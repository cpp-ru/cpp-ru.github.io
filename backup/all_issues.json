[
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/590",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/590/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/590/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/590/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/590",
    "id": 2176047524,
    "node_id": "I_kwDOFK7cns6Bs9mk",
    "number": 590,
    "title": "Новый манипулятор вывода чисел с плавающей точкой",
    "user": {
      "login": "asherikov",
      "id": 923021,
      "node_id": "MDQ6VXNlcjkyMzAyMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/923021?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asherikov",
      "html_url": "https://github.com/asherikov",
      "followers_url": "https://api.github.com/users/asherikov/followers",
      "following_url": "https://api.github.com/users/asherikov/following{/other_user}",
      "gists_url": "https://api.github.com/users/asherikov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asherikov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asherikov/subscriptions",
      "organizations_url": "https://api.github.com/users/asherikov/orgs",
      "repos_url": "https://api.github.com/users/asherikov/repos",
      "events_url": "https://api.github.com/users/asherikov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asherikov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2024-03-08T13:29:12Z",
    "updated_at": "2024-03-25T14:32:29Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Добавить манипулятор вывода чисел с плавающей точкой для компактного форматирования без потери точности и типа, существующие механизмы этого не позволяют (https://en.cppreference.com/w/cpp/io/manip):\r\n\r\n- `std::setprecision` низкоуровневая функция, в сочетании со стандартным форматированием целочисленных значений теряется точка при выводе, что приводит к потере информации о типе и возможным проблемам в обрабатывающем коде на других языках;\r\n- вывод `std::scientific` или `std::setprecision` + `std::showpoint` избыточен.\r\n\r\nПример:\r\n```\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <limits>\r\n\r\nint main()\r\n{\r\n    double a = 1.;\r\n    double b = 0.0000000000001;\r\n\r\n    std::cout << a << \" | \"  << b << std::endl;\r\n    std::cout << std::scientific << a << \" | \"  << b << std::endl;\r\n    std::cout << std::defaultfloat;\r\n    std::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1) << a << \" | \" << b << std::endl;\r\n    std::cout << std::defaultfloat;\r\n    std::cout << std::showpoint << std::setprecision(std::numeric_limits<long double>::digits10 + 1) << a << \" | \" << b << std::endl;\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nРезультат:\r\n```\r\n1 | 1e-13\r\n1.000000e+00 | 1.000000e-13\r\n1 | 1.00000000000000003e-13\r\n1.000000000000000000 | 1.000000000000000030e-13\r\n```\r\n\r\nХочется:\r\n```\r\n// std::cout << std::numericdata << a << \" | \" << b << std::endl;\r\n1. | 1.00000000000000003e-13\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/590/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/590/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/589",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/589/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/589/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/589/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/589",
    "id": 2167487020,
    "node_id": "I_kwDOFK7cns6BMTos",
    "number": 589,
    "title": "Предложение по улучшению",
    "user": {
      "login": "hagz0r",
      "id": 48390403,
      "node_id": "MDQ6VXNlcjQ4MzkwNDAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/48390403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hagz0r",
      "html_url": "https://github.com/hagz0r",
      "followers_url": "https://api.github.com/users/hagz0r/followers",
      "following_url": "https://api.github.com/users/hagz0r/following{/other_user}",
      "gists_url": "https://api.github.com/users/hagz0r/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hagz0r/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hagz0r/subscriptions",
      "organizations_url": "https://api.github.com/users/hagz0r/orgs",
      "repos_url": "https://api.github.com/users/hagz0r/repos",
      "events_url": "https://api.github.com/users/hagz0r/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hagz0r/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2024-03-04T18:37:17Z",
    "updated_at": "2024-03-24T15:29:21Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Я хочу чтобы программы на языке С++ выполнялись быстрее, были безопасными и не допускали ошибок!\r\n\r\nПримеры мы можем увидеть в реализации таких языков как Rust, JavaScript. \r\n\r\nКод:\r\n```rust\r\nfn main() {\r\n  println!(\"Make C++ faster!\");\r\n}\r\n```\r\n```js\r\nconsole.log(\"Make C++ faster!\")\r\n```\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/589/reactions",
      "total_count": 18,
      "+1": 9,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 7,
      "eyes": 2
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/589/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/588",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/588/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/588/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/588/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/588",
    "id": 2067995861,
    "node_id": "I_kwDOFK7cns57QxzV",
    "number": 588,
    "title": "why one of my inputs is empty?",
    "user": {
      "login": "Huseyn201",
      "id": 140795743,
      "node_id": "U_kgDOCGRfXw",
      "avatar_url": "https://avatars.githubusercontent.com/u/140795743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Huseyn201",
      "html_url": "https://github.com/Huseyn201",
      "followers_url": "https://api.github.com/users/Huseyn201/followers",
      "following_url": "https://api.github.com/users/Huseyn201/following{/other_user}",
      "gists_url": "https://api.github.com/users/Huseyn201/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Huseyn201/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Huseyn201/subscriptions",
      "organizations_url": "https://api.github.com/users/Huseyn201/orgs",
      "repos_url": "https://api.github.com/users/Huseyn201/repos",
      "events_url": "https://api.github.com/users/Huseyn201/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Huseyn201/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2024-01-05T20:29:29Z",
    "updated_at": "2024-01-06T10:08:12Z",
    "closed_at": "2024-01-06T10:08:12Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "my input:\r\n3\r\ngr\r\nsud\r\nabc\r\n\r\n```\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    int n;\r\n    cin>>n;\r\n    string a[1000];\r\n    string s,b;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        getline(cin,b);\r\n        a[i]=b;\r\n    }\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/588/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/588/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/587",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/587/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/587/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/587/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/587",
    "id": 2062703169,
    "node_id": "I_kwDOFK7cns568lpB",
    "number": 587,
    "title": "linalg в C++26.",
    "user": {
      "login": "Gigachader007",
      "id": 147135728,
      "node_id": "U_kgDOCMUc8A",
      "avatar_url": "https://avatars.githubusercontent.com/u/147135728?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Gigachader007",
      "html_url": "https://github.com/Gigachader007",
      "followers_url": "https://api.github.com/users/Gigachader007/followers",
      "following_url": "https://api.github.com/users/Gigachader007/following{/other_user}",
      "gists_url": "https://api.github.com/users/Gigachader007/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Gigachader007/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Gigachader007/subscriptions",
      "organizations_url": "https://api.github.com/users/Gigachader007/orgs",
      "repos_url": "https://api.github.com/users/Gigachader007/repos",
      "events_url": "https://api.github.com/users/Gigachader007/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Gigachader007/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2024-01-02T17:04:15Z",
    "updated_at": "2024-03-24T09:56:34Z",
    "closed_at": "2024-03-24T09:56:34Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Требую добавить полностью библиотеку glm в стандартную библиотеку.\r\n\r\nДанное решение позволит заниматься обычной линейной алгеброй, при этом не приспосабливаться к новой стандартной реализации линейной алгебры (linalg), а использовать уже привычную библиотеку glm со всеми вещами.\r\n\r\nПолезные ссылки:\r\n* https://github.com/g-truc/glm - GLM",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/587/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 0,
      "laugh": 2,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/587/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/586",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/586/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/586/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/586/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/586",
    "id": 2044227976,
    "node_id": "I_kwDOFK7cns552HGI",
    "number": 586,
    "title": "__int128_t",
    "user": {
      "login": "Huseyn201",
      "id": 140795743,
      "node_id": "U_kgDOCGRfXw",
      "avatar_url": "https://avatars.githubusercontent.com/u/140795743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Huseyn201",
      "html_url": "https://github.com/Huseyn201",
      "followers_url": "https://api.github.com/users/Huseyn201/followers",
      "following_url": "https://api.github.com/users/Huseyn201/following{/other_user}",
      "gists_url": "https://api.github.com/users/Huseyn201/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Huseyn201/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Huseyn201/subscriptions",
      "organizations_url": "https://api.github.com/users/Huseyn201/orgs",
      "repos_url": "https://api.github.com/users/Huseyn201/repos",
      "events_url": "https://api.github.com/users/Huseyn201/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Huseyn201/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-12-15T18:59:24Z",
    "updated_at": "2024-02-23T15:43:52Z",
    "closed_at": "2024-02-23T15:43:51Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Здравствуйте, я пишу обычный код на с++ с типом __int128_t, но у меня возникает проблема при вводе,выводе.\r\nВот мой код:\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    __int128_t n,result;\r\n    cin >> n;\r\n    result=pow(5,n);\r\n    cout<<result;\r\n}\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/586/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/586/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/585",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/585/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/585/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/585/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/585",
    "id": 2025387541,
    "node_id": "I_kwDOFK7cns54uPYV",
    "number": 585,
    "title": "Добавляем недостающие type-erased перегрузки `std::format` и `std::print`",
    "user": {
      "login": "HolyBlackCat",
      "id": 20289055,
      "node_id": "MDQ6VXNlcjIwMjg5MDU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/20289055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/HolyBlackCat",
      "html_url": "https://github.com/HolyBlackCat",
      "followers_url": "https://api.github.com/users/HolyBlackCat/followers",
      "following_url": "https://api.github.com/users/HolyBlackCat/following{/other_user}",
      "gists_url": "https://api.github.com/users/HolyBlackCat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/HolyBlackCat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/HolyBlackCat/subscriptions",
      "organizations_url": "https://api.github.com/users/HolyBlackCat/orgs",
      "repos_url": "https://api.github.com/users/HolyBlackCat/repos",
      "events_url": "https://api.github.com/users/HolyBlackCat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/HolyBlackCat/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-12-05T06:36:40Z",
    "updated_at": "2023-12-23T08:13:40Z",
    "closed_at": "2023-12-23T08:13:40Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Допустим, хочется напечатать через `std::print` не напрямую в stdout/stderr/`FILE *`, а в type-erased колбек.\r\n\r\n<details>\r\n\r\n<summary>Пример печати в колбек</summary>\r\n\r\n```сpp\r\n#include <cstdio>\r\n#include <functional>\r\n#include <print>\r\n#include <utility>\r\n\r\nstruct Printer\r\n{\r\n    using callback_t = std::function<void(std::string_view fmt, std::format_args args)>;\r\n    callback_t callback;\r\n\r\n    template <class ...Args>\r\n    void print(std::format_string<Args...> fmt, Args &&...args)\r\n    {\r\n        callback(fmt.get(), std::make_format_args(args...));\r\n    }\r\n\r\n    Printer(callback_t callback) : callback(std::move(callback)) {}\r\n\r\n    Printer(FILE *file)\r\n        : Printer([file](std::string_view fmt, std::format_args args)\r\n        {\r\n            std::vprint_unicode(file, fmt, args);\r\n        })\r\n    {}\r\n};\r\n\r\nint main()\r\n{\r\n    Printer p(stdout);\r\n    p.print(\"Hello, {}!\", \"World\");\r\n}\r\n```\r\n</details>\r\n\r\nВ теории это должно быть просто, по аналогии с `std::vprintf`, но на практике вылезает сырость API:\r\n\r\n* При переходе с `std::print` на `std::vprint`, я должен руками выбирать между `std::vprint_unicode` и `std::vprint_nonunicode`.\r\n* И наоборот, если мне не нужно type erasure, я не могу принудительно выбрать unicode или его отсутствие, нет `std::print_[non]unicode`.\r\n\r\n* Нет `std::vprintln`. Вроде мелочь, но как удобно дописать `\\n` непонятно. Либо копировать строку формата в `std::string` чтобы дописать `\\n`, либо дергать `std::fputc('\\n', file)` - и то и то странно.\r\n\r\n* В качестве бонуса, нет  `std::vformat_to_n`, есть только `std::vformat_to`. Хотя `std::format_to_n` есть.\r\n\r\nКак это чинить?\r\n\r\n* Добавить `std::vformat_to_n` - тут все просто.\r\n\r\n* Про `std::vprint` я не совсем уверен. Можно просто добавить `std::vprint` и `std::print_[non]unicode`, а с отсутствием `vprintln` ничего не делать, потому что в  libfmt он все равно [реализован через временный буфер](https://github.com/fmtlib/fmt/blob/5d55375a8a6aabf39528bdf48f7b3ded5ef4e9bb/include/fmt/core.h#L2932C48-L2932C48).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/585/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/585/timeline",
    "performed_via_github_app": null,
    "state_reason": "not_planned"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/584",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/584/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/584/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/584/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/584",
    "id": 2023154902,
    "node_id": "I_kwDOFK7cns54luTW",
    "number": 584,
    "title": "Аналог GetModuleFileName",
    "user": {
      "login": "astafiev555",
      "id": 79691352,
      "node_id": "MDQ6VXNlcjc5NjkxMzUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/79691352?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/astafiev555",
      "html_url": "https://github.com/astafiev555",
      "followers_url": "https://api.github.com/users/astafiev555/followers",
      "following_url": "https://api.github.com/users/astafiev555/following{/other_user}",
      "gists_url": "https://api.github.com/users/astafiev555/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/astafiev555/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/astafiev555/subscriptions",
      "organizations_url": "https://api.github.com/users/astafiev555/orgs",
      "repos_url": "https://api.github.com/users/astafiev555/repos",
      "events_url": "https://api.github.com/users/astafiev555/events{/privacy}",
      "received_events_url": "https://api.github.com/users/astafiev555/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-12-04T06:53:23Z",
    "updated_at": "2023-12-04T06:53:23Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Очень не хватает в современном стандарте функции, которая возвращает абсолютный путь относительно исполняемого файла (получение текущей директории - типа getCWD не подходит в некоторых случаях, т.к. текущая директория не обязана всегда указывать на папку, где лежит исполняемый файл)\r\n\r\n(Требуется очень часто загружать какие-то конфигурационные файлы из папок, расположение которых жёстко фиксировано относительно исполняемого файла)\r\n\r\nОдин из вариантов реализации такой функции (get_main_module_path, пример):\r\n\r\n#include <filesystem>\r\n\r\nstd::filesystem::path get_main_module_path();\r\n\r\n#ifdef _MSC_VER\r\n#define WIN32_LEAN_AND_MEAN\r\n#include <windows.h>\r\n#include <tchar.h>\r\n\r\nstd::filesystem::path get_main_module_path() {\r\n  TCHAR gPath[FILENAME_MAX + 1];\r\n  int32_t sz = GetModuleFileName(nullptr, gPath, FILENAME_MAX);\r\n  if (sz >= 0) {\r\n    gPath[sz] = _T('\\0');\r\n  }\r\n  TCHAR *fnd = _tcsrchr(gPath, _T('\\\\'));\r\n  if (fnd) {\r\n    fnd[1] = _T('\\0');\r\n  }\r\n  std::filesystem::path ret = gPath;\r\n  return ret;\r\n}\r\n#else\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <unistd.h>\r\n\r\nstd::filesystem::path get_main_module_path() {\r\n  char gPath[FILENAME_MAX + 1];\r\n  char buff[64];\r\n  uint32_t pid = (uint32_t)getpid();\r\n  int32_t sz = 0;\r\n#if defined(__sun) || defined(sun)\r\n  sprintf(buff, \"/proc/%u/path/a.out\", pid);\r\n#else\r\n  sprintf(buff, \"/proc/%u/exe\", pid);\r\n  sz = (int32_t)readlink(buff, gPath, FILENAME_MAX);\r\n#endif\r\n  if (sz >= 0) {\r\n    gPath[sz] = '\\0';\r\n  }\r\n  char *fnd = strrchr(gPath, '/');\r\n  if (fnd) {\r\n    fnd[1] = '\\0';\r\n  }\r\n  std::filesystem::path ret = gPath;\r\n  return ret;\r\n}\r\n#endif\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/584/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/584/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/583",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/583/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/583/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/583/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/583",
    "id": 2007749675,
    "node_id": "I_kwDOFK7cns53q9Qr",
    "number": 583,
    "title": "Наследование enum class",
    "user": {
      "login": "mcroitor",
      "id": 1931103,
      "node_id": "MDQ6VXNlcjE5MzExMDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1931103?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mcroitor",
      "html_url": "https://github.com/mcroitor",
      "followers_url": "https://api.github.com/users/mcroitor/followers",
      "following_url": "https://api.github.com/users/mcroitor/following{/other_user}",
      "gists_url": "https://api.github.com/users/mcroitor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mcroitor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mcroitor/subscriptions",
      "organizations_url": "https://api.github.com/users/mcroitor/orgs",
      "repos_url": "https://api.github.com/users/mcroitor/repos",
      "events_url": "https://api.github.com/users/mcroitor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mcroitor/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-11-23T08:58:10Z",
    "updated_at": "2023-11-23T08:58:10Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Не хватает наследования `enum class`.\r\n\r\nНа данный момент возможен следующий код:\r\n```cpp\r\n#include <iostream>\r\n\r\nenum class pin_type: uint8_t\r\n{\r\n    d0, d1, d2, a0 = 10, a1,\r\n};\r\nenum class digital_pin_type: uint8_t {\r\n    d0, d1, d2,\r\n};\r\nenum class analog_pin_type: uint8_t {\r\n    a0 = 10, a1,\r\n};\r\n\r\nint main()\r\n{\r\n    pin_type pin = static_cast<pin_type>(analog_pin_type::a0); // ok\r\n    digital_pin_type dpin = static_cast<digital_pin_type>(pin_type::d1); // ok\r\n    analog_pin_type apin = static_cast<analog_pin_type>(pin_type::d1); // logic error, but works\r\n\r\n    std::cout << (size_t)pin << \" \" << (size_t)dpin << \" \" << (size_t)apin;\r\n    return 0;\r\n}\r\n```\r\nОднако в нем отслеживание на правильность связи между перечислениями ложится на разработчика. Поэтому хочется иметь возможность указать зависимость (наследование) одного перечисления от другого. Ожидаемый код:\r\n```cpp\r\n#include <iostream>\r\n\r\nenum class pin_type: uint8_t\r\n{\r\n    d0, d1, d2, a0 = 10, a1,\r\n};\r\nenum class digital_pin_type: pin_type {\r\n    d0 = pin_type:d0, d1, d2,\r\n};\r\nenum class analog_pin_type: pin_type {\r\n    a0 = pin_type:a0, a1,\r\n};\r\n\r\nint main()\r\n{\r\n    pin_type pin = analog_pin_type::a0; // ok\r\n    digital_pin_type dpin = pin_type::d1; // ok\r\n    analog_pin_type apin = pin_type::d1; // compile error\r\n\r\n    std::cout << (size_t)pin << \" \" << (size_t)dpin << \" \" << (size_t)apin;\r\n    return 0;\r\n}\r\n```\r\nОжидаемые свойства:\r\n\r\n* дочернее перечисление содержит некоторый набор значений из базового перечисления\r\n* дочернее перечисление может содержать псевдонимы значений\r\n* дочернее перечисление не содержит других значений, на совместимых с базовым перечислением\r\n* неявное приведение типов, дочернего к базовому\r\n* при приведении типов от базового к дочернему выдача ошибки / предупреждения",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/583/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/583/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/582",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/582/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/582/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/582/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/582",
    "id": 1994664228,
    "node_id": "I_kwDOFK7cns525Ckk",
    "number": 582,
    "title": "Аналог метода extract для std::set/std::map, когда исходный контейнер больше не потребуется",
    "user": {
      "login": "prigluchenie",
      "id": 76661639,
      "node_id": "MDQ6VXNlcjc2NjYxNjM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/76661639?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prigluchenie",
      "html_url": "https://github.com/prigluchenie",
      "followers_url": "https://api.github.com/users/prigluchenie/followers",
      "following_url": "https://api.github.com/users/prigluchenie/following{/other_user}",
      "gists_url": "https://api.github.com/users/prigluchenie/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prigluchenie/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prigluchenie/subscriptions",
      "organizations_url": "https://api.github.com/users/prigluchenie/orgs",
      "repos_url": "https://api.github.com/users/prigluchenie/repos",
      "events_url": "https://api.github.com/users/prigluchenie/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prigluchenie/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-11-15T12:15:40Z",
    "updated_at": "2023-11-15T12:53:36Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Проблема\r\nДля переноса узла std::set в другой экземпляр контейнера (возможно, с попутной модификацией ключа) есть метод extract, который позволяет переиспользовать аллокацию. Однако частно это требуется сделать для всех элементов контейнера, и исходный контейнер больше не нужен.\r\n\r\nПример, как можно реализовать условную задачу сейчас\r\n\r\n```\r\nstd::set<std::string> input{\"a\", \"b\", \"c\"}; \r\nstd::set<std::string> output_good, output_bad;\r\n\r\nwhile(!input.empty()) {\r\n\tauto node_handler = input.extract(input.begin());\r\n\tif (is_good(node_handler.value()) {\r\n\t\tnode_handler.value() += '!';\r\n\t\toutput_good.insert(std::move(node_handler));\r\n\t} else {\r\n\t\toutput_bad.insert(std::move(node_handler));\r\n\t}\r\n}\r\n```\r\n\r\nНедостаток этого решения в том, что между итерациями цикла приходится восстанавливать инварианты черно-красного дерева, что избыточно, т.к. объект больше не требуется (в итоге заведомо остается пустой).\r\n\r\nПредлагается добавить метод extract_each (условно), который бы позволял максимально эффективно разобрать дерево на отдельные ноды целиком.\r\n\r\nНапример, код решения исходной задачи с таким методом мог бы выглядеть как-то так\r\n\r\n```\r\nstd::move(input).extract_each([&output_good, &output_bad](auto node_handler) {\r\n\tif (is_good(node_handler.value()) {\r\n\t\tnode_handler.value() += '!';\r\n\t\toutput_good.insert(std::move(node_handler));\r\n\t} else {\r\n\t\toutput_bad.insert(std::move(node_handler));\r\n\t}\r\n});\r\n```\r\n\r\nМожно подумать и над вариантом метода extract с дополнительными параметрами диапазона итераторов from, to, и с аналогичным функтором для передачи владения узлами.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/582/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/582/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/581",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/581/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/581/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/581/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/581",
    "id": 1986259687,
    "node_id": "I_kwDOFK7cns52Y-rn",
    "number": 581,
    "title": "Перечисление пространств имён через запятую после using namespace",
    "user": {
      "login": "daniilrozanov",
      "id": 65226211,
      "node_id": "MDQ6VXNlcjY1MjI2MjEx",
      "avatar_url": "https://avatars.githubusercontent.com/u/65226211?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/daniilrozanov",
      "html_url": "https://github.com/daniilrozanov",
      "followers_url": "https://api.github.com/users/daniilrozanov/followers",
      "following_url": "https://api.github.com/users/daniilrozanov/following{/other_user}",
      "gists_url": "https://api.github.com/users/daniilrozanov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/daniilrozanov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/daniilrozanov/subscriptions",
      "organizations_url": "https://api.github.com/users/daniilrozanov/orgs",
      "repos_url": "https://api.github.com/users/daniilrozanov/repos",
      "events_url": "https://api.github.com/users/daniilrozanov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/daniilrozanov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-11-09T19:22:23Z",
    "updated_at": "2023-12-11T21:56:37Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Вместо того, чтобы тратить строчки с несколькими `using namespace X`, предлагается разрешить после директивы `using namespace` перечислять пространства имён через запятую.\r\n\r\nПример:\r\n\r\n```cpp\r\n// ...\r\nvoid foo() {\r\n  // using namespace ranges;\r\n  // using namespace ranges::view;\r\n  using namespace ranges, ranges::view;\r\n  sort(arr, my_cmp); // ranges::sort\r\n  for (X& x : arr | filter(&filters::even, &X::number)) // ranges::view::filter\r\n    std::cout << x << std::endl;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/581/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/581/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/580",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/580/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/580/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/580/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/580",
    "id": 1957240606,
    "node_id": "I_kwDOFK7cns50qR8e",
    "number": 580,
    "title": "Разрешить shebang в C++",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-10-23T13:56:25Z",
    "updated_at": "2024-02-28T12:21:34Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_Разрешить shebang в C++ препроцессоре_\r\n\r\nПожалуй C++ один из немногих популярных языков программирования где компилятор всё ещё запрещает shebang.\r\n\r\nВ итоге на C++ проектах можно увидеть целый зоопарк разных скриптов написанных на bash/ch/perl/python/go для решения задач связанных со сборкой, тестированием или деплоем.\r\n\r\nЭта фича вместе с #558 может открыть новую сферу для применения C++ которую до этого занимали скриптовые языки.\r\n\r\nПолезные ссылки:\r\n* https://en.wikipedia.org/wiki/Shebang_(Unix)\r\n* https://habr.com/ru/articles/488962/",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/580/reactions",
      "total_count": 4,
      "+1": 1,
      "-1": 3,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/580/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/579",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/579/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/579/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/579/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/579",
    "id": 1898244169,
    "node_id": "I_kwDOFK7cns5xJOhJ",
    "number": 579,
    "title": "Однократный вызов кода (как создание static переменных)",
    "user": {
      "login": "IvanK-work",
      "id": 62900448,
      "node_id": "MDQ6VXNlcjYyOTAwNDQ4",
      "avatar_url": "https://avatars.githubusercontent.com/u/62900448?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/IvanK-work",
      "html_url": "https://github.com/IvanK-work",
      "followers_url": "https://api.github.com/users/IvanK-work/followers",
      "following_url": "https://api.github.com/users/IvanK-work/following{/other_user}",
      "gists_url": "https://api.github.com/users/IvanK-work/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/IvanK-work/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/IvanK-work/subscriptions",
      "organizations_url": "https://api.github.com/users/IvanK-work/orgs",
      "repos_url": "https://api.github.com/users/IvanK-work/repos",
      "events_url": "https://api.github.com/users/IvanK-work/events{/privacy}",
      "received_events_url": "https://api.github.com/users/IvanK-work/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-09-15T11:34:53Z",
    "updated_at": "2023-09-15T13:11:57Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Если мы можем сказать компилятору - \"создай эту переменную только один раз, как только мы дошли до этого места\", почему бы на не сказать ему - \"выполни этот код один раз, как только мы дошли до этого места\". \r\n\r\nДо:\r\n``` C++\r\nbool is_call_first_time=true;\r\nvoid foo()\r\n{\r\n   if(is_call_first_time)\r\n   {\r\n       // code...\r\n      is_call_first_time = false;\r\n   }\r\n....\r\n....\r\n\r\n}\r\n```\r\n\r\nПосле:\r\n\r\n```` C++\r\nvoid foo()\r\n{\r\n  static{\r\n       // code...\r\n   };\r\n....\r\n....\r\n}\r\n\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/579/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/579/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/578",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/578/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/578/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/578/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/578",
    "id": 1892397370,
    "node_id": "I_kwDOFK7cns5wy7E6",
    "number": 578,
    "title": "оптимизация coroutine initial/final",
    "user": {
      "login": "marakew",
      "id": 3596295,
      "node_id": "MDQ6VXNlcjM1OTYyOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3596295?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marakew",
      "html_url": "https://github.com/marakew",
      "followers_url": "https://api.github.com/users/marakew/followers",
      "following_url": "https://api.github.com/users/marakew/following{/other_user}",
      "gists_url": "https://api.github.com/users/marakew/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marakew/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marakew/subscriptions",
      "organizations_url": "https://api.github.com/users/marakew/orgs",
      "repos_url": "https://api.github.com/users/marakew/repos",
      "events_url": "https://api.github.com/users/marakew/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marakew/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-09-12T12:19:02Z",
    "updated_at": "2024-03-24T17:03:42Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "а не хотят ли в много уважаемом комитете сделать подарок к С++26\r\n\r\nи сделать initial_suspend() и final_suspend() опциональными\r\n\r\nчестно говоря утомляет их постоянно писать когда их нет смысла использовать",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/578/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/578/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/577",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/577/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/577/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/577/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/577",
    "id": 1889268915,
    "node_id": "I_kwDOFK7cns5wm_Sz",
    "number": 577,
    "title": "Возможность использовать auto в качестве типового параметра другого типа",
    "user": {
      "login": "evilenzo",
      "id": 89089095,
      "node_id": "MDQ6VXNlcjg5MDg5MDk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/89089095?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/evilenzo",
      "html_url": "https://github.com/evilenzo",
      "followers_url": "https://api.github.com/users/evilenzo/followers",
      "following_url": "https://api.github.com/users/evilenzo/following{/other_user}",
      "gists_url": "https://api.github.com/users/evilenzo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/evilenzo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/evilenzo/subscriptions",
      "organizations_url": "https://api.github.com/users/evilenzo/orgs",
      "repos_url": "https://api.github.com/users/evilenzo/repos",
      "events_url": "https://api.github.com/users/evilenzo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/evilenzo/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-09-10T17:56:53Z",
    "updated_at": "2023-09-13T10:14:03Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "### Описание\r\nНа данный момент если мы хотим иметь какой-то констрейнт для шаблонного типа, мы пишем что-то в таком духе:\r\n```cpp\r\ntemplate <typename T>\r\nvoid foo(std::optional<T> opt_arg);\r\n``` \r\nЭто полезно и для пользователя, т.к. в объявлении он явно видит, что аргумент, например, обёрнут optional'ом, и для разработчика, т.к. он получает автокомплит от IDE.\r\nНо есть и несколько минусов, например, излишняя вербозность, в особенности, когда имя типа больше использоваться не будет.\r\nС 20-м стандартом появилась возможность переписать код подобным образом:\r\n```cpp\r\ntemplate<typename T>\r\nstruct is_optional : std::false_type {};\r\n\r\ntemplate <typename T>\r\nstruct is_optional<std::optional<T>> : std::true_type {};\r\n\r\ntemplate <typename T>\r\nconcept Optional = is_optional<T>::value;\r\n\r\n/* В некоторых случаях можно сделать так:\r\ntemplate <typename T>\r\nconcept Optional = std::is_same_v<std::optional<T::value_type>, T>;\r\n*/\r\n\r\nvoid foo(Optional auto opt_arg);\r\n```\r\nНо вербозность это не особо уменьшает и всё ещё имеет множество минусов, например, нужда реализовывать такие констрейнты под каждый тип.\r\nЧтобы решить проблему, предлагается такая запись:\r\n```cpp\r\nvoid foo(std::optional<auto> opt_arg);\r\n```\r\nЛибо, как вариант, вообще самостоятельно не писать шаблонные параметры и разрешить такую запись:\r\n```cpp\r\nvoid foo(std::optional opt_arg);\r\n```\r\n### Мотивация \r\nКак было сказано выше, уменьшить вербозность, не писать лишний код, когда нам неинтересен сам тип, при этом иметь автокомплит и полезную информацию для пользователя.\r\n### Сложности\r\nНужно решить вопрос с несколькими параметрами у типа. Пример:\r\n```cpp\r\ntemplate <typename A, typename B>\r\nstruct TwoParams {};\r\n\r\n// Вариант 1\r\nvoid foo(TwoParams<auto, auto> arg);\r\n\r\n// Вариант 2\r\nvoid foo(TwoParams<auto> arg);\r\n\r\n// Вариант 3\r\nvoid foo(TwoParams<auto...> arg);\r\n```\r\nВ случае с третьим вариантом есть вопросы по другим нюансам, например, когда таких аргументов несколько.\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/577/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/576",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/576/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/576/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/576/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/576",
    "id": 1886555635,
    "node_id": "I_kwDOFK7cns5wco3z",
    "number": 576,
    "title": "Стандартизировать макрос __COUNTER__",
    "user": {
      "login": "kov-serg",
      "id": 5946122,
      "node_id": "MDQ6VXNlcjU5NDYxMjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5946122?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kov-serg",
      "html_url": "https://github.com/kov-serg",
      "followers_url": "https://api.github.com/users/kov-serg/followers",
      "following_url": "https://api.github.com/users/kov-serg/following{/other_user}",
      "gists_url": "https://api.github.com/users/kov-serg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kov-serg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kov-serg/subscriptions",
      "organizations_url": "https://api.github.com/users/kov-serg/orgs",
      "repos_url": "https://api.github.com/users/kov-serg/repos",
      "events_url": "https://api.github.com/users/kov-serg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kov-serg/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-09-07T20:57:44Z",
    "updated_at": "2024-01-01T21:07:31Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Стандартизировать макрос `__COUNTER__`\r\n\r\nЧто бы не городить такое https://github.com/madmurphy/zen.h/blob/master/zen.h\r\n\r\nПолезные ссылки:\r\nhttps://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html\r\nhttps://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros\r\nhttps://clang.llvm.org/docs/LanguageExtensions.html#builtin-macros",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/576/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/576/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/575",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/575/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/575/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/575/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/575",
    "id": 1868527002,
    "node_id": "I_kwDOFK7cns5vX3Wa",
    "number": 575,
    "title": "\"Безопасные\" приведения целочисленных типов",
    "user": {
      "login": "romasandu-gaijin",
      "id": 141152553,
      "node_id": "U_kgDOCGnRKQ",
      "avatar_url": "https://avatars.githubusercontent.com/u/141152553?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/romasandu-gaijin",
      "html_url": "https://github.com/romasandu-gaijin",
      "followers_url": "https://api.github.com/users/romasandu-gaijin/followers",
      "following_url": "https://api.github.com/users/romasandu-gaijin/following{/other_user}",
      "gists_url": "https://api.github.com/users/romasandu-gaijin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/romasandu-gaijin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/romasandu-gaijin/subscriptions",
      "organizations_url": "https://api.github.com/users/romasandu-gaijin/orgs",
      "repos_url": "https://api.github.com/users/romasandu-gaijin/repos",
      "events_url": "https://api.github.com/users/romasandu-gaijin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/romasandu-gaijin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2023-08-27T15:01:58Z",
    "updated_at": "2023-10-31T21:15:19Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "На горизонте контракты. В связи с этим хочется автоматизировать довольно часто встречающийся на практике отрывок кода:\r\n```\r\nstd::vector<uint16_t> data;\r\nvoid foo(int x)\r\n{\r\n    assert(0 <= x && x <= std::numeric_limits<uint16_t>::max());\r\n    data.push_back(static_cast<uint16_t>(x));\r\n}\r\n```\r\nОбычно такое выходит, когда \"по дефолту\" в публичных интерфейсах ставят простые типы, а потом оказывается, что на самом деле хватит 16 или даже 8 бит, имплементацию меняют для экономии памяти/перфа, а публичное АПИ менять нельзя (не хочется, сложно, ...). Но кажется и другие кейсы не сложно придумать.\r\n\r\nИдея следующая:\r\n```\r\n// <numeric>\r\nnamespace std\r\n{\r\ntemplate<std::integral T, std::integral U>\r\nT integral_cast(U u)\r\n    [[pre: std::numeric_limits<T>::min() <= u]]\r\n    [[pre: u <= std::numeric_limits<T>::max()]]\r\n    [[post r: static_cast<U>(r) == u]] // возможно не нужно?\r\n{\r\n    return static_cast<T>(u);\r\n}\r\n}\r\n```\r\nТаким образом получаем явную передачу намерения \"я точно знаю, что должно влезть, приведение по модулю 2^n -- ошибка\", плюс автоматическую ловлю багов в режиме проверки контрактов в рантайме.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/575/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/575/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/574",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/574/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/574/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/574/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/574",
    "id": 1865181893,
    "node_id": "I_kwDOFK7cns5vLGrF",
    "number": 574,
    "title": "Добавить std::prefetch() функцию",
    "user": {
      "login": "klappdev",
      "id": 40568872,
      "node_id": "MDQ6VXNlcjQwNTY4ODcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/40568872?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/klappdev",
      "html_url": "https://github.com/klappdev",
      "followers_url": "https://api.github.com/users/klappdev/followers",
      "following_url": "https://api.github.com/users/klappdev/following{/other_user}",
      "gists_url": "https://api.github.com/users/klappdev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/klappdev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/klappdev/subscriptions",
      "organizations_url": "https://api.github.com/users/klappdev/orgs",
      "repos_url": "https://api.github.com/users/klappdev/repos",
      "events_url": "https://api.github.com/users/klappdev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/klappdev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-08-24T13:38:34Z",
    "updated_at": "2024-03-24T15:38:49Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В последние стандарты активно добавлялись вещи для оптимизации кода.\r\nНапример, в C++20 были добавлены атрибуты _[[likely]]_, _[[unlikely]]_.\r\nВ C++23 было добавлено атрибут _[[assume]]_, функция _std::unreachable()_.\r\n\r\nОдним из таких техник оптимизации является префектичинг кеша процессора.\r\n\r\nВо многих компиляторах, это доступно в виде интринсиков.\r\nhttps://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005fprefetch\r\nhttps://clang.llvm.org/docs/LanguageExtensions.html#builtin-prefetch\r\n\r\nВ boost.context есть уже такая функция.\r\nhttps://www.boost.org/doc/libs/1_81_0/boost/context/detail/prefetch.hpp\r\n\r\nПланируется также добавить в boost.core.\r\nhttps://github.com/boostorg/core/issues/136\r\n\r\nПредлагается добавить в С++ переносимую _std::prefetch()_ функцию.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/574/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/574/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/573",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/573/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/573/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/573/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/573",
    "id": 1865146178,
    "node_id": "I_kwDOFK7cns5vK99C",
    "number": 573,
    "title": "Добавить std::make_unique_nothrow() и std::make_shared_nothrow() функции",
    "user": {
      "login": "klappdev",
      "id": 40568872,
      "node_id": "MDQ6VXNlcjQwNTY4ODcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/40568872?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/klappdev",
      "html_url": "https://github.com/klappdev",
      "followers_url": "https://api.github.com/users/klappdev/followers",
      "following_url": "https://api.github.com/users/klappdev/following{/other_user}",
      "gists_url": "https://api.github.com/users/klappdev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/klappdev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/klappdev/subscriptions",
      "organizations_url": "https://api.github.com/users/klappdev/orgs",
      "repos_url": "https://api.github.com/users/klappdev/repos",
      "events_url": "https://api.github.com/users/klappdev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/klappdev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-08-24T13:20:36Z",
    "updated_at": "2024-03-24T15:39:41Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Использование _std::make_unique()_ и _std::make_shared()_ может привести к киданию исключение _std::bad_alloc_, если памяти не достаточно.\r\nВ таких случаях, необходимо использовать оператор _new_ с _std::nothrow_.\r\n```C++\r\n#include <memory>\r\n\r\nstd::unique_ptr<T> p = new(std::nothrow) T();\r\n```\r\n\r\nФункции _std::make_shared()_ и _std::make_unique()_ более эффективны и могут предотвратить двойное выделения памяти.\r\nПредлагается добавить _std::make_unique_nothrow()_ и _std::make_shared_nothrow()_ функции, которые можно  реализовано следующим образом.\r\n\r\n```C++\r\ntemplate <class T, class... Args>\r\nstd::unique_ptr<T> make_unique_nothrow(Args&&... args)\r\n    noexcept(noexcept(T(std::forward<Args>(args)...)))\r\n{\r\n    return std::unique_ptr<T>(new (std::nothrow) T(std::forward<Args>(args)...));\r\n}\r\n\r\ntemplate <class T, class... Args>\r\nstd::shared_ptr<T> make_shared_nothrow(Args&&... args)\r\n    noexcept(noexcept(T(std::forward<Args>(args)...)))\r\n{\r\n    return std::shared_ptr<T>(new (std::nothrow) T(std::forward<Args>(args)...));\r\n}\r\n```\r\n\r\nВ библиотеке boost уже реализована подобные функции \r\nhttps://www.boost.org/doc/libs/1_63_0/boost/move/make_unique.hpp",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/573/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/573/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/572",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/572/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/572/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/572/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/572",
    "id": 1865132500,
    "node_id": "I_kwDOFK7cns5vK6nU",
    "number": 572,
    "title": "Добавить std::int128_t, std::uint128_t типы",
    "user": {
      "login": "klappdev",
      "id": 40568872,
      "node_id": "MDQ6VXNlcjQwNTY4ODcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/40568872?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/klappdev",
      "html_url": "https://github.com/klappdev",
      "followers_url": "https://api.github.com/users/klappdev/followers",
      "following_url": "https://api.github.com/users/klappdev/following{/other_user}",
      "gists_url": "https://api.github.com/users/klappdev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/klappdev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/klappdev/subscriptions",
      "organizations_url": "https://api.github.com/users/klappdev/orgs",
      "repos_url": "https://api.github.com/users/klappdev/repos",
      "events_url": "https://api.github.com/users/klappdev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/klappdev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-08-24T13:13:26Z",
    "updated_at": "2024-02-23T15:44:10Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В С++23 были добавленны вещественные типы фиксированого размера.\r\n\r\n```C++\r\n#include <stdfloat>\r\n\r\nbfloat16_t bf16 = 10.0bf16;\r\nfloat16_t f16 = 20.0f16;\r\nfloat32_t f32 = 30.0f32;\r\nfloat64_t f64 = 40.0f64;\r\nfloat128_t f128 = 50.0f128;\r\n```\r\nhttps://en.cppreference.com/w/cpp/types/floating-point\r\n\r\nВ С++11 ранее были добавлены целочисленные типы фиксированного размера.\r\n```C++\r\n#include <cstdint>\r\n\r\nstd::int64_t i64 = 10;\r\n```\r\nhttps://en.cppreference.com/w/cpp/types/integer\r\n\r\nНо типы std::int128_t, std::uint128_t не были добавлены.\r\nБольшенство компиляторов поддерживаю в виде расширения int128_t и uint128_t.\r\nТакже boost поддерживает работу с такими типами.\r\n\r\nПредлагается добавить в <cstdint> std::int128_t и std::uint128_t типы для консистенстности к вещественным типам\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/572/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/572/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/571",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/571/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/571/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/571/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/571",
    "id": 1851234866,
    "node_id": "I_kwDOFK7cns5uV5oy",
    "number": 571,
    "title": "request for comments: оператор вывода tuple в поток",
    "user": {
      "login": "fukanchik",
      "id": 967289,
      "node_id": "MDQ6VXNlcjk2NzI4OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967289?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fukanchik",
      "html_url": "https://github.com/fukanchik",
      "followers_url": "https://api.github.com/users/fukanchik/followers",
      "following_url": "https://api.github.com/users/fukanchik/following{/other_user}",
      "gists_url": "https://api.github.com/users/fukanchik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fukanchik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fukanchik/subscriptions",
      "organizations_url": "https://api.github.com/users/fukanchik/orgs",
      "repos_url": "https://api.github.com/users/fukanchik/repos",
      "events_url": "https://api.github.com/users/fukanchik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fukanchik/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-08-15T10:41:18Z",
    "updated_at": "2023-08-27T14:03:10Z",
    "closed_at": "2023-08-27T14:03:10Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Идея: хочется писать\r\n`std::cout << std::tuple(1,2,\"str\") << std::endl;`\r\nили ещё напрмер\r\n`BOOST_LOG_TRIVIAL(error) << std::tuple(1,2,\"str\");`\r\nили\r\n`serializer_stream << std::tuple(1,2,\"str\");`\r\n\r\nСложно сказать, будет ли такая штука полезна в стандартной библиотеке. В питоне, например, печатается без проблем, но формат жёсткий - `(element,...)`\r\n\r\nЯ не настоящий c++-сник, поэтому у меня получились вот такие две реализации:\r\nрекурсивная:\r\n```\r\n#include <iostream>\r\n#include <string>\r\n#include <tuple>\r\n\r\ntemplate <std::size_t N = 0, typename... T>\r\nvoid foo(std::ostream &os, const std::tuple<T...> &t) {\r\n  if (N != 0)\r\n    os << \",\";\r\n  os << std::get<N>(t);\r\n  if constexpr ((N + 1) != sizeof...(T))\r\n    foo<std::size_t(N + 1), T...>(os, t);\r\n}\r\n\r\ntemplate <typename... T>\r\nstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\r\n  foo(os, t);\r\n  return os;\r\n}\r\ntemplate <typename... T>\r\nstd::ostream &operator<<(std::ostream &os, const std::tuple<> &t) {\r\n  return os;\r\n}\r\n\r\nint main() {\r\n  std::cout << std::tuple(1, 2, \"Hello, world\") << std::endl;\r\n  std::cout << std::tuple() << std::endl;\r\n  return 0;\r\n}\r\n```\r\n\r\nвторая:\r\n```\r\n#include <iostream>\r\n#include <string>\r\n#include <tuple>\r\n\r\ntemplate <typename... T> struct X {\r\n  std::ostream &_x;\r\n  X(std::ostream &x) : _x(x) {}\r\n\r\n  template <typename N> const N &baz(const N &v, const char *sep) {\r\n    _x << sep << v;\r\n    return v;\r\n  }\r\n\r\n  template <std::size_t... Is>\r\n  void bar(const std::tuple<T...> &t, std::index_sequence<Is...>) {\r\n    std::tuple<T...> d{baz(std::get<0>(t), \"\"),\r\n                       baz(std::get<Is + 1>(t), \",\")...};\r\n  }\r\n};\r\n\r\ntemplate <typename... T>\r\nstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\r\n  X<T...>(os).bar(t, std::make_index_sequence<sizeof...(T) - 1>{});\r\n  return os;\r\n}\r\ntemplate <typename... T>\r\nstd::ostream &operator<<(std::ostream &os, const std::tuple<> &t) {\r\n  return os;\r\n}\r\n\r\nint main() {\r\n  std::cout << std::tuple(1, 2, \"Hello, world\") << std::endl;\r\n  std::cout << std::tuple() << std::endl;\r\n  return 0;\r\n}\r\n```\r\n\r\n1. насколько это разумные реализации? какие в них ошибки? можно ли проще и оптимальные?\r\n2. есть ли смысл заносить это в стандарт? в буст? есть ли в ваших проектах такое?\r\n3. может, это уже предложено, и я просто не смог его найти в https://wg21.link/index.txt?\r\n4. не понятно в какое место библиотеки это вставлять чтобы не занести зависимость `<iostream>` в `<tuple>` или `<tuple>` в `<iostream>`\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/571/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/571/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/570",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/570/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/570/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/570/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/570",
    "id": 1850398220,
    "node_id": "I_kwDOFK7cns5uStYM",
    "number": 570,
    "title": "Добавить with <variable> do  оператор  из старого доброго Паскаля )",
    "user": {
      "login": "raidenluikang",
      "id": 24319853,
      "node_id": "MDQ6VXNlcjI0MzE5ODUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/24319853?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raidenluikang",
      "html_url": "https://github.com/raidenluikang",
      "followers_url": "https://api.github.com/users/raidenluikang/followers",
      "following_url": "https://api.github.com/users/raidenluikang/following{/other_user}",
      "gists_url": "https://api.github.com/users/raidenluikang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raidenluikang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raidenluikang/subscriptions",
      "organizations_url": "https://api.github.com/users/raidenluikang/orgs",
      "repos_url": "https://api.github.com/users/raidenluikang/repos",
      "events_url": "https://api.github.com/users/raidenluikang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raidenluikang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2023-08-14T19:21:28Z",
    "updated_at": "2023-08-17T11:07:17Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Вспомнил 20 лет давности : with .. do  оператор  было адский удобно, для инициализация полей у структур (Record).\r\n\r\nСсылка  [https://freepascal.org/docs-html/ref/refsu62.html](https://freepascal.org/docs-html/ref/refsu62.html)\r\n\r\nПочему это идея не дойдет до стандарта? )\r\n\r\nМаленький пример,\r\n```\r\nstruct Message\r\n{ \r\n     int id;\r\n    std::string text;\r\n   std::chrono::steady_clock::time_point delivery;\r\n};\r\n\r\nint main(){\r\n    struct Message m;\r\n    with   m do {\r\n          id = 22;\r\n          text = \"Hello world\";\r\n          delivery = std::chrono::steady_clock::now();\r\n    }\r\n}\r\n\r\n```\r\n\r\nНе путайте with оператор у Пайтон, там другая.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/570/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/570/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/569",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/569/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/569/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/569/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/569",
    "id": 1842982552,
    "node_id": "I_kwDOFK7cns5t2a6Y",
    "number": 569,
    "title": "Автоматические BitmaskType для scoped enum",
    "user": {
      "login": "bibmaster",
      "id": 4622723,
      "node_id": "MDQ6VXNlcjQ2MjI3MjM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4622723?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bibmaster",
      "html_url": "https://github.com/bibmaster",
      "followers_url": "https://api.github.com/users/bibmaster/followers",
      "following_url": "https://api.github.com/users/bibmaster/following{/other_user}",
      "gists_url": "https://api.github.com/users/bibmaster/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bibmaster/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bibmaster/subscriptions",
      "organizations_url": "https://api.github.com/users/bibmaster/orgs",
      "repos_url": "https://api.github.com/users/bibmaster/repos",
      "events_url": "https://api.github.com/users/bibmaster/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bibmaster/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2023-08-09T10:55:39Z",
    "updated_at": "2023-08-09T22:16:08Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Добавить маркер  `bitmask` для scoped enum.\r\n\r\nВ стандарте есть различные scoped enum удовлетворяющие требованиям BitmaskType.\r\nНо реализация этих требований выливается в большое количество boilerplate кода.\r\nПримеры:\r\nhttps://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/fs_fwd.h#L165\r\nhttps://github.com/microsoft/STL/blob/ed8150e099f6124c50dd4f002cd2ab8c429a81e3/stl/inc/type_traits#L2270\r\n\r\nПредлагается переложить эту работу на компилятор, явно указав допустимость выполненения битовых операций со значениями enum.\r\nВо избежание добавления новых ключевых слов можно расширить enum-key.\r\nСейчас это _one of enum, enum class, or enum struct_, добавить enum union\r\n```cpp\r\nenum union perms\r\n```\r\nПри этом предполагается что операции вида `Enum::x <op> Enum::y` будут эквивалентны следующему коду:\r\n```cpp\r\nstatic_cast<Enum>(static_cast<undelying_type_t<Enum>>(x) <op> static_cast<underlying_type_t<Enum>>(y))\r\n```\r\nВторая проблема с использованием scoped enum в качестве bitmask это проверки на 0.\r\nПример из gcc:\r\n```cpp\r\nnamespace\r\n{\r\n  template<typename Bitmask>\r\n    inline bool\r\n    is_set(Bitmask obj, Bitmask bits)\r\n    {\r\n      return (obj & bits) != Bitmask::none;\r\n    }\r\n}\r\n```\r\n\r\nПредлагается для значений bitmask enum использовать правила explicit bool conversion аналогичные таковым для соотвествующих underlying type.\r\n```cpp\r\n// Было\r\nif(is_set(mask, options::x))\r\nif((mask & options::x) != options::none)\r\n\r\n// Стало\r\nif(mask & options::x)\r\n```\r\n\r\nДополнительно можно добавить concept Bitmask и функцию проверки\r\n```cpp\r\ntemplate<Bitmask T> constexpr bool std::is_set(T mask, T bits)\r\n\r\nbool x_enabled = std::is_set(mask, option::x);\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/569/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/569/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/568",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/568/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/568/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/568/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/568",
    "id": 1835160933,
    "node_id": "I_kwDOFK7cns5tYlVl",
    "number": 568,
    "title": "Получение файлового дескриптора из std::ofstream",
    "user": {
      "login": "gleb-kov",
      "id": 41119563,
      "node_id": "MDQ6VXNlcjQxMTE5NTYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/41119563?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gleb-kov",
      "html_url": "https://github.com/gleb-kov",
      "followers_url": "https://api.github.com/users/gleb-kov/followers",
      "following_url": "https://api.github.com/users/gleb-kov/following{/other_user}",
      "gists_url": "https://api.github.com/users/gleb-kov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gleb-kov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gleb-kov/subscriptions",
      "organizations_url": "https://api.github.com/users/gleb-kov/orgs",
      "repos_url": "https://api.github.com/users/gleb-kov/repos",
      "events_url": "https://api.github.com/users/gleb-kov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gleb-kov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-08-03T14:18:37Z",
    "updated_at": "2024-02-23T15:37:23Z",
    "closed_at": "2024-02-23T15:37:23Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nХочется добавить метод в std::ofstream который возвращает файловый дескриптор. \r\n\r\nПо аналогии с std::thread можно заиметь такой интерфейс:\r\n\r\n```\r\nnative_handle_type native_handle();\r\n```\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\n\r\nПолезно для вызова низкоуровневого апи, например fsync, fdatasync. Наверняка есть еще больше юзкейсов.\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\n\r\n-\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/568/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/567",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/567/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/567/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/567/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/567",
    "id": 1784143203,
    "node_id": "I_kwDOFK7cns5qV91j",
    "number": 567,
    "title": "Получение списка доступных последовательных портов (Boost.Asio)",
    "user": {
      "login": "ksrp1984",
      "id": 73793780,
      "node_id": "MDQ6VXNlcjczNzkzNzgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/73793780?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ksrp1984",
      "html_url": "https://github.com/ksrp1984",
      "followers_url": "https://api.github.com/users/ksrp1984/followers",
      "following_url": "https://api.github.com/users/ksrp1984/following{/other_user}",
      "gists_url": "https://api.github.com/users/ksrp1984/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ksrp1984/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ksrp1984/subscriptions",
      "organizations_url": "https://api.github.com/users/ksrp1984/orgs",
      "repos_url": "https://api.github.com/users/ksrp1984/repos",
      "events_url": "https://api.github.com/users/ksrp1984/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ksrp1984/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 10,
    "created_at": "2023-07-01T18:38:01Z",
    "updated_at": "2023-11-25T14:11:22Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nМетод получения доступных последовательных портов в системе\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nБудет полезно в любом приложение работающее с COM портами\r\n_<Код c реализацией вашей идеи, если есть>_\r\nВ качестве референса можно использовать реализацию в QT: \"QList<QSerialPortInfo> QSerialPortInfo::availablePorts()\"(qserialportinfo_unix.cpp, qserialportinfo_win.cpp)\r\n\r\nПолезные ссылки:\r\n* https://www.qt.io/download-open-source - исходники QT",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/567/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/566",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/566/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/566/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/566/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/566",
    "id": 1776389717,
    "node_id": "I_kwDOFK7cns5p4Y5V",
    "number": 566,
    "title": "Добавить в алгоритмы merge_unique",
    "user": {
      "login": "tomilov",
      "id": 896175,
      "node_id": "MDQ6VXNlcjg5NjE3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/896175?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomilov",
      "html_url": "https://github.com/tomilov",
      "followers_url": "https://api.github.com/users/tomilov/followers",
      "following_url": "https://api.github.com/users/tomilov/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomilov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomilov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomilov/subscriptions",
      "organizations_url": "https://api.github.com/users/tomilov/orgs",
      "repos_url": "https://api.github.com/users/tomilov/repos",
      "events_url": "https://api.github.com/users/tomilov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomilov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-06-27T08:38:27Z",
    "updated_at": "2023-06-27T08:54:59Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nНе хватает функции, которая за один проход сливает две неубывающих последовательности в строго возрастающую\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nБазовый алгоритм\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\n```\r\ntemplate<typename InputIterator1, typename InputIterator2, typename OutputIterator>\r\nOutputIterator merge_unique(InputIterator1 first1, InputIterator1 last1,\r\n                            InputIterator2 first2, InputIterator2 last2,\r\n                            OutputIterator result)\r\n{\r\n    while (first1 != last1 && first2 != last2)\r\n    {\r\n        if (*first1 < *first2)\r\n        {\r\n            *result = *first1;\r\n            while (++first1 != last1 && !(*std::prev(first1) < *first1));\r\n        }\r\n        else if (*first2 < *first1)\r\n        {\r\n            *result = *first2;\r\n            while (++first2 != last2 && !(*std::prev(first2) < *first2));\r\n        }\r\n        else // *first1 == *first2\r\n        {\r\n            *result = *first1;\r\n            while (++first1 != last1 && !(*std::prev(first1) < *first1));\r\n            while (++first2 != last2 && !(*std::prev(first2) < *first2));\r\n        }\r\n        ++result;\r\n    }\r\n    while (first1 != last1) {\r\n        *result++ = *first1;\r\n        while (++first1 != last1 && !(*std::prev(first1) < *first1));\r\n    }\r\n    while (first2 != last2) {\r\n        *result++ = *first2;\r\n        while (++first2 != last2 && !(*std::prev(first2) < *first2));\r\n    }\r\n    return result;\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/566/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/566/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/565",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/565/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/565/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/565/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/565",
    "id": 1764013290,
    "node_id": "I_kwDOFK7cns5pJLTq",
    "number": 565,
    "title": "Новая семантика ... , частичные CTAD, неименованные локалы и т.д.",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-06-19T18:30:33Z",
    "updated_at": "2024-03-24T16:19:36Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Увидел пропозал в С++26 на auto _ которое бы заменялось на [[maybe_unused]] auto x и сгорело немного\r\n\r\nКажется существуют способы гораздо лучше с точки зрения языка, которые решают сразу несколько проблем, моё предложение решает проблемы:\r\n* множества make* функций\r\n* неименованных локалов(которые хочется не именовать)\r\n* structured binding и рефлексия на его основе\r\n* более удобное метапрограммирование и новые возможности в нём(понятные и логичные)\r\n* решение проблемы \"как написать универсальное is_specialization_of\"\r\n* и т.д.\r\n\r\nИтак, первая часть пропозала:\r\n\r\n```c++\r\nauto [...args] = x;          // структурная привязка в вариадик\r\nauto [a, b, ...args] = x;  // два первых аргумента обычные, остальные вариадик\r\nauto [a, ...] = x;            // первый аргумент обычный, остальные НЕИМЕНОВАННЫЙ вариадик\r\nauto [..., a] = x;            // выделение последнего и неименованный вариадик в начале\r\nauto [a, ..., b] = x;        // и даже так, если tuple_size_v < 2, то программа ill formed\r\n// это можно также использовать для создания неименованных переменных\r\n// std::get для lock_guard возвращает *this чтобы это было возможно\r\nauto [...] = std::lock_guard(mtx);\r\n// std::scoped_lock это буквально логический тупл локов\r\nauto [...] = std::scoped_lock(mtxs...);\r\n```\r\n\r\nВторая часть пропозала:\r\n\r\nВ контексте декларации шаблонных аргументов ... X будет означать пак любых аргуменов, например здесь Args это пак ЛЮБЫХ аргументов, не только типов\r\n```C++\r\ntemplate<... Args>\r\n```\r\n\r\nЭто позволяет сделать следующее\r\n\r\n```C++\r\ntemplate<typename>\r\nstruct is_specialization : std::false_type {};\r\n\r\ntemplate<...Args, template<...> typename Template>\r\nstruct is_specialization<Template<Args...>> : std::true_type {};\r\n```\r\nКонтекст декларации аргументов функции\r\n\r\n```C++\r\n// это шаблон функции с неименованным паком аргументов аналогично тому как работает void foo(auto);\r\nvoid foo(vector<int, ...>); \r\n// эквивалентно этому переписанному коду(если бы были аргументы не типы у шаблона, то добавило бы их тоже)\r\ntemplate<typename... Args>\r\nvoid foo(vector<int, Args...>)\r\n\r\n// Аналогично для\r\nvoid foo(vector<...>);         // неименованный пак\r\nvoid foo(vector<... Args>); // именованный пак\r\ntemplate<typename Alloc>\r\nvoid foo(vector<int, Alloc, ...>); // тоже работает, сейчас на гцц такое поведение поддержано\r\n\r\nvoid foo(vector<..., int, ...>); // ошибка компиляции\r\nvoid foo(vector<...> v, unique_ptr<...>); // работает\r\n```\r\n\r\nКонтекст передачи шаблонных шаблонных аргументов\r\nTemplate<Type, ...> - алиас на Template с requires что первый тип same_as<Type>\r\nПример:\r\n\r\n```C++\r\nview | to<vector<int, ...>> // переписывается в то что ниже\r\n\r\ntemplate<same_as<int> T, ... Args> // all args, not just types\r\nusing __alias_vector = vector<T, Args...>;\r\nview | to<vector<int, ...>>\r\n\r\n```\r\n\r\nКонтекст вывода типов переменных (CTAD)\r\n\r\n```C++\r\n// применяет частичный CTAD с переданным пользователем типом int\r\nvector<int, ...> x = vector<float, myaloc>();\r\n// выполняет полный CTAD\r\nvector<...> x = vector<int>();\r\n```\r\n\r\nМеханизм работы частичного CTAD:\r\nУ компилятора имеются дедакт гайды, в некоторых из них типы СПРАВА undeductible, в этом случае это называется частичный дедакт гайд(сейчас это запрещено)\r\nПри передаче пользователем части аргументов компилятор подставляет их и некоторые из частичных дедакт гайдов становятся полными, после этого компилятор делает обычный CTAD как сейчас(это похоже на C++20 фичу с дедакт гайдом из алиасов, просто фактически как и выше Template<Args, ...> создаёт алиас по которому компилятор выводит полный тип)\r\n\r\nПример:\r\n```C++\r\n// это частичный дедакт гайд\r\n// компилятор видит что тип U в типе справа невыводим, но когда пользователь сам передаёт тип U\r\n// компилятор имеет всю информацию чтобы вывести тип\r\ntemplate<typename T, typename U, typename Alloc>\r\nvector(vector<T, Alloc>) -> vector<U, Alloc>;\r\n\r\n// использование. Компилятор видит слева int, подставляет в дедакт гайд,\r\n// остаётся вывести аллокатор, дедакт гайд подсказывает, что он my_alloc\r\nvector<int, ...> v = vector<float, my_alloc>{};\r\n\r\n```\r\nЭтот частичный дедакт гайд также можно переписать с помощью пропозала короче\r\n\r\n```C++\r\ntemplate<typename Alloc>\r\nvector(vector<..., Alloc>) -> vector<..., Alloc>;  // использованы два неименованных пака, разных\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/565/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/565/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/564",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/564/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/564/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/564/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/564",
    "id": 1763621543,
    "node_id": "I_kwDOFK7cns5pHrqn",
    "number": 564,
    "title": "Решение проблемы релоцирования объектов",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-06-19T14:04:50Z",
    "updated_at": "2023-06-20T09:35:34Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "\r\nВся суть проблемы с релоцированием объектов заключается в том, что компилятору неизвестно каким образом происходит мув и из кода невозможно узнать (помимо trivial мува) каково поведение типа.\r\n\r\nНо если посмотреть на проблему шире, оказывается, что валидных стратегий реализации мув конструктора всего 4:\r\n1. memcpy (trivial move)\r\n2. exchange с дефолтным состоянием\r\n3. self reference сценарий\r\n4. у объекта вовсе нет мува, а есть только копирование(С++03 объект)\r\nну или тип вообще не movable, но очевидно его и релоцировать нельзя\r\nТак вот, сейчас в С++ представлен только первый тип как = default и трейт is_trivially_move_constructible, \r\n\r\nЯ предлагаю\r\n\r\nдобавить сценарий 2 как стратегию поведения на муве и трейты для этого, например\r\n\r\nType(Type&&) = default; // то что сейчас, мув конструктор у всех филдов/базовых классов\r\n\r\nType(Type&&) = swap; // дефолтное конструирование + вызов swap через adl для всех филдов и базовых классов\r\n\r\nТо же самое можно сделать с оператором\r\nType& operator=(Type&&) = swap; // типичная реализация мув оператора\r\n\r\nи добавить трейт is_not_self_reference<Type> который будет давать true если у типа и рекурсивно у всех типов за ним нет нетривиальных мувов.\r\nТ.к. фактически нет никакого смысла делать нетривиальный мув при таких условиях\r\n\r\nЭто \r\n* уберёт бойлерплейт\r\n* позволит компилятору и контейнерам узнавать практически во всех случаях, что тип не селф референс\r\n\r\nБолее того, практически все дефолтные конструкторы и деструкторы можно сделать constexpr, даже  у std::any такой конструктор.\r\nкомпилятор может \"выдумать\" объект и дефолтно его сконструировать, а потом разрушить и на компиляции узнать, что деструктор был noop.\r\n\r\nДля этого я предлагаю ещё один трейт is_trivially_destructible_after_move\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/564/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/564/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/563",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/563/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/563/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/563/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/563",
    "id": 1754047478,
    "node_id": "I_kwDOFK7cns5ojKP2",
    "number": 563,
    "title": "static_assert в constexpr функции",
    "user": {
      "login": "blacktea",
      "id": 42189825,
      "node_id": "MDQ6VXNlcjQyMTg5ODI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/42189825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktea",
      "html_url": "https://github.com/blacktea",
      "followers_url": "https://api.github.com/users/blacktea/followers",
      "following_url": "https://api.github.com/users/blacktea/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktea/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktea/orgs",
      "repos_url": "https://api.github.com/users/blacktea/repos",
      "events_url": "https://api.github.com/users/blacktea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktea/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-06-13T05:06:55Z",
    "updated_at": "2023-06-17T05:29:09Z",
    "closed_at": "2023-06-17T05:28:50Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "**Мотивация**\r\n\r\nВ `constexpr` функциях можно использовать `static_assert` в if..else конструкциях. \r\n\r\nНапример,\r\n```\r\ntemplate<typename T>\r\nconstexpr int mypow(T&& b)\r\n{\r\n    if constexpr(std::is_same_v<T, int>) {\r\n        return b*2;\r\n    }\r\n    else {\r\n        static_assert(false, \"type is not supported\");\r\n    }\r\n}\r\n```\r\nКомпиляция закончится ошибкой только если функция будет инстанциированна отличным от `int` типом.\r\nТак же можно использовать исключения в `constexpr` функциях.\r\n\r\n```\r\ntemplate<typename T>\r\nconstexpr int mypow(T&& b)\r\n{\r\n    if constexpr(std::is_same_v<T, int>) {\r\n        return b*2;\r\n    }\r\n    throw std::runtime_error{\"type is not supported\"};\r\n}\r\n```\r\nКомпилятор может отслеживать поток выполнения приложения. Таким образом, функция является `constexpr`, если выполняется условие.\r\n\r\nОднако, та же логика не работает для `static_assert` и if..else конструкции. Следующий код не скопилируется, даже если вызвать с `int` типом. Компилятор в любов случае фэйлится на `static_assert`.\r\n\r\n```\r\ntemplate<typename T>\r\nconstexpr int mypow(T&& b)\r\n{\r\n    if constexpr(std::is_same_v<T, int>) {\r\n        return b*2;\r\n    }\r\n    static_assert(false, \"type is not supported\");\r\n}\r\n```\r\n\r\nМое предложение - не проверять `static_assert` в терминальном случае. \r\n**Достоинства:**\r\n* Код выглядит немного чище, чем с `else` веткой.\r\n* Сохранится последовательность когда используется `throw`.\r\n\r\nПолезные ссылки:\r\n* https://godbolt.org/z/dz4o4qn79 - ссылка на последний пример.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/563/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/563/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/562",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/562/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/562/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/562/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/562",
    "id": 1728720765,
    "node_id": "I_kwDOFK7cns5nCi99",
    "number": 562,
    "title": "Добавить функцию деманглирования имени type_info из boost::core::demangle.",
    "user": {
      "login": "shiz01",
      "id": 45585072,
      "node_id": "MDQ6VXNlcjQ1NTg1MDcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/45585072?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shiz01",
      "html_url": "https://github.com/shiz01",
      "followers_url": "https://api.github.com/users/shiz01/followers",
      "following_url": "https://api.github.com/users/shiz01/following{/other_user}",
      "gists_url": "https://api.github.com/users/shiz01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shiz01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shiz01/subscriptions",
      "organizations_url": "https://api.github.com/users/shiz01/orgs",
      "repos_url": "https://api.github.com/users/shiz01/repos",
      "events_url": "https://api.github.com/users/shiz01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shiz01/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-05-27T13:14:29Z",
    "updated_at": "2023-05-28T08:50:36Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Вмержить в стандарт `boost::core::demangle`, т.к. на данный момент нет какого-либо стандартного способа получить человекочитаемое имя из `typeid(T).name()`.\r\n\r\nДостаточно удобно при отладке шаблонов использовать в логах `type_info`, но без библиотеки boost требуется дополнительное деманглирование.\r\n\r\nНа данный момент `typeid(std::expected<std::vector<std::string>, my_error_t>).name()` выведет манглированное имя, которое в логах придётся дополнительно деманглировать при отладке, т.к. трудно однозначно интерпретировать тип.\r\n`St8expectedISt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS6_EE10my_error_tE`\r\n\r\nПри использовании `boost::core::demangle`, нам не нужна постобработка логов, мы можем сразу получить читаемое имя типа.\r\n`std::expected<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, my_error_t>`\r\n\r\n\r\nПолезные ссылки:\r\n* https://www.boost.org/doc/libs/1_82_0/libs/core/doc/html/core/demangle.html - ссылка на документацию о реализации деманглирования имён из type_info в boost.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/562/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/562/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/561",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/561/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/561/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/561/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/561",
    "id": 1696079530,
    "node_id": "I_kwDOFK7cns5lGB6q",
    "number": 561,
    "title": "Добавить вариант std::any_of, all_of, none_of  со значением",
    "user": {
      "login": "blacktea",
      "id": 42189825,
      "node_id": "MDQ6VXNlcjQyMTg5ODI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/42189825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktea",
      "html_url": "https://github.com/blacktea",
      "followers_url": "https://api.github.com/users/blacktea/followers",
      "following_url": "https://api.github.com/users/blacktea/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktea/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktea/orgs",
      "repos_url": "https://api.github.com/users/blacktea/repos",
      "events_url": "https://api.github.com/users/blacktea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktea/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-05-04T13:58:09Z",
    "updated_at": "2023-06-19T13:42:51Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Добавить перегрузки к методам std::any_of, all_of, none_of, которые примают значение в качестве референса.\r\nМетод std::find имеет такую перегрузку \r\n```\r\ntemplate< class InputIt, class T >\r\nconstexpr InputIt find( InputIt first, InputIt last, const T& value );\r\n```\r\n[cppreference](https://en.cppreference.com/w/cpp/algorithm/find)\r\n\r\nОжидаемое сигнатура:\r\n\r\n```\r\ntemplate< class InputIt, class T >\r\nconstexpr bool any_of( InputIt first, InputIt last, const T& value );\r\n```\r\n\r\n**Мотивация**\r\nРассмотрим простой пример с использованием std::any_of.\r\nПредположим имеем массив чисел, и хотим узнать содержит ли массив какое-то конкретное число.\r\n\r\nС std::find мы напишем\r\n```\r\nvector<int> v{1,2,3};\r\nint target = 1;\r\nconst bool contains = std::find(v.begin(), v.end(), target) != v.end;\r\n```\r\nC std::any_of:\r\n```\r\nvector<int> v{1,2,3};\r\nint target = 1;\r\nconst bool contains = std::any_of(v.begin(), v.end(), [target](int value){ return target == value; });\r\n```\r\n\r\nМое предложение призвано упростить код. Будет выглядить след. образом.\r\n```\r\nvector<int> v{1,2,3};\r\nint target = 1;\r\nconst bool contains = std::any_of(v.begin(), v.end(), value);\r\n```\r\n\r\n\r\nПолезные ссылки:\r\n* https://en.cppreference.com/w/cpp/algorithm/all_any_none_of\r\n* https://en.cppreference.com/w/cpp/algorithm/find\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/561/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/561/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/560",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/560/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/560/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/560/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/560",
    "id": 1693247118,
    "node_id": "I_kwDOFK7cns5k7OaO",
    "number": 560,
    "title": "Стандарт для описания отображения пользовательских и не только типов при отладке",
    "user": {
      "login": "DaMilyutin",
      "id": 44639272,
      "node_id": "MDQ6VXNlcjQ0NjM5Mjcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/44639272?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DaMilyutin",
      "html_url": "https://github.com/DaMilyutin",
      "followers_url": "https://api.github.com/users/DaMilyutin/followers",
      "following_url": "https://api.github.com/users/DaMilyutin/following{/other_user}",
      "gists_url": "https://api.github.com/users/DaMilyutin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DaMilyutin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DaMilyutin/subscriptions",
      "organizations_url": "https://api.github.com/users/DaMilyutin/orgs",
      "repos_url": "https://api.github.com/users/DaMilyutin/repos",
      "events_url": "https://api.github.com/users/DaMilyutin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DaMilyutin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-05-03T00:21:30Z",
    "updated_at": "2023-05-03T00:21:30Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Как известно, у MSVS есть такой визуализатор пользовательских типов [natvis](https://learn.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?source=recommendations&view=vs-2022)\r\nОн отчасти хорош, но не всегда и не всё позволяет (по моему опыту). Например, он не позволяет вызывать функции из кода.\r\nТакже он проприетарный для MSVS. И многоловный.\r\n\r\nХотелось бы более удобный язык описания, например похожий на С++ форматеры и стандартизированный.\r\nНапример, как в Rust есть [trait.Debug](https://doc.rust-lang.org/std/fmt/trait.Debug.html). Или в python есть [repr](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-repr/).\r\n\r\nТакое полезно будет для отображения пользовательских типов в отладке.\r\n\r\nКод предложить не могу, кроме как по приведённым ссылкам.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/560/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/560/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/559",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/559/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/559/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/559/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/559",
    "id": 1688013765,
    "node_id": "I_kwDOFK7cns5knQvF",
    "number": 559,
    "title": "Добавить новое понятие character types: char, char8_t, wchar_t, char16_t, char32_t, ограничить взаимодействие их с другими арифметическими типами",
    "user": {
      "login": "raidenluikang",
      "id": 24319853,
      "node_id": "MDQ6VXNlcjI0MzE5ODUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/24319853?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raidenluikang",
      "html_url": "https://github.com/raidenluikang",
      "followers_url": "https://api.github.com/users/raidenluikang/followers",
      "following_url": "https://api.github.com/users/raidenluikang/following{/other_user}",
      "gists_url": "https://api.github.com/users/raidenluikang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raidenluikang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raidenluikang/subscriptions",
      "organizations_url": "https://api.github.com/users/raidenluikang/orgs",
      "repos_url": "https://api.github.com/users/raidenluikang/repos",
      "events_url": "https://api.github.com/users/raidenluikang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raidenluikang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-04-28T07:00:58Z",
    "updated_at": "2024-02-28T12:03:50Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Предлагаю новое понятие character types и там добавить типы char, wchar_t, char8_t, char16_t, char32_t. Их надо отделять от integral types. И сильно надо ограничить их взаимодействие с другими арифметическими типами. Возможно запредекатит имплисит конвертация другими типы к character types.\r\n\r\n```\r\nchar c = 'A'; // OK\r\nstd::string s ;\r\n  s = c; // OK\r\n  \r\n  int i = 'B'; // deprecated, use char, or use static_cast<int>('B');\r\n  \r\n  s = i; // deprecated, use char or use static_cast<char>(i);\r\n  \r\n  \r\n```\r\n\r\nУже очень надоело такие ошибки.\r\n```\r\nstruct some_param{\r\n      std::string progress;\r\n};\r\n....\r\n\r\nvoid foo(some_param& param){\r\n         param.progress = 100; // Молча компилируется gcc, clang даже с -Wall ,   только в -Wconversion показывает варнинг но это уже слишком много ошибок показывает везде даже в библиотечные коды, что теряется там полезные варнингы.\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/559/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/559/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/558",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/558/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/558/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/558/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/558",
    "id": 1642779803,
    "node_id": "I_kwDOFK7cns5h6tSb",
    "number": 558,
    "title": "std::system V2",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-03-27T20:39:45Z",
    "updated_at": "2023-03-27T20:39:45Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_Запуск программы с контролем выполнения_\r\n\r\n_Часто возникают задачи для запуска внешних программ, где std::system уже недостаточно_\r\n\r\n- Нужно контроллировать поток ввода-вывода\r\n- Контроллировать код возврата\r\n- Переменные среды и аргументы программы\r\n- Ожидание завершения\r\n\r\nПочти во всех языках программирования подобный функционал присутствует из коробки, а тянуть boost.process в проект на C++ ради этого часто не хочется.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/558/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/558/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/557",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/557/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/557/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/557/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/557",
    "id": 1641638120,
    "node_id": "I_kwDOFK7cns5h2Wjo",
    "number": 557,
    "title": "Добавить operator[] для tuple.",
    "user": {
      "login": "blacktea",
      "id": 42189825,
      "node_id": "MDQ6VXNlcjQyMTg5ODI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/42189825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktea",
      "html_url": "https://github.com/blacktea",
      "followers_url": "https://api.github.com/users/blacktea/followers",
      "following_url": "https://api.github.com/users/blacktea/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktea/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktea/orgs",
      "repos_url": "https://api.github.com/users/blacktea/repos",
      "events_url": "https://api.github.com/users/blacktea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktea/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2023-03-27T08:27:24Z",
    "updated_at": "2024-03-24T15:51:55Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "**Идея**\r\nПредлагаю добавить функцию `operator[](size_t)` в класс std::tuple. Функция, в отличии от std::get, принимает аргумент - индекс значения.\r\nЭто очень упростит пользовательский код т.к. постоянно набирать std::get<>(tuple) - жутко не удобно.\r\n \r\n\r\n\r\n**Пример:**\r\n\r\n\r\n```\r\nstd::tuple<int, double> tp(1, 3.14);\r\n\r\nfor(size_t i = 0; i < tp.size();++i) {\r\n\r\nstd::cerr << tp[0] << '\\n';\r\n\r\n}\r\n```\r\n\r\nТоже самое, сейчас:\r\n\r\n```\r\nstd::apply([](auto&&... xs) {\r\n               ((std::cout << std::forward<decltype(xs)>(xs) << '\\n'), ...); },\r\n             tp);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/557/reactions",
      "total_count": 5,
      "+1": 4,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/557/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/556",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/556/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/556/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/556/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/556",
    "id": 1631698877,
    "node_id": "I_kwDOFK7cns5hQb-9",
    "number": 556,
    "title": "Добавить runtime функцию для создания std::variant с типом внутри определяемым по индексу",
    "user": {
      "login": "ExpertSDR3",
      "id": 93903520,
      "node_id": "U_kgDOBZjaoA",
      "avatar_url": "https://avatars.githubusercontent.com/u/93903520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ExpertSDR3",
      "html_url": "https://github.com/ExpertSDR3",
      "followers_url": "https://api.github.com/users/ExpertSDR3/followers",
      "following_url": "https://api.github.com/users/ExpertSDR3/following{/other_user}",
      "gists_url": "https://api.github.com/users/ExpertSDR3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ExpertSDR3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ExpertSDR3/subscriptions",
      "organizations_url": "https://api.github.com/users/ExpertSDR3/orgs",
      "repos_url": "https://api.github.com/users/ExpertSDR3/repos",
      "events_url": "https://api.github.com/users/ExpertSDR3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ExpertSDR3/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-03-20T09:17:37Z",
    "updated_at": "2023-03-20T09:17:37Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Мне нужно было реализовать FSM на шаблонах, описывается таблица переходом, из неё извлекаются все типы состояний и для хранения текущего состояния я взял std::veriant, он идеально подходит для этого. Во время выполнения состояния могут переключаться по разному и нужно было реализовать функцию, которая создаёт std::variant с конкретным типом внутри и этот тип определяется индексом. \r\nВ STL есть compiletime решение:  `std::variant(std::in_place_index<I>)` , но мне нужен был аналог для runtime.\r\n\r\nБлагодаря сообществу нашлось решение:\r\n\r\n``` C++\r\ntemplate <class... T, std::size_t... I>\r\nconstexpr static std::variant<T...> make_one_impl(std::index_sequence<I...>, std::size_t i) {\r\n    return std::array { +[] { return std::variant<T...>(std::in_place_index<I>); }... }[i]();\r\n}\r\n\r\ntemplate <class... T>\r\nconstexpr static std::variant<T...> make_one(std::size_t index) {\r\n    return make_one_impl(std::index_sequence_for<T...>(), index);\r\n}\r\n```\r\nНаписать такое под силу не многим, хотелось бы иметь готовые решения в STL.\r\n\r\n\r\nМоя библиотека FSM:\r\n* https://github.com/ValeraMikhaylovsky/fsm\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/556/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/556/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/555",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/555/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/555/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/555/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/555",
    "id": 1631661725,
    "node_id": "I_kwDOFK7cns5hQS6d",
    "number": 555,
    "title": "Добавить runtime функцию для доступа к элементу std::tuple по индексу",
    "user": {
      "login": "ExpertSDR3",
      "id": 93903520,
      "node_id": "U_kgDOBZjaoA",
      "avatar_url": "https://avatars.githubusercontent.com/u/93903520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ExpertSDR3",
      "html_url": "https://github.com/ExpertSDR3",
      "followers_url": "https://api.github.com/users/ExpertSDR3/followers",
      "following_url": "https://api.github.com/users/ExpertSDR3/following{/other_user}",
      "gists_url": "https://api.github.com/users/ExpertSDR3/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ExpertSDR3/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ExpertSDR3/subscriptions",
      "organizations_url": "https://api.github.com/users/ExpertSDR3/orgs",
      "repos_url": "https://api.github.com/users/ExpertSDR3/repos",
      "events_url": "https://api.github.com/users/ExpertSDR3/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ExpertSDR3/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2023-03-20T08:57:05Z",
    "updated_at": "2023-06-21T08:24:09Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "При написании библиотек периодически сталкиваюсь с задачей обращения к экземпляру типа внутри std::tuple по индексу в runtime. Готового решения нет, есть std::apply, который передаёт сразу все экземпляры в функтор в виде аргументов, но мне нужен только один.\r\n\r\nПредположим, есть бинарный протокол управления устройством, имеется набор команд, каждая команда это класс, реализуется некоторый шаблонный класс протокола, которому шаблонными параметрами передаются все команды и они хранятся в std::tuple.\r\n\r\n``` C++\r\ntemplate <class Cmds...>\r\nstruct protocol_t {\r\n\r\n    void process(std::size_t index, std::span<std::byte> bytes) {\r\n        std::apply_one([&](auto &&cmd){ \r\n            cmd.process(bytes);\r\n        }, index, m_commands);\r\n    }\r\n\r\nprivate:\r\n    std::tuple<Cmds...> m_commands;\r\n};\r\n```\r\nПример реализации:\r\n * https://godbolt.org/z/fePaMqTf7\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/555/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/555/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/554",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/554/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/554/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/554/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/554",
    "id": 1620703339,
    "node_id": "I_kwDOFK7cns5gmfhr",
    "number": 554,
    "title": "Добавить атрибут для default метки, который будет выдавать warning если не все значения enum обработаны в switch",
    "user": {
      "login": "adromanov",
      "id": 13982171,
      "node_id": "MDQ6VXNlcjEzOTgyMTcx",
      "avatar_url": "https://avatars.githubusercontent.com/u/13982171?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adromanov",
      "html_url": "https://github.com/adromanov",
      "followers_url": "https://api.github.com/users/adromanov/followers",
      "following_url": "https://api.github.com/users/adromanov/following{/other_user}",
      "gists_url": "https://api.github.com/users/adromanov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adromanov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adromanov/subscriptions",
      "organizations_url": "https://api.github.com/users/adromanov/orgs",
      "repos_url": "https://api.github.com/users/adromanov/repos",
      "events_url": "https://api.github.com/users/adromanov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adromanov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-03-13T03:53:32Z",
    "updated_at": "2023-03-13T04:20:36Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Предложение добавить атрибут для `default` метки, который будет выдавать warning если не все значения `enum` обработаны в `switch`.\r\nКонкретное имя для аттрибута - to be discussed, для примера назовём его `[[enum-switch]]` по аналогии с флагом `gcc` \\ `clang` `-Wenum-switch`\r\n```\r\nenum class Enum { A, B, C };\r\nconst Enum value = get_value();\r\nswitch (value)\r\n{\r\ncase Enum::A: return \"A\";\r\ncase Enum::B: return \"B\";\r\ncase Enum::C: return \"C\";\r\n[[enum-switch]] default: return \"Unknown\";\r\n};\r\n```\r\n\r\nИспользования метки `default` в `switch` по значению `enum` в данный момент можно разделить на 2 категории:\r\n1) Мы явно указываем несколько, но не все значения `enum`, которые хотим обработать, а также хотим иметь логику по умолчанию для всех остальных значений.\r\n2) Мы имеем метки для всех возможных значений `enum`, но имеем метку `default` на случай, _если что-то пошло не так_. Например, мы обрабатываем сообщение от третьей стороны и делаем `switch` по типу сообщения. В большинстве случаев нам будут приходить только те сообщения, которые описаны в протоколе, но в общем случае мы не можем на 100% доверять данным, приходящим извне - невалидные данные могут быть присланы со злым умыслом или повреждены во время передачи.\r\n\r\nДля второй категории новый атрибут будет полезен - при добавлении нового значения в `enum` компилятор предупредит нас о том, что новое значение не обработано в `switch` **даже если есть `default` метка** - так же, как сейчас компиляторы с флагом `-Wenum-switch` предупреждают, если нет метки `default` и не все значения `enum` имеют метки.\r\n\r\nЭтого нельзя добиться дополнительным флагом для компилятора потому что есть случаи, когда мы сознательно не перечисляем остальные значения `enum` (категория 1).\r\n\r\nЖелаемого поведения можно добиться, вынеся код из `default` за пределы `switch`, но в некоторых случаях это усложнит код - например, мы хотим сделать ранний возврат из `default` метки. Поэтому я считаю, что с новым аттрибутом код будет проще и менее подвержен ошибкам.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/554/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/554/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/553",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/553/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/553/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/553/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/553",
    "id": 1608377204,
    "node_id": "I_kwDOFK7cns5f3eN0",
    "number": 553,
    "title": "Добавление warning при вызове функции, кидающей исключение, из noexcept функции",
    "user": {
      "login": "cezarnik",
      "id": 20155967,
      "node_id": "MDQ6VXNlcjIwMTU1OTY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/20155967?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cezarnik",
      "html_url": "https://github.com/cezarnik",
      "followers_url": "https://api.github.com/users/cezarnik/followers",
      "following_url": "https://api.github.com/users/cezarnik/following{/other_user}",
      "gists_url": "https://api.github.com/users/cezarnik/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cezarnik/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cezarnik/subscriptions",
      "organizations_url": "https://api.github.com/users/cezarnik/orgs",
      "repos_url": "https://api.github.com/users/cezarnik/repos",
      "events_url": "https://api.github.com/users/cezarnik/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cezarnik/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 10,
    "created_at": "2023-03-03T10:28:53Z",
    "updated_at": "2023-03-13T12:46:30Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Предложение - чтобы при указании какого-то флага компилятор (```-Wnoexcept-safe```, помощь в названии флага приветствуется) мог указывать, что в такой-то ```noexcept``` функции может быть вызвана функция, кидающая исключение.\r\n\r\nЧасто, когда пишешь код без исключений (например, когда их выкидывание очень сильно влияет на производительность), хочется передавать ошибку как возвращаемый результат (например, через ```std::expected```), а саму функцию помечать как ```noexcept```.\r\nСейчас выкидывание исключения из ```noexcept``` функции приводит к вызову ```std::terminate```. Это делает спецификатор ```noexcept``` очень непрактичным для каких-то нетривиальных функций:\r\nСделав функцию ```A``` ```noexcept```, автор должен быть уверен, что никакие функции, которые он позовёт из ```A```, не должны бросать исключение. Что ещё более страшно, что функции, которые вызываются из ```A```, могут менять свою спецификацию или начать кидать исключения, что ставит ```A``` под угрозу вызова ```std::terminate```\r\nБолее того, все деструкторы обычно noexcept, и изменение любой функции, вызываемой в деструкторе, может вызвать поломку этого кода, поэтому сейчас используются конструкции такого вида\r\n```\r\n~MyClass(){\r\n  try {\r\n    CallSomeFunctions();\r\n  } catch(...) {\r\n   // Do nothing.\r\n  }\r\n}\r\n```\r\n\r\nМожно оставить реализацию с ```std::terminate``` при таком вызове для обратной совместимости, но для всех желающих компиляция с новым флагом ```-Werror``` позволит избежать таких проблем.\r\n\r\nВ реализации могут быть трудности с определением, кинется ли исключение в случае, если у нас есть try/catch блок в нашей ```noexcept``` функции, который ловит что-то кроме ```...``` - может быть такой случай:\r\n```\r\nclass  MyException : public std::exception{};\r\nclass  AnotherException : public std::exception{};\r\n\r\nCallSomeFunctions() {\r\n   throw AnotherException();\r\n}\r\n\r\n~MyClass(){\r\n  try {\r\n    CallSomeFunctions();\r\n  } catch(const MyException& myEx) {\r\n   // Do nothing.\r\n  }\r\n}\r\n``` \r\n\r\nВ данном случае вылетит исключение. Чтобы такое понимать, надо для простоты либо считать, что exception может вылететь всегда, если не ловится ```...```, либо поддерживать все виды выбрасывемых типов, и проверять, что они являются наследниками типа, который написан в catch. Второй вариант, мне кажется, не сойдётся, так как может быть всякая экзотика с вызовом std::function, которая, если не пометить её как noexcept (так можно?), может кидать произвольные исключения\r\n\r\nВ случае, если в noexcept функции нет try/catch блоков, то проверка корректности заключается в проверке спецификатора noexcept у всех вызываемых функций. Пример ниже должен кинуть warning (даже если в B ничего не бросается)\r\n\r\n```\r\nA() noexcept {\r\n B();\r\n}\r\n\r\nB() {\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/553/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/553/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/552",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/552/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/552/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/552/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/552",
    "id": 1608264494,
    "node_id": "I_kwDOFK7cns5f3Csu",
    "number": 552,
    "title": "Поправить правила преобразования типов",
    "user": {
      "login": "ssoft-hub",
      "id": 21082620,
      "node_id": "MDQ6VXNlcjIxMDgyNjIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/21082620?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssoft-hub",
      "html_url": "https://github.com/ssoft-hub",
      "followers_url": "https://api.github.com/users/ssoft-hub/followers",
      "following_url": "https://api.github.com/users/ssoft-hub/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssoft-hub/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssoft-hub/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssoft-hub/subscriptions",
      "organizations_url": "https://api.github.com/users/ssoft-hub/orgs",
      "repos_url": "https://api.github.com/users/ssoft-hub/repos",
      "events_url": "https://api.github.com/users/ssoft-hub/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssoft-hub/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-03-03T09:30:13Z",
    "updated_at": "2023-03-20T19:31:39Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В языке существует особенность, которая проявляется при реализации паттерна Adapter (Proxy, Wrapper).\r\n\r\nПростейшая реализация Proxy, который агрегирует значение и при преобразовании к типу вложенного значения сохраняет свойства rvalue/lvalue и контантность, выглядит следующим образом:\r\n\r\n```cpp\r\ntemplate < typename T >\r\nclass Proxy\r\n{\r\nprivate:\r\n    T m_v;\r\n\r\npublic:\r\n    T && get () && { return static_cast< T && >(m_v); }\r\n    T const && get () const && { return static_cast< T const && >(m_v); }\r\n    T & get () & { return m_v; }\r\n    T const & get () const & { return m_v; }\r\n};\r\n```\r\n\r\nСлучай для спецификатора volitile добавляет еще 4 варианта методов, но для упрощения здесь не рассматриваются.\r\n\r\nЯвное преобразование типа Proxy к типу вложенного значения с помощью метода get() позволяет бесшовно использовать экземпляры Proxy. Следующий код позволяет в этом убедиться:\r\n\r\n```cpp\r\nclass Data {};\r\nusing ProxyData = Proxy< Data >;\r\n\r\nProxyData foo () { return {}; }\r\nProxyData const cfoo () { return {}; }\r\n\r\nvoid bar ( MyData && other ) {}\r\nvoid bar ( MyData const && other ) {}\r\nvoid bar ( MyData & other ) {}\r\nvoid bar ( MyData const & other ) {}\r\n\r\nint main ()\r\n{\r\n    // rvalue / mutable\r\n    {\r\n        Data data = foo().get();\r\n        data = foo().get();\r\n        bar( foo().get() );\r\n    }\r\n\r\n    // rvalue / const\r\n    {\r\n        Data data = cfoo().get();\r\n        data = cfoo().get();\r\n        bar( cfoo().get() );\r\n    }\r\n\r\n    // lvalue / mutable\r\n    {\r\n        ProxyData proxy;\r\n        Data data = proxy.get();\r\n        data = proxy.get();\r\n        bar( proxy.get() );\r\n    }\r\n\r\n    // lvalue / const\r\n    {\r\n        ProxyData const proxy;\r\n        Data data = proxy.get();\r\n        data = proxy.get();\r\n        bar( proxy.get() );\r\n    }\r\n}\r\n```\r\n\r\nНе всегда удобно использовать метод get(), особенно при множественном вложении значения в разные Proxy. Хотелось бы использовать экземпляр Proxy в выражениях наравне с экземплярами вложенного типа \"прозрачно\", без явного приведения с помощью метода get().\r\n\r\nЕсли попытаться заменить явный метод get() на пользовательский оператор преобразования типа, то это приведет к ошибкам компиляции для временного экземпляра Proxy (компилятор gcc7 данный код компилирует без ошибок).\r\n\r\n```cpp\r\ntemplate < typename T >\r\nclass Proxy\r\n{\r\nprivate:\r\n    T m_v;\r\n\r\npublic:\r\n    operator T && () && { return static_cast< T && >(m_v); }\r\n    operator T const && () const && { return static_cast< T const && >(m_v); }\r\n    operator T & () & { return m_v; }\r\n    operator T const & () const & { return m_v; }\r\n};\r\n\r\nclass Data {};\r\nusing ProxyData = Proxy< Data >;\r\n\r\nProxyData foo () { return {}; }\r\nProxyData const cfoo () { return {}; }\r\n\r\nvoid bar ( MyData && other ) {}\r\nvoid bar ( MyData const && other ) {}\r\nvoid bar ( MyData & other ) {}\r\nvoid bar ( MyData const & other ) {}\r\n\r\nint main ()\r\n{\r\n    // rvalue / mutable\r\n    {\r\n        Data data = foo();\r\n        data = foo();       // error: ambiguous overload for 'operator='\r\n        bar( foo() );       // error: call of overloaded 'bar(ProxyData)' is ambiguous\r\n    }\r\n\r\n    // rvalue / const\r\n    {\r\n        Data data = cfoo();\r\n        data = cfoo();      // error: ambiguous overload for 'operator='\r\n        bar( cfoo() );      // error: call of overloaded 'bar(ProxyData)' is ambiguous\r\n    }\r\n\r\n    // lvalue / mutable\r\n    {\r\n        ProxyData proxy;\r\n        Data data = proxy;\r\n        data = proxy;\r\n        bar( proxy );\r\n    }\r\n\r\n    // lvalue / const\r\n    {\r\n        ProxyData const proxy;\r\n        Data data = proxy;\r\n        data = proxy;\r\n        bar( proxy );\r\n    }\r\n}\r\n```\r\n\r\nТакая ситуация связана с тем, что результат функции foo() одинаково хорошо стандартно преобразуется в ссылку rvalue и константную ссылку lvalue на временный экземпляр Proxy, который в свою очередь может быть одинаково пользовательски преобразован в ссылку rvalue и константную ссылку lvalue на внутреннее значение. Цепочки преобразований равнозначные - компилятор не может выбрать одну из них.\r\n\r\nЕсли стандартизировать преобразование в ссылку rvalue предпочтительнее преобразования в константную ссылку lvalue, то данную ситуацию можно было бы разрешить однозначно верно.\r\n\r\nТакое изменение не привнесет нежелательных побочных эффектов в существующую кодовую базу, так как только уточняет правила связывания временных объектов с сылками (работает в gcc7) и позволит реализовать пользовательские операторы преобразования типов с сохранением свойств rvalue/lvalue и const/volatile.\r\n\r\nСсылка на исходный код [godbolt](https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGIAMwArKSuADJ4DJgAcj4ARpjEIACc0gAOqAqETgwe3r4BwemZjgLhkTEs8Ykptpj2JQxCBEzEBLk%2BfkG19dlNLQRl0XEJydIKza3t%2BV3j/YMVVaMAlLaoXsTI7Bzm/hHI3lgA1Cb%2BbmwsJACeJ9gmGgCCd/fjxF4OhwAiTM1PJgDsVgeh2Bn2%2BTEOECWxwB/w%2BTxBoOaEMR4PMADZ0YdUAQEAlDlD/lY/nCgSCvkiICjDmgGONjmYMQysTi8QSYcT4WSwcjyaimdjccR8dCiST7gjeTzuTS6ZiBayRbDfqTgZK5akEt8SMd/B8pUj0XKWUK2RZDsRMAR1gxDgAqHF4BQnM1KlVU9WaohCk56ymSmUEemMtHMwXCwnmy3Wu0Op3%2BF0ct1q/ka4ha726/V8kPyk0iyNW4g2%2B0IR3O6FiiXcj1pr0631UgNB0MKiMWwvF2Pl12PDnx5X3ABuqDw6EOsRaWaDRrDpp7w9H48nfulAllDJnrfZYoXY4nQpXBv5xvD26eu6XB8ba8Dm7zhJ7TwImBYqQMz51bkOBEuGuYbEOAAVHVbgeF43kDZRiFQVRrgeB83WAlgAH1B2dAcEVQVN0yA6cmUhPCQzbKMi0OWZHGQZDRHGE4v2Aw0mRuCAUMHJZu0TcUQSwz1tWApsGJDAj%2BI3RiAQLaNyLwSjqIIWjcOE4MQOY1C2PjCtOWBbja145sCMxYiO0OFj2MrLjsLrPib10qEFPzdto2MtTH0QwjDmAS0IQJESiLE%2BzSMk6SmBo05cIEpSWNUhNTOBSzaVvby3I8oSrLCgyJOaCiqKC2SQti9dFKYiKTI00KmXcwM9NEs0/JtRyopKvL4pDcrPOpFKqvE0i6vU%2BC%2B0BR4Hi8TIjEOKCYMuNVMzG2C5Mm25%2B3gh5pom7l%2BFQVq0tIh8%2Bp6%2B5lv9KzkDWjbfJIm1trhJyOKeCJAxYJgIk834YTdBEEM4hFPsOAB6b7zUHMQvEwH6jK8ZpYnoEqvuBd7obhql0GrTM1shAA6crIXQ174eBRGDWR1BUDRjHIqhnHL0pFGlnRy0CNJ7Gvucj74d%2B/7AeBv6AzJxmXuZ8mEaRvUjsJ4nafpvnybx1FM2FonqZJrGJZx/dKVl0WCDpxX%2BaZ/nWdoAHvA50HwchhnPth/mQX27lUmgmaFqV%2BHJSl%2BtDlt8aaY18XLZBF2fTdu3Lk9zGHZ94EVYDj2SfxLXyZ18m9YNoGQa5s23t5sPRsDg64sj%2B3%2Bsz53BbzoOFdDsO/czd3YOD72w4j6vS7FmPy5xns4fb6GLZx1niCTo2WDBpgIcwbnzYzsOi/xvUqdjn3K5nkW659iOqZbgu4%2ButOQV7/uU5vMf043n2p%2BloXZ9by2F%2BpC/j8tiO1ahZf4fjnu/v19mQcHk3R%2B3mGJ59tbJEjc56W1Pq7EBl9%2BbX0gXffmDdA7r0PiCV%2BLN35705gfP%2BipsEIiAeCJssDkFfXAf7IhuDfbF3IY7OGCDxpIOwZ3HmYoSo1UOBoRWsIOArFoJwQIvA/AcC0KQVAnA3DWGsGRNYGxgY7B4KQAgmhuErAANYgEkAADlRlwP4GiuBmECEkDQaJAgaMCJIaQvCOCSAEUokRnBeAKBABoBRSiVhwFgEgNAr46AJHIJQbxqRfGJGAH8YIWBBxSUwAANTwJgAA7gAeT/JweRNBaDPmIE4iAsQ7GxAiC0S4qTeD5OYMQS4iTYjaEwA4YppBvFsEEIkhgtAilCN4Fge6RhxDtNIPgC0Dg8CDkwE43pmBVA1LBlseRt06h2NoHgWIaZykeCwHYggxA8AsGKSsKgBhgAKFiQk5JjA6n8EECIMQ7ApAyEEIoFQ6hem6C4PoQwxgJGWH0IspxkAVhYQaKMxxdQakNBcAwdwngOh6DCBEIYlQRgvKKFkAQUw/CIoyMihg8xhiJBeXYEFvQJhtEhfkPFwLBkCD6K0bF8LcW2CJaivQsxqWwoWAilYChpGbAkDwvhtjemiI4IcVQGi0QAFo0SSDcsgZAhw/io0CBCXAhBtRyKWLwRR7T3FeNQD4%2BgZAKAQECcElABgjDIQ2V4BgKi%2BmYEiZsI5SSUncF4OkzJ2Tcm9NKYUup3rymVOqbUl19TdWNIIM01pdjOlvJ6cI/pBLhmjOEeMyZz46mzKscIhZSzCmrK2MIjZWydl8H2YcuJTrTnBvOcIUQ4gbnVvuWoOxugzCvKMCgD5Nhs0/MhCI1IAKHHdAJc4CArhGUvJheUHFegkUNHHaQWd2QaWLDJT0SlDKSVoqHRSxoRLl0Ivpf0edzKBisunVwDlXLrm8o4Pw0ggjhGCuFaKiVUr9hvIhJa61UIIDKrrGqjVbjSAQB1XqvxhrjX6pAMAfRraIlRMdScwRaS6DusoJ64Rfq2nyKwwGkFdSGmMHDS0tpcaXwxvzR0vAAzHCJrsSm5AUz02CDmb07NyzLh5vWZs7ZLrdmlsQ86tJshLl1ukA2pQTannqLbe8yw1gvmxB7X8/t2RAWrHWNyi9%2Bg%2BX3rsU%2BkV4rJXStlfo1GZglX4H/WYfwF7ANauA6BoJ%2Br/FGt1c5kY%2BwuBJGQv4ODdqEPlqQ2c1DCQPV5IKeU31kWKlVPw8GwjTSSNRvI90yjfTqMJpGfRiZjG03BozfMxZHGuO9MLbxng/GmAHME5W4TFza3XPE7IRtjzhG6H8LJjt8nPndvgCpgdHAgVrr8KO8F87J1wpXQujFc7N0ztm0us9tKmXkoaFS4leQt34p3Rt/ddKT3Hr3ctldl7NPXp07e/lj7ODPpDCwBQg5ZWDm89ojQEIADqABJKI2Af1/tVTZuzritUrFxEwLAiRe1qMCFwVGGizBcA0X8SQGgkj%2BEkFIQIkrLs2L0wKwdTiXGaq0EsG9Zhru8EFfZ0nKxhlZOyOooAA%3D%3D%3D)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/552/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/552/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/551",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/551/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/551/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/551/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/551",
    "id": 1606427752,
    "node_id": "I_kwDOFK7cns5fwCRo",
    "number": 551,
    "title": "Функция возвращющие размер динамического выделенного массива в частности std::unique_ptr<T[]>::size() method.",
    "user": {
      "login": "raidenluikang",
      "id": 24319853,
      "node_id": "MDQ6VXNlcjI0MzE5ODUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/24319853?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raidenluikang",
      "html_url": "https://github.com/raidenluikang",
      "followers_url": "https://api.github.com/users/raidenluikang/followers",
      "following_url": "https://api.github.com/users/raidenluikang/following{/other_user}",
      "gists_url": "https://api.github.com/users/raidenluikang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raidenluikang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raidenluikang/subscriptions",
      "organizations_url": "https://api.github.com/users/raidenluikang/orgs",
      "repos_url": "https://api.github.com/users/raidenluikang/repos",
      "events_url": "https://api.github.com/users/raidenluikang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raidenluikang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-03-02T09:19:57Z",
    "updated_at": "2023-03-02T09:19:57Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "При выделение массив динамический способом, компилятор \"знает\" его размер, и хранить его где-то в любом случае.\r\n\r\n```\r\nint arr = new int[444]; // --> 444 где то в памяти хранится, все равно.\r\n\r\n....\r\n\r\ndelete [] arr; // -> Если компилятор \"незнал\" бы размер, здесь он не смог бы удалить весь выделенный память.\r\n```\r\nПредлагаю добавить функция \"извлекающий\" тот размер из памяти.\r\n\r\nТипа того `get_dynamic_array_allocated_size`.\r\n\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nЭто очень полезно в std::unique_ptr<T[]>   ,  теперь там можно добавить size()  метод возвращающий размер массива.\r\n\r\n\r\nЭто удобно в std::vector<T, std::allocator<T>>  с стандартнами аллокатаорами, теперь vector capacity можно не хранить, а спросить это из аллокатора.\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\n\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/551/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/551/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/549",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/549/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/549/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/549/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/549",
    "id": 1593881491,
    "node_id": "I_kwDOFK7cns5fALOT",
    "number": 549,
    "title": "RTTI and Exceptions сделать опциональный",
    "user": {
      "login": "raidenluikang",
      "id": 24319853,
      "node_id": "MDQ6VXNlcjI0MzE5ODUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/24319853?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raidenluikang",
      "html_url": "https://github.com/raidenluikang",
      "followers_url": "https://api.github.com/users/raidenluikang/followers",
      "following_url": "https://api.github.com/users/raidenluikang/following{/other_user}",
      "gists_url": "https://api.github.com/users/raidenluikang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raidenluikang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raidenluikang/subscriptions",
      "organizations_url": "https://api.github.com/users/raidenluikang/orgs",
      "repos_url": "https://api.github.com/users/raidenluikang/repos",
      "events_url": "https://api.github.com/users/raidenluikang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raidenluikang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-02-21T17:49:40Z",
    "updated_at": "2023-07-10T17:14:18Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Некоторые страдает изза RTTI и exceptions (исключение), embedded, mobile, ioT разработчики, еще у некоторые компании не разрешается использовать RTTI and exceptions.\r\n\r\n Почти все 3 большие компиляторы (GCC, Clang, MSVC) поддерживает -fno-rtti  , -fno-exceptions. Но это не предусмотрено в стандарте, если не ошибаюсь.\r\n\r\nПредлагаю стандартном уровне их сделать опциональные фича, Определить каждый случае без исключение или без RTTI.\r\n\r\nДа это очень трудноёмкая задача, зато точно знаем что будет если включим -fno-rtti,  -fno-exceptions.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/549/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/549/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/548",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/548/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/548/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/548/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/548",
    "id": 1592852855,
    "node_id": "I_kwDOFK7cns5e8QF3",
    "number": 548,
    "title": "Предварительное описание методов",
    "user": {
      "login": "osheter",
      "id": 87515424,
      "node_id": "MDQ6VXNlcjg3NTE1NDI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/87515424?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osheter",
      "html_url": "https://github.com/osheter",
      "followers_url": "https://api.github.com/users/osheter/followers",
      "following_url": "https://api.github.com/users/osheter/following{/other_user}",
      "gists_url": "https://api.github.com/users/osheter/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osheter/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osheter/subscriptions",
      "organizations_url": "https://api.github.com/users/osheter/orgs",
      "repos_url": "https://api.github.com/users/osheter/repos",
      "events_url": "https://api.github.com/users/osheter/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osheter/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 7,
    "created_at": "2023-02-21T05:49:57Z",
    "updated_at": "2023-05-29T15:16:57Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Разрешить предварительное описание методов, не описывая весь класс.\r\nИспользовать вместо pimpl.\r\n\r\n// h-файл\r\n```\r\nclass foo;\r\nint foo::bar() const;\r\n```\r\n\r\n// cpp-файл\r\n```\r\nclass foo\r\n{ \r\npublic:\r\n  int bar() const { return 0; }\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/548/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/548/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/547",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/547/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/547/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/547/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/547",
    "id": 1590263334,
    "node_id": "I_kwDOFK7cns5eyX4m",
    "number": 547,
    "title": "Аттрибут [[pure]] для функций.",
    "user": {
      "login": "IMMZ",
      "id": 1856709,
      "node_id": "MDQ6VXNlcjE4NTY3MDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1856709?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/IMMZ",
      "html_url": "https://github.com/IMMZ",
      "followers_url": "https://api.github.com/users/IMMZ/followers",
      "following_url": "https://api.github.com/users/IMMZ/following{/other_user}",
      "gists_url": "https://api.github.com/users/IMMZ/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/IMMZ/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/IMMZ/subscriptions",
      "organizations_url": "https://api.github.com/users/IMMZ/orgs",
      "repos_url": "https://api.github.com/users/IMMZ/repos",
      "events_url": "https://api.github.com/users/IMMZ/events{/privacy}",
      "received_events_url": "https://api.github.com/users/IMMZ/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-02-18T08:49:12Z",
    "updated_at": "2023-07-28T14:35:43Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Наряду с аттрибутами [[likely]] и [[unlikely]] было бы неплохо добавить аттрибут [[pure]], чтобы указать, что функция [чистая](https://en.wikipedia.org/wiki/Pure_function), т.е. не имеет побочных эффектов. Это могло бы помочь компиляторам с оптимизацией.\r\n\r\nПример:\r\n[[pure]]\r\nint sum(int a, int b) {\r\n    return a + b;\r\n}\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/547/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/547/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/550",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/550/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/550/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/550/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/550",
    "id": 1602468826,
    "node_id": "I_kwDOFK7cns5fg7va",
    "number": 550,
    "title": "std::format специализированный типом возвращаемого контейнера.",
    "user": {
      "login": "XRay3D",
      "id": 10693876,
      "node_id": "MDQ6VXNlcjEwNjkzODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10693876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/XRay3D",
      "html_url": "https://github.com/XRay3D",
      "followers_url": "https://api.github.com/users/XRay3D/followers",
      "following_url": "https://api.github.com/users/XRay3D/following{/other_user}",
      "gists_url": "https://api.github.com/users/XRay3D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/XRay3D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/XRay3D/subscriptions",
      "organizations_url": "https://api.github.com/users/XRay3D/orgs",
      "repos_url": "https://api.github.com/users/XRay3D/repos",
      "events_url": "https://api.github.com/users/XRay3D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/XRay3D/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-02-07T22:16:37Z",
    "updated_at": "2023-02-28T06:51:08Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Чтобы можно было использовать сразу\r\n```cpp\r\nuse(std::format<QString>(\"...\", ...));\r\n```\r\nвместо использования промежуточных переменных.\r\n```cpp\r\nQString str;\r\nstd::format_to(std::back_inserter(str), \"...\", ...);\r\nuse(str);\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/550/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/550/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/546",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/546/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/546/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/546/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/546",
    "id": 1560942208,
    "node_id": "I_kwDOFK7cns5dChaA",
    "number": 546,
    "title": "Функция принудительного завершения времени жизни локальной переменной",
    "user": {
      "login": "Centimo",
      "id": 7148130,
      "node_id": "MDQ6VXNlcjcxNDgxMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7148130?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Centimo",
      "html_url": "https://github.com/Centimo",
      "followers_url": "https://api.github.com/users/Centimo/followers",
      "following_url": "https://api.github.com/users/Centimo/following{/other_user}",
      "gists_url": "https://api.github.com/users/Centimo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Centimo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Centimo/subscriptions",
      "organizations_url": "https://api.github.com/users/Centimo/orgs",
      "repos_url": "https://api.github.com/users/Centimo/repos",
      "events_url": "https://api.github.com/users/Centimo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Centimo/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2023-01-28T17:35:30Z",
    "updated_at": "2023-01-28T17:36:35Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "**Кратко**\r\nПредлагается добавить в стандарт функцию, которая бы позволяла принудительно завершать время жизни локальной переменной, делая её недоступной для дальнейшего использования. Также предлагается реализовать _copy elision_ (или его аналог) для _xvalues_ вида `const T&&`.\r\n\r\n**Проблема**\r\nНа данный момент в C++ нет возможности убрать из скоупа переменную. В лучше случае, мы можем сделать `std::move`, который оставит после себя обнулённый (в зависимости от определения) объект.\r\nПример:\r\n\r\n```C++\r\n{\r\n  std::shared_ptr< Some > local_variable = std::make_shared< Some >(...);\r\n\t\r\n  ...\r\n\t\r\n  some_function(std::move(local_variable));\r\n\t\r\n  ...\r\n\t\r\n  local_variable->some_method(); // runtime (!) error\r\n}\r\n```\r\n\r\n**Предложение**\r\nДобавить функцию - пусть это будет, например, `std::drop`, - которая бы возвращала по аналогии с `std::move` _xvalue expression_, но при этом бы гарантировала ошибку компиляции в случае повтороного доступа к переменной. Тогда пример выше можно было бы написать следующим образом:\r\n\r\n```C++\r\n{\r\n  /* [const] */ std::shared_ptr< Some > local_variable = std::make_shared< Some >(...);\r\n\t\r\n  ...\r\n\t\r\n  some_function(std::drop(local_variable)); // тут переменная \"перемещается в функцию\" `some_function`, но удаляется из локального скоупа\r\n\t\r\n  ...\r\n\t\r\n  // local_variable->some_method(); // _compile_ time (!) error: \"local_variable was dropped before at line ...\"\r\n  // auto local_variable{}; // _compile_ time (!) error - переопределение должно быть запрещено\r\n  // decltype(local_variable) new_variable{}; // _compile_ time (!) error - такое тоже, вероятно, стоит запретить\r\n}\r\n\r\n```\r\nЕсли сделать переменную `local_variable` константной, то `std::move` теряет свой смысл (константная переменная должна \"обнулиться\", что явно не самый ожидаемый результат), а вот `std::drop` остаётся актуальной - нет смысла заботиться о константности переменной, удалённой из скоупа. То есть функция `std::drop` должна либо преобразовывать `const T&&` в `T&&`, либо реализовать _copy elision_. Последний вариант кажется более удачным.\r\nЕщё один пример для дискуссии:\r\n\r\n```C++\r\n{\r\n  std::shared_ptr< Some > local_variable = std::make_shared< Some >(...);\r\n\t\r\n  ...\r\n\t\r\n  // использование std::drop внутри условных операторов тоже стоит запретить. Как и внутри `switch .. case` и `try ... catch`.\r\n  /*\r\n  if (is_drop) {\r\n    std::drop(local_variable);\r\n  }\r\n  */ \r\n\t\r\n  // Использование функции вместе с её аргументом в тех случаях, когда порядок вычисления не определён, не допускается\r\n  // some_function(std::drop(local_variable), local_variable);\r\n  ...\r\n\t\r\n  // а вот такое, возможно, стоит разрешить\r\n  if constexpr (constexpr_is_drop) {\r\n    std::drop(local_variable);\r\n  }\r\n}\r\n```\r\n\r\nЕщё пример. Рассмотрим следующую структуру:\r\n```C++\r\nstruct Message {\r\n  const std::string _text;\r\n\r\n  Message() = delete;\r\n  Message(const Message&) = delete;\r\n  Message(Message&&) = delete;\r\n  Message(const Message&&);\r\n  Message operator = (Message&&) = delete;\r\n  Message operator = (const Message&&);\r\n\t\r\n  static std::unique_ptr< Message > make();\r\n};\r\n```\r\n\r\nТут всё просто: сообщение, которое:\r\nа) Константно. Если мы создали сообщение (например, с помощью статического метода класса `Message`), то оно не должно меняться.\r\nб) Существует в единственном экземпляре, для чего мы запретили конструктор копирования.\r\nв) Не может быть пустым, для чего мы запретили конструктор и оператор перемещения и конструктор по умолчанию.\r\n\r\nПусть мы хотим после этого определить следующий тип:\r\n\r\n```C++\r\nstruct Package {\r\n  const Message _message;\r\n  const int _id;\r\n\t\r\n  Package(const Message&& message, int id) \r\n    : _message(std::forward< const Message >(message) // копирование, а не перемещение\r\n    // : _message(message) // ошибка компиляции (конструктор копирования `Message` удалён)\r\n    // : _message(std::forward< Message >(message) // ошибка компиляции (_message константна)\r\n    , _id(id)\r\n  {}\r\n};\r\n\r\nint main() {\r\n  const Message message = ...;\r\n\t\r\n  ...\r\n\t\r\n  const Package package(std::move(message), 3); // копирование\r\n  // const Package package(std::drop(message), 3); // перемещение\r\n}\r\n```\r\n\r\nОшибки компиляции логичны, иначе нарушались бы гарантии константности. Но с функцией `std::drop` можно было бы реализовать перемещение констант.\r\n\r\n**Предложение суммарно:**\r\n1) Добавить функцию, позволяющую удалять локальные переменные из скоупа.\r\n2) Реализовать copy elision (или его аналог) для xvalues вида `const T&&` (с учётом случаев первого пункта).\r\n\r\n**Плюсы:**\r\n1) Появляется возможность сделать код более понятным и безопасным\r\n2) Расширяются возможности при работе с константами\r\n3) Добавляются подсказки для компиляторов/статических анализаторов\r\n\r\n**Минусы:**\r\n1) Возможно, чтобы разделить временные объекты и перемещаемые константы, придётся добавлять новый тип выражений (?)\r\n? ...\r\n\r\n**Обратная совместимость.**\r\nРеализация функции `std::drop` не нарушает обратную совместимость. Расширение _copy elision_ для _xvalues_ вида `const T&&` может нарушить обратную совместимость, если не будет привязано к использованию функции `std::drop`.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/546/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/546/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/545",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/545/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/545/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/545/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/545",
    "id": 1536359426,
    "node_id": "I_kwDOFK7cns5bkvwC",
    "number": 545,
    "title": "static_print",
    "user": {
      "login": "kov-serg",
      "id": 5946122,
      "node_id": "MDQ6VXNlcjU5NDYxMjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5946122?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kov-serg",
      "html_url": "https://github.com/kov-serg",
      "followers_url": "https://api.github.com/users/kov-serg/followers",
      "following_url": "https://api.github.com/users/kov-serg/following{/other_user}",
      "gists_url": "https://api.github.com/users/kov-serg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kov-serg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kov-serg/subscriptions",
      "organizations_url": "https://api.github.com/users/kov-serg/orgs",
      "repos_url": "https://api.github.com/users/kov-serg/repos",
      "events_url": "https://api.github.com/users/kov-serg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kov-serg/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-01-17T13:12:35Z",
    "updated_at": "2023-06-30T20:46:17Z",
    "closed_at": "2023-06-30T20:46:17Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Почему досих пор нет static_print? Уже 5 лет прошло.\r\n\r\nhttps://github.com/saarraz/static-print\r\n\r\nhttps://www.youtube.com/watch?v=61w4LbQ0fzU\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/545/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/545/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/544",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/544/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/544/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/544/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/544",
    "id": 1532818303,
    "node_id": "I_kwDOFK7cns5bXPN_",
    "number": 544,
    "title": "Добавить полезную вещь энумератам.",
    "user": {
      "login": "ghost",
      "id": 10137,
      "node_id": "MDQ6VXNlcjEwMTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ghost",
      "html_url": "https://github.com/ghost",
      "followers_url": "https://api.github.com/users/ghost/followers",
      "following_url": "https://api.github.com/users/ghost/following{/other_user}",
      "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
      "organizations_url": "https://api.github.com/users/ghost/orgs",
      "repos_url": "https://api.github.com/users/ghost/repos",
      "events_url": "https://api.github.com/users/ghost/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ghost/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2023-01-13T19:43:21Z",
    "updated_at": "2023-03-02T16:39:24Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Сделать enum чуть полезнее, чтобы можно было спокойно получать значение, зная какое значение имеет энумерат.\r\n\r\nДанная вещь будет полезна при создании обработчика событий браузера, написании игровых движков и там, где нужно зная какое значение имеет энумерат, получить значение.\r\n\r\nКак в Rust'е на данный момент:\r\n```\r\nenum DayTime{\r\n     \r\n    Morning(String),\r\n    Evening(String)\r\n}\r\n\r\nfn main(){\r\n//получили откуда-то значение var\r\nmatch var {\r\n    Morning(a) => {/* что-то */},\r\n    Evening(b) => {/* что-то */}\r\n}\r\n}\r\n```\r\n\r\nКак это выглядело бы в C++:\r\n```\r\nstruct  Data{\r\n    enum class Types{\r\n       WebErrorCode,\r\n       LoadedTime\r\n    };\r\n   Types t;\r\n   std::variant<int,float> values;\r\n};\r\nint main() {\r\n//взяли откуда-то экземпляр типа `Data`\r\nif (d.t == Data::Types::WebErrorCode){\r\n    //Тут дальше что-то делаете со значениями\r\n}\r\n}\r\n```\r\n\r\nКак хотелось бы в C++:\r\n```\r\nenum Data{\r\n    WebErrorCode(int),\r\n    LoadedTime(float)\r\n};\r\n\r\nint main(){\r\n//откуда-то получили данные\r\nif (D == Data::WebErrorCode){\r\n    int res = std::get<Data::WebErrorCode>(D); //Если попробовать получить Data::LoadedTime, то кидало бы ошибку компиляции.\r\n    //Дальше что-то делаете с этим.\r\n}\r\n}\r\n```\r\n\r\nТакже можно расширить switch, которым никто особо не пользуется, до match как в первом примере.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/544/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/544/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/543",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/543/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/543/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/543/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/543",
    "id": 1519447744,
    "node_id": "I_kwDOFK7cns5akO7A",
    "number": 543,
    "title": "in-place set_intersection, set_difference",
    "user": {
      "login": "loskutov",
      "id": 1202012,
      "node_id": "MDQ6VXNlcjEyMDIwMTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1202012?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/loskutov",
      "html_url": "https://github.com/loskutov",
      "followers_url": "https://api.github.com/users/loskutov/followers",
      "following_url": "https://api.github.com/users/loskutov/following{/other_user}",
      "gists_url": "https://api.github.com/users/loskutov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/loskutov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/loskutov/subscriptions",
      "organizations_url": "https://api.github.com/users/loskutov/orgs",
      "repos_url": "https://api.github.com/users/loskutov/repos",
      "events_url": "https://api.github.com/users/loskutov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/loskutov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-01-04T19:07:19Z",
    "updated_at": "2023-02-24T19:05:46Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Согласно стандарту, вызов `std::set_intersection` с output range, пересекающимся с input range, [приводит к неопределённому поведению](https://eel.is/c++draft/set.intersection#2), что делает невалидным код вроде:\r\n```cpp\r\n// std::vector<int> lhs, rhs;\r\nlhs.erase(std::set_intersection(lhs.begin(), lhs.end(),\r\n                                rhs.begin(), rhs.end(),\r\n                                lhs.begin()),\r\n          lhs.end()\r\n);\r\n```\r\n\r\nПри этом желание пересечь два множества, не выделяя дополнительной памяти, является довольно естественным и не накладывает дополнительных ограничений на имплементацию: см. [libstdc++](https://github.com/gcc-mirror/gcc/blob/18f176d0b25591e2880bc5ef453ce0834f9e0e2a/libstdc%2B%2B-v3/include/bits/stl_algo.h#L5261), [libc++](https://github.com/llvm/llvm-project/blob/ed2d3644abee9535eb07333beb1562a651001281/libcxx/include/__algorithm/set_intersection.h#L40) — даже в случае, если output range совпадает с каким-либо из input range, рассматриваемые алгоритмом интервалы (суффиксы исходных) всё равно не пересекаются с заполненной частью output range, и запись туда никак не влияет на последующие чтения.\r\n\r\nАналогичные соображения применимы и к `std::set_difference` (для первого input range) и соответствующим функциям из пространства имён `std::ranges`.\r\n\r\nКонечно, в случае, когда output range начинается строго внутри одного из input ranges, получается что-то странное, и в таком случае ничего не гарантировать выглядит разумным решением. Предлагается переписать preconditions, чтобы UB получалось только в таком случае, а если пересечение имеется, но такое, что input range начинается внутри (возможно, в начале) output range — такие входные данные должны быть допустимыми.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/543/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/543/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/542",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/542/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/542/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/542/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/542",
    "id": 1509935658,
    "node_id": "I_kwDOFK7cns5Z_8oq",
    "number": 542,
    "title": "standardize empty base/member optimization",
    "user": {
      "login": "DaMilyutin",
      "id": 44639272,
      "node_id": "MDQ6VXNlcjQ0NjM5Mjcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/44639272?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DaMilyutin",
      "html_url": "https://github.com/DaMilyutin",
      "followers_url": "https://api.github.com/users/DaMilyutin/followers",
      "following_url": "https://api.github.com/users/DaMilyutin/following{/other_user}",
      "gists_url": "https://api.github.com/users/DaMilyutin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DaMilyutin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DaMilyutin/subscriptions",
      "organizations_url": "https://api.github.com/users/DaMilyutin/orgs",
      "repos_url": "https://api.github.com/users/DaMilyutin/repos",
      "events_url": "https://api.github.com/users/DaMilyutin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DaMilyutin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 4417430062,
        "node_id": "LA_kwDOFK7cns8AAAABB0yiLg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/breaking-change",
        "name": "breaking-change",
        "color": "b60205",
        "default": false,
        "description": "Идея, ломающая валидный имеющийся код или бинарную совместимость"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2022-12-24T04:37:09Z",
    "updated_at": "2023-02-23T09:26:38Z",
    "closed_at": "2023-02-23T09:25:18Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_Idea_\r\nWe have EBO for empty base optimization. That reduces memory of object.\r\nIn same way we have [[no_unique_address]] which does similar thing.\r\nHowever, this is not standadrized as behavior. (Or prove me wrong.)\r\n\r\nWhat I'd like to see is default behavior is both for EBO/EMO.\r\n\r\nI think we go wrong way using attributee for EMO where it should be default behavior.\r\nFrom other hand, we can add attribute [[unique_address]] for contrary behavior.\r\n\r\n_Examples_\r\n`struct Empty\r\n{\r\n// methods, typedefs, static stuff...\r\n};\r\n\r\nstruct EmptyBase\r\n{\r\n// methods, typedefs, static stuff...\r\n}\r\n\r\nstruct Derived: EmptyBase // EBO kicks in by default\r\n{\r\n   Data data;\r\n   Empty empty; // EMO kicks in by default\r\n};\r\n\r\nstruct Derived: [[unique_address]] EmptyBase // attribute stops EBO\r\n{\r\n   Data data;\r\n   [[unique_address]] Empty empty; // attribute stops EMO\r\n};`",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/542/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/542/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/541",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/541/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/541/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/541/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/541",
    "id": 1501472334,
    "node_id": "I_kwDOFK7cns5ZfqZO",
    "number": 541,
    "title": "Новое служебное слово",
    "user": {
      "login": "mitya-y",
      "id": 96876822,
      "node_id": "U_kgDOBcY5Fg",
      "avatar_url": "https://avatars.githubusercontent.com/u/96876822?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mitya-y",
      "html_url": "https://github.com/mitya-y",
      "followers_url": "https://api.github.com/users/mitya-y/followers",
      "following_url": "https://api.github.com/users/mitya-y/following{/other_user}",
      "gists_url": "https://api.github.com/users/mitya-y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mitya-y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mitya-y/subscriptions",
      "organizations_url": "https://api.github.com/users/mitya-y/orgs",
      "repos_url": "https://api.github.com/users/mitya-y/repos",
      "events_url": "https://api.github.com/users/mitya-y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mitya-y/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2022-12-17T16:53:18Z",
    "updated_at": "2023-02-24T17:29:51Z",
    "closed_at": "2023-02-24T17:29:39Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Новое служебное слово для объявления переменых в классе, которые доступны как константы вне класса, и как обычные не const в методах самого класса.\r\n\r\nДанное решение будет очень удобным для реализации SOLID идеалогии.\r\nСейчас програмисты вынуждены писать так:\r\n\r\nclass A\r\n{\r\n  int x;\r\n...\r\npublic:\r\n  const int & GetX( void );\r\n}\r\n...\r\nA a;\r\nint x = a.GetX();\r\n\r\nНа обертку каждой переменной класса в больших проектах уходит большое количество времени. Намного удобнее написать одно служебное слово (например extconst (external const))\r\n\r\nclass A\r\n{\r\npublic:\r\n   extconst int x;\r\n   ...\r\n   A( int n)\r\n   {\r\n      x = n;\r\n   }\r\n}\r\n...\r\nA a;\r\nint x = a.x;\r\na.x = 10; // ошибка компиляции\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/541/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/541/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/540",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/540/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/540/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/540/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/540",
    "id": 1458579181,
    "node_id": "I_kwDOFK7cns5W8Cbt",
    "number": 540,
    "title": "Стандартизировать девиртуализацию вызовов",
    "user": {
      "login": "Izaron",
      "id": 5406399,
      "node_id": "MDQ6VXNlcjU0MDYzOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5406399?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Izaron",
      "html_url": "https://github.com/Izaron",
      "followers_url": "https://api.github.com/users/Izaron/followers",
      "following_url": "https://api.github.com/users/Izaron/following{/other_user}",
      "gists_url": "https://api.github.com/users/Izaron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Izaron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Izaron/subscriptions",
      "organizations_url": "https://api.github.com/users/Izaron/orgs",
      "repos_url": "https://api.github.com/users/Izaron/repos",
      "events_url": "https://api.github.com/users/Izaron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Izaron/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-11-21T21:08:46Z",
    "updated_at": "2022-11-21T21:14:04Z",
    "closed_at": "2022-11-21T21:14:04Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Нужно стандартизировать девиртуализацию - то есть оптимизацию, когда делается явный вызов метода объекта полиморфического класса без диспетчеризации (т.е. просмотра vtable), если компилятор может доказать, что 100% будет вызван именно этот метод.\r\n\r\nУсловия для девиртуализации строгие - например в одном из кейсов класс должен быть помечен final, и мы должны иметь дело со ссылкой на этот класс. Об этом круче всего написано в этой статье - https://blog.feabhas.com/2022/11/using-final-in-c-to-improve-performance/\r\n\r\nСамый важный для меня кейс - это **девиртуализация вызова виртуального деструктора** для объекта на стеке. Для всех объектов на стеке можно девиртуализовать все вызовы, в том числе деструктор.\r\nЕсли это стандартизировать, это даст возможность компилятору **автоматически делать деструктор виртуальным** (если в классе есть виртуальные методы), это уберет вероятность UB.\r\nТогда не будет такой тупости, что все пишут `virtual ~Foo() = default`, это сделает компилятор за них.\r\n\r\nУ меня есть микро-статья на эту тему - https://t.me/cxx95/67.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/540/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/540/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/539",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/539/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/539/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/539/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/539",
    "id": 1405964178,
    "node_id": "I_kwDOFK7cns5TzU-S",
    "number": 539,
    "title": "обобщить `rebind` в стандартной библиотеке",
    "user": {
      "login": "sigasigasiga",
      "id": 48245894,
      "node_id": "MDQ6VXNlcjQ4MjQ1ODk0",
      "avatar_url": "https://avatars.githubusercontent.com/u/48245894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sigasigasiga",
      "html_url": "https://github.com/sigasigasiga",
      "followers_url": "https://api.github.com/users/sigasigasiga/followers",
      "following_url": "https://api.github.com/users/sigasigasiga/following{/other_user}",
      "gists_url": "https://api.github.com/users/sigasigasiga/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sigasigasiga/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sigasigasiga/subscriptions",
      "organizations_url": "https://api.github.com/users/sigasigasiga/orgs",
      "repos_url": "https://api.github.com/users/sigasigasiga/repos",
      "events_url": "https://api.github.com/users/sigasigasiga/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sigasigasiga/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-10-12T10:28:11Z",
    "updated_at": "2022-10-21T09:19:54Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "насколько мне известно, изначально для нужд стандартной библиотеки `rebind` был необходим только для аллокаторов. теперь, с грядущим приходом C++23 `rebind` будет необходим ещё и для `std::expected`.\r\n\r\nкак мне кажется, плодить для каждого нуждающегося в `rebind`'е класса отдельный `typedef` -- слишком кривое решение, которое мало того что плохо масштабируется, порождая лишний бойлерплейт, так ещё и выглядит просто ужасно (вспомните про `std::allocator_traits<AllocatorForT>::template rebind_alloc<U>`). хотя ничто не мешает реализовать подобный функционал вообще для всех шаблонов классов сразу\r\n\r\n```С++\r\nnamespace detail {\r\n\r\ntemplate<typename...>\r\nstruct type_vector{};\r\n\r\ntemplate<template<class...> class T, typename... OldArgs, typename... NewArgs>\r\nT<NewArgs...> rebind_impl(T<OldArgs...>&& f, type_vector<NewArgs...>);\r\n\r\n} // namespace detail\r\n\r\ntemplate<typename Rebindee, typename... NewArgs>\r\nstruct rebind\r\n{\r\n    using type = decltype(rebind_impl(std::declval<Rebindee>(), detail::type_vector<NewArgs...>{}));\r\n};\r\n\r\ntemplate<typename Rebindee, typename... NewArgs>\r\nusing rebind_t = typename rebind<Rebindee, NewArgs...>::type;\r\n\r\nint main()\r\n{\r\n    std::allocator<int> int_alloc;\r\n    rebind_t<decltype(int_alloc), double> double_alloc;\r\n    static_assert(std::is_same_v<decltype(double_alloc), std::allocator<double>>);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/539/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/539/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/538",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/538/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/538/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/538/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/538",
    "id": 1371071753,
    "node_id": "I_kwDOFK7cns5RuOUJ",
    "number": 538,
    "title": "std::exclusive_or",
    "user": {
      "login": "dasfex",
      "id": 40736909,
      "node_id": "MDQ6VXNlcjQwNzM2OTA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/40736909?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dasfex",
      "html_url": "https://github.com/dasfex",
      "followers_url": "https://api.github.com/users/dasfex/followers",
      "following_url": "https://api.github.com/users/dasfex/following{/other_user}",
      "gists_url": "https://api.github.com/users/dasfex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dasfex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dasfex/subscriptions",
      "organizations_url": "https://api.github.com/users/dasfex/orgs",
      "repos_url": "https://api.github.com/users/dasfex/repos",
      "events_url": "https://api.github.com/users/dasfex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dasfex/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-09-13T08:35:57Z",
    "updated_at": "2022-09-13T19:02:12Z",
    "closed_at": "2022-09-13T19:02:12Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В STL есть ```std::conjunction``` и ```std::disjunction```. Тут покрыты лишь две из трёх основных битовых операций в короткой форме. Однако нет никакого аналога xor-метафунктора (xor по определению не имеет короткой формы, но всё же). \r\n\r\nPossible implementation:\r\n```cpp\r\ntemplate <typename T, typename... Args>\r\nstruct exclusive_or : exclusive_or<T, exclusive_or<Args...>> {};\r\n\r\ntemplate <typename T>\r\nstruct exclusive_or<T> : T {};\r\n\r\ntemplate <typename T, typename S>\r\nstruct exclusive_or<T, S> {\r\n    static constexpr bool value = T::value ^ S::value;\r\n};\r\n\r\ntemplate <typename... Args>\r\nconstexpr inline bool exclusive_or_v = exclusive_or<Args...>::value;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/538/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/538/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/537",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/537/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/537/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/537/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/537",
    "id": 1360271777,
    "node_id": "I_kwDOFK7cns5RFBmh",
    "number": 537,
    "title": "добавить возможность передать владение указателем в/из `std::string` и `std::vector`",
    "user": {
      "login": "sigasigasiga",
      "id": 48245894,
      "node_id": "MDQ6VXNlcjQ4MjQ1ODk0",
      "avatar_url": "https://avatars.githubusercontent.com/u/48245894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sigasigasiga",
      "html_url": "https://github.com/sigasigasiga",
      "followers_url": "https://api.github.com/users/sigasigasiga/followers",
      "following_url": "https://api.github.com/users/sigasigasiga/following{/other_user}",
      "gists_url": "https://api.github.com/users/sigasigasiga/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sigasigasiga/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sigasigasiga/subscriptions",
      "organizations_url": "https://api.github.com/users/sigasigasiga/orgs",
      "repos_url": "https://api.github.com/users/sigasigasiga/repos",
      "events_url": "https://api.github.com/users/sigasigasiga/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sigasigasiga/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 16,
    "created_at": "2022-09-02T14:27:11Z",
    "updated_at": "2022-12-14T16:21:50Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "C++ хорош тем, что он позволяет без лишней возни и оверхеда использовать C'шные библиотеки. однако в некоторых сценариях межъязыковое взаимодействие всё-таки даёт о себе знать:\r\nпредположим, C'шная библиотека возвращает какой-то буфер, владение которым отдаётся на откуп пользователю, а затем этот буфер надо передать уже в плюсовую библиотеку, которая принимает какой-то contiguous контейнер (например, `std::vector` или `std::string`). в этом случае не видится никакого другого решения, кроме как скопировать буфер из C'шной библиотеки в контейнер, а затем его удалить. копирование на пустом месте!\r\n\r\nпримерно та же история может быть работать в обратную сторону: может потребоваться отдать в C'шную библиотеку владение указателем, который принадлежит `std::vector`'у или `std::string`'у, и в этом случае тоже придётся делать абсолютно бессмысленное копирование.\r\n\r\nпредлагается дать возможность контейнерам более гибко работать с владением буферами.\r\n\r\n**передача владения в контейнер**\r\nнаверное, стоит сделать новый конструктор от четырёх аргументов: `pointer`, `size`, `capacity` и `allocator` -- такой вариант конструктора, насколько я вижу, ещё никем не использован. возможно, лучше бы было добавить статический метод в класс, чтобы его имя лучше отражало суть происходящего, однако судя по тому, что в комитете ни разу подобным образом не поступили, такой вариант вряд ли прийдётся кому-то по душе.\r\n\r\n**передача владения из контейнера**\r\nдля этого, думаю, стоит добавить метод `release` по аналогии с тем, что сейчас есть в `std::unique_ptr`. возвращать он может какую-то структуру (но ни в коем случае не `std::tuple`, использование которого обречёт пользователей на написание `std::get</* SOME MAGIC NUMBER */>`), которая будет содержать указатель, размер, capacity и аллокатор.\r\n\r\n**аллокаторы**\r\nэти изменения вряд ли будет работать так просто -- в C'шном коде в лучшем случае память выделяется с помощью `malloc`'а и удаляется с помощью `free`, а `std::allocator` делает это с помощью `new` и `delete` соответственно, и между собой эти два варианта аллокации/деаллокации, к сожалению, несовместимы. поэтому, скорее всего, нужно будет добавить в стандартную библиотеку ещё один вариант аллокатора, который использует `malloc` и `free` (а назвать его можно `mallocator`'ом:) ).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/537/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/537/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/536",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/536/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/536/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/536/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/536",
    "id": 1356547282,
    "node_id": "I_kwDOFK7cns5Q20TS",
    "number": 536,
    "title": "Улучшение для final_suspend",
    "user": {
      "login": "MBkkt",
      "id": 32071355,
      "node_id": "MDQ6VXNlcjMyMDcxMzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/32071355?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MBkkt",
      "html_url": "https://github.com/MBkkt",
      "followers_url": "https://api.github.com/users/MBkkt/followers",
      "following_url": "https://api.github.com/users/MBkkt/following{/other_user}",
      "gists_url": "https://api.github.com/users/MBkkt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MBkkt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MBkkt/subscriptions",
      "organizations_url": "https://api.github.com/users/MBkkt/orgs",
      "repos_url": "https://api.github.com/users/MBkkt/repos",
      "events_url": "https://api.github.com/users/MBkkt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MBkkt/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-08-31T00:46:50Z",
    "updated_at": "2022-08-31T00:46:50Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В идеальном мире return_value/void и final_suspend это одна функция.\r\n\r\nНа текущий момент времени этого уже сделать нельзя, к тому же возможно имеются сложности в реализации этого на уровне компилятора (из-за эксепшенов).\r\n\r\nПоэтому предлагается позволить писать:\r\n```cpp\r\ntemplate <typename T>\r\nauto final_suspend();\r\n```\r\n\r\nА компилятор вызовет final_suspend с типом параметра вызванного return_value.\r\nТогда в final_suspend мы можем понять, какая из перегрузок return_value была выбрана.\r\n\r\nhttps://github.com/YACLib/YACLib/issues/189\r\n\r\nЯ столкнулся с тем, что хочу возвращать разные типы в final_suspend.\r\nДля того чтобы реализовать \"future unwrapping\", иначе говоря вернуть асинхронной задачу из асинхронной задачи без ожидания (пусть и неблокирующего)\r\n\r\nПонятно что это не что-то критичное, но почему нет?\r\nК тому же я думаю со временем примеров станет больше.\r\nПо сути сюда подходит любое поведение, которое отличается в зависимости от возвращаемого типа.\r\nНапример возможны оптимизации на не хранение того что у нас есть отмена.\r\nИли запуск ленивой задачи при возврате из асинхронной.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/536/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/536/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/535",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/535/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/535/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/535/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/535",
    "id": 1354517507,
    "node_id": "I_kwDOFK7cns5QvEwD",
    "number": 535,
    "title": "Получение имени типа",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-08-29T15:48:38Z",
    "updated_at": "2022-08-31T20:13:37Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Часто не хватает простого способа получить имя типа в шаблоне. ( например в диагностике static_assert ) Почему бы не добавить nameof который работал бы аналогично size_of, но возвращал бы string_view/char* на имя типа.\r\n\r\n\r\nПолезные ссылки:\r\n*  (https://github.com/Neargye/nameof)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/535/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/535/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/534",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/534/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/534/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/534/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/534",
    "id": 1353959068,
    "node_id": "I_kwDOFK7cns5Qs8ac",
    "number": 534,
    "title": "Конструкторы с resize/reserve policy для std::vector. ",
    "user": {
      "login": "dasfex",
      "id": 40736909,
      "node_id": "MDQ6VXNlcjQwNzM2OTA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/40736909?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dasfex",
      "html_url": "https://github.com/dasfex",
      "followers_url": "https://api.github.com/users/dasfex/followers",
      "following_url": "https://api.github.com/users/dasfex/following{/other_user}",
      "gists_url": "https://api.github.com/users/dasfex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dasfex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dasfex/subscriptions",
      "organizations_url": "https://api.github.com/users/dasfex/orgs",
      "repos_url": "https://api.github.com/users/dasfex/repos",
      "events_url": "https://api.github.com/users/dasfex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dasfex/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-08-29T09:14:25Z",
    "updated_at": "2023-02-24T07:25:24Z",
    "closed_at": "2023-02-24T07:25:24Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Уже несколько лет почти ежедневно пользуюсь std::vector. И очень частая ситуация (95% случаев), когда код выглядит примерно так:\r\n\r\n```cpp\r\nstd::vector<SomeMyType> data;\r\ndata.reserve(some_value);\r\n```\r\n\r\nИ имхо очень неудобно делать это постоянно в несколько строк. Круто было бы иметь конструктор вроде:\r\n\r\n```cpp\r\nstd::vector<int> data(std::vector::reserve_policy, some_value);\r\n```\r\n\r\nИ можно ```std::vector::resize_policy``` для консистентности. \r\n\r\nТакже такой конструктор сможет сократить код и в некоторых других сценариях:\r\n\r\n```cpp\r\nvoid f(std::vector<int> data) {} // не обращаем внимания на копию\r\n\r\nstd::vector<int> data;\r\ndata.reserve(size);\r\nf(data);\r\n\r\n// vs\r\n\r\nf(std::vector<int>(std::vector::reserve_policy, size));\r\n```\r\n\r\n```cpp\r\nstd::vector<std::vector<int>> data(size1);\r\nfor (auto& vec : data) {\r\n  vec.reserve(size2);\r\n}\r\n\r\n// vs\r\n\r\nstd::vector<std::vector<int>> data(size1, std::vector<int>(std::vector::reserve_policy, size2));\r\n```\r\n\r\nПодозреваю, это ещё может открыть компилятору возможность немножко больше пооптимизировать код. \r\n\r\nПлюс можно какие-то удобные обёртки теперь писать, где пользователь сам может отдать policy в наш класс, а мы просто пробросим, чтобы не ифать или делать перегрузки. \r\n\r\nРеализация тривиальна. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/534/reactions",
      "total_count": 5,
      "+1": 4,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/534/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/533",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/533/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/533/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/533/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/533",
    "id": 1352978526,
    "node_id": "I_kwDOFK7cns5QpNBe",
    "number": 533,
    "title": "Неконсистентность вординга касательно equality of value representation",
    "user": {
      "login": "eoan-ermine",
      "id": 47888628,
      "node_id": "MDQ6VXNlcjQ3ODg4NjI4",
      "avatar_url": "https://avatars.githubusercontent.com/u/47888628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eoan-ermine",
      "html_url": "https://github.com/eoan-ermine",
      "followers_url": "https://api.github.com/users/eoan-ermine/followers",
      "following_url": "https://api.github.com/users/eoan-ermine/following{/other_user}",
      "gists_url": "https://api.github.com/users/eoan-ermine/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eoan-ermine/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eoan-ermine/subscriptions",
      "organizations_url": "https://api.github.com/users/eoan-ermine/orgs",
      "repos_url": "https://api.github.com/users/eoan-ermine/repos",
      "events_url": "https://api.github.com/users/eoan-ermine/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eoan-ermine/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-08-27T08:02:41Z",
    "updated_at": "2022-08-27T16:07:17Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "> «Pointers to layout-compatible types shall have the same value representation and alignment requirements» [(3.4) [basic.compound]](https://eel.is/c++draft/basic.compound#3.4)\r\n\r\n> «Evaluates load(order) and compares its value representation for equality against that of old.» [(23.1) [atomics.ref.ops]](https://eel.is/c++draft/atomics.ref.ops#23.1)\r\n\r\nВординг неконсистентен. В одном месте под equality of value representation имеется ввиду то, что кол-во битов в них одинаковое, а в другом то, что эти биты одинаковые.\r\n\r\nПричем в другом месте выражаются вот так: \r\n\r\n> «Each bit of the value representation of the result is equal to the corresponding bit in the object representation of from» [(26.5.3) [bit.cast]](https://eel.is/c++draft/bit.cast#2)\r\n\r\n\r\nТо есть, и [(23.1) [atomics.ref.ops]](https://eel.is/c++draft/atomics.ref.ops#23.1) было бы логично переписать как-то так для устранения неоднозначности: \r\n\r\n> «compares bits of its value representation for equality against these of old»\r\n\r\n\r\nМожно было бы посчитать, что то, что в одном случае речь идёт о количестве, а в другом о значениях битов, понятно из контекста.\r\n\r\nНо это не отменяет того, что в одном случае для того, чтобы обозначить сравнение значений битов value representation используется вординг each bit of the value representation, а в других случаях просто compares its value representation, что вносит лишнюю путаницу.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/533/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/533/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/532",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/532/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/532/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/532/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/532",
    "id": 1347100326,
    "node_id": "I_kwDOFK7cns5QSx6m",
    "number": 532,
    "title": "Неявное приведение std::pair к структуре.",
    "user": {
      "login": "IvanOrfanidi",
      "id": 10355755,
      "node_id": "MDQ6VXNlcjEwMzU1NzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/10355755?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/IvanOrfanidi",
      "html_url": "https://github.com/IvanOrfanidi",
      "followers_url": "https://api.github.com/users/IvanOrfanidi/followers",
      "following_url": "https://api.github.com/users/IvanOrfanidi/following{/other_user}",
      "gists_url": "https://api.github.com/users/IvanOrfanidi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/IvanOrfanidi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/IvanOrfanidi/subscriptions",
      "organizations_url": "https://api.github.com/users/IvanOrfanidi/orgs",
      "repos_url": "https://api.github.com/users/IvanOrfanidi/repos",
      "events_url": "https://api.github.com/users/IvanOrfanidi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/IvanOrfanidi/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2022-08-22T23:10:32Z",
    "updated_at": "2022-08-29T07:41:49Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Неявное приведение  std::pair к структуре.\r\n\r\nВозможное продолжение с structured binding и упрощение синтаксиса С++.\r\nПриведение будет работать если типы структуры и pair совпадают, ну и логично количество элементов только 2.\r\n\r\nНапример:\r\n```\r\nint main() {\r\n    std::map<std::string, unsigned> all_data = {\r\n      {\"GPS\", 14},\r\n      {\"GLONASS\", 10},\r\n      {\"GALILEO\", 8},\r\n    };\r\n\r\n    struct GPS_Data {\r\n        std::string service{};\r\n        unsigned num_of_sat = 0;\r\n    };\r\n    GPS_Data gps = *all_data.begin();\r\n\r\n    std::cout << \"Service: \" << gps.service << \", Number of satellites: \" << gps.num_of_sat << std::endl;\r\n}\r\n\r\n```\r\n\r\nВместо:\r\n```\r\n    const auto& [service, num_of_sat] = *all_data.begin();\r\n    GPS_Data gps = {service, num_of_sat};\r\n```\r\n\r\nВозможные проблемы:\r\nПониманием кода когда структура содержит один элемент std::pair.\r\n\r\n```\r\n    struct GPS_Data {\r\n        std::pair<std::string, unsigned> data;\r\n    };\r\n    GPS_Data gps = {*all_data.begin()};\r\n```\r\n\r\nТогда запись:\r\n ```GPS_Data gps = {*all_data.begin()};```  против  ```GPS_Data gps = *all_data.begin();```\r\n может вызывать неоднозначность.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/532/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/532/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/531",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/531/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/531/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/531/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/531",
    "id": 1347072691,
    "node_id": "I_kwDOFK7cns5QSrKz",
    "number": 531,
    "title": " Неявное приведение",
    "user": {
      "login": "IvanOrfanidi",
      "id": 10355755,
      "node_id": "MDQ6VXNlcjEwMzU1NzU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/10355755?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/IvanOrfanidi",
      "html_url": "https://github.com/IvanOrfanidi",
      "followers_url": "https://api.github.com/users/IvanOrfanidi/followers",
      "following_url": "https://api.github.com/users/IvanOrfanidi/following{/other_user}",
      "gists_url": "https://api.github.com/users/IvanOrfanidi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/IvanOrfanidi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/IvanOrfanidi/subscriptions",
      "organizations_url": "https://api.github.com/users/IvanOrfanidi/orgs",
      "repos_url": "https://api.github.com/users/IvanOrfanidi/repos",
      "events_url": "https://api.github.com/users/IvanOrfanidi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/IvanOrfanidi/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-08-22T22:34:31Z",
    "updated_at": "2022-08-22T22:35:06Z",
    "closed_at": "2022-08-22T22:35:06Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\n\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/531/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/531/timeline",
    "performed_via_github_app": null,
    "state_reason": "not_planned"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/530",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/530/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/530/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/530/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/530",
    "id": 1337946733,
    "node_id": "I_kwDOFK7cns5Pv3Jt",
    "number": 530,
    "title": "Замыкания методов без лямбд",
    "user": {
      "login": "pavelkryukov",
      "id": 11466405,
      "node_id": "MDQ6VXNlcjExNDY2NDA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11466405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pavelkryukov",
      "html_url": "https://github.com/pavelkryukov",
      "followers_url": "https://api.github.com/users/pavelkryukov/followers",
      "following_url": "https://api.github.com/users/pavelkryukov/following{/other_user}",
      "gists_url": "https://api.github.com/users/pavelkryukov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pavelkryukov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pavelkryukov/subscriptions",
      "organizations_url": "https://api.github.com/users/pavelkryukov/orgs",
      "repos_url": "https://api.github.com/users/pavelkryukov/repos",
      "events_url": "https://api.github.com/users/pavelkryukov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pavelkryukov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-08-13T12:20:52Z",
    "updated_at": "2022-08-16T20:58:29Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В C++ валиден такой синтаксис:\r\n\r\n```c++\r\nstruct A\r\n{\r\n    int foo(int x);\r\n};\r\n\r\nint bar(int x);\r\n\r\nA a;\r\n(a.foo)(5);\r\n(bar)(5);\r\n```\r\n\r\nПри этом выражение `(bar)` может быть присвоено переменной – это указатель на функцию.\r\n\r\n```c++\r\nauto ptr1 = (bar);  // это создаёт функциональный объект (указатель)\r\nptr1(5); // это вызывает функцию\r\n```\r\n\r\n`(a.foo)` – это замыкание, реализованное средствами языка так, что время его жизни крайне короткое, не уверен, что это даже считается выражением. В работе [1] вводится термин _PMFC (pending member function call)_. Чтобы продлить время жизни этой конструкции, её нужно завернуть в лямбда-функцию.\r\n\r\n``` c++\r\nauto ptr2 = [&a](int x) { return (a.foo)(x); }\r\nptr2(5);\r\n```\r\n\r\nЧем больше обобщений требуется, тем больше шаблонов и `&&`-ов будет содержать лямбда. Многословность можно решить через препроцессор со всеми вытекающими проблемами:\r\n\r\n```c++\r\n#define CLOSURE(x) ([&]<typename ... Args>(Args&& ... args) { return (x)(std::forward<Args>(args)...); })\r\n\r\n// эквивалентный код:\r\n(a.foo)(5);\r\nCLOSURE(a.foo)(5);\r\n\r\n// можно разделить на две части:\r\nauto ptr3 = CLOSURE(a.foo);\r\nptr3(5);\r\n```\r\n\r\nПомимо общих проблем макросов, нужно учесть и специфику лямбд...\r\n```c++\r\nA* b;\r\nauto questionable = CLOSURE(b->foo);\r\n++b;\r\nquestionable(5); // наш макрос захватывает по ссылке и мы работаем с изменившимся указателем...\r\n```\r\n\r\nПочему бы тогда не задействовать неявный синтаксис, уже наполовину предоставляемый языком, и возложить создание подходящего функционального объекта на компилятор? Сравните с примером `ptr1` выше.\r\n\r\n``` c++\r\nauto ptr4 = (a.foo); // это создаёт функциональный объект \r\nptr4(5); // это вызывает функцию\r\n```\r\n\r\nДля этого в библиотеке нужен такой класс, либо лямбда:\r\n\r\n```c++\r\ntemplate<typename T, typename R, typename ... Args>\r\nclass std::call\r\n{\r\npublic:\r\n    constexpr std::call(T& ptr, R (T::*mem)(Args...)) : ptr(ptr), mem(mem) {}\r\n\r\n    R operator()(Args&& ... args) const\r\n    {\r\n        return (ptr.*mem)(std::forward<Args>(args)...);\r\n    }\r\n\r\nprivate:\r\n    T& ptr;\r\n    R (T::*const mem)(Args...);\r\n};\r\n```\r\n\r\nи способ научить компилятор перетащить аргументы операторов `.`, `->`, `.*`, `->*` в его/её конструктор:\r\n\r\n```c++\r\n/* (a.foo) */   std::call(a, &std::remove_cvref_t<decltype(a)>::foo);\r\n/* (a->foo) */  std::call(*(a.operator->()), &std::remove_cvref_t<decltype(*(a.operator->()))>::foo);\r\n/* (a.*ptr) */  std::call(a, ptr);\r\n/* (a->*ptr) */ std::call(*a, ptr); // если оператор не перегружен\r\n```\r\n\r\nВозможный вариант — парсить выражение в скобках как `std::pair`, и уже в таком виде подавать в `std::call` (либо отнаследовать его от `std::pair`).\r\n\r\n**Ссылки:**\r\n1. https://www.aristeia.com/Papers/DDJ_Oct_1999.pdf",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/530/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/530/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/529",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/529/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/529/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/529/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/529",
    "id": 1337747781,
    "node_id": "I_kwDOFK7cns5PvGlF",
    "number": 529,
    "title": "`operator->*` для типов стандартной библиотеки, имеющих `operator->`",
    "user": {
      "login": "pavelkryukov",
      "id": 11466405,
      "node_id": "MDQ6VXNlcjExNDY2NDA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11466405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pavelkryukov",
      "html_url": "https://github.com/pavelkryukov",
      "followers_url": "https://api.github.com/users/pavelkryukov/followers",
      "following_url": "https://api.github.com/users/pavelkryukov/following{/other_user}",
      "gists_url": "https://api.github.com/users/pavelkryukov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pavelkryukov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pavelkryukov/subscriptions",
      "organizations_url": "https://api.github.com/users/pavelkryukov/orgs",
      "repos_url": "https://api.github.com/users/pavelkryukov/repos",
      "events_url": "https://api.github.com/users/pavelkryukov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pavelkryukov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-08-12T22:16:59Z",
    "updated_at": "2022-08-16T20:53:26Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "**Предложение**\r\nОпределить `operator->*` для того, что в стандартной библиотеке умеет в `operator->`.\r\nНавскидку вспоминаю `unique_ptr`, `shared_ptr`, `optional`, итераторы.\r\n\r\n```c++\r\ntemplate<typename R>\r\nR& operator->*(R T::*member) const\r\n{\r\n    return this->operator->()->*member;\r\n}\r\n\r\ntemplate<typename R, typename ... Args>\r\nauto operator->*(R (T::*member)(Args...)) const\r\n{\r\n    return [ptr=this->operator->(), member](Args&& ... args) { return (ptr->*member)(std::forward(args)...); };\r\n}\r\n\r\ntemplate<typename R, typename ... Args>\r\nauto operator->*(R (T::*member)(Args...) const) const\r\n{\r\n    return [ptr=this->operator->(), member](Args&& ... args) { return (ptr->*member)(std::forward(args)...); };\r\n}\r\n```\r\n\r\nКак я догадываюсь, это не было сделано изначально из-за отсутствия лямбд и вариабельных шаблонов, без них решение весьма громоздко [1].\r\n\r\n**Область применения**\r\nЕсли к разным полям хранимой по smart-pointer/итераторам структуры применяются одни и те же алгоритмы, то хочется убрать повторяющийся код и использовать одну (мета-)функцию, принимающую `pointer-to-member` аргументом.\r\nСхожий пример с методами – мультиплицирующий адаптер [2]:\r\n\r\n```c++\r\nclass Interface\r\n{\r\npublic:\r\n    virtual void foo(int x) = 0;\r\n    virtual void bar(int y, int z) = 0;\r\n    // много других функций\r\n};\r\n\r\nclass Adapter : public Interface\r\n{\r\n    std::list<std::shared_ptr<Interface>> children;\r\n\r\npublic:\r\n    void foo(int x) override\r\n    {\r\n        for (auto& e : children)\r\n            e->foo(x);\r\n    }\r\n\r\n    void bar(int y, int z) override\r\n    {\r\n        for (auto& e : children)\r\n            e->bar(y, z);\r\n    }\r\n\r\n   // и так далее...\r\n};\r\n\r\n// то же, но немного проще:\r\nclass Adapter2 : public Interface\r\n{\r\n    std::list<std::shared_ptr<Interface>> children;\r\n\r\n    template<auto f, typename ... Args>\r\n    void adapt(Args&& ... args)\r\n    {\r\n         for (auto& e : children) {\r\n             //(e->*f)(std::forward<Args>(args)...); // ошибка компиляции!\r\n             (*e.*f)(std::forward<Args>(args)...); // а это работает\r\n         }\r\n    }\r\n\r\npublic:\r\n    void foo(int x) override { adapt<&Interface::foo>(x); }\r\n    void bar(int y, int z) override { adapt<&Interface::bar>(y, z); }\r\n    // и так далее, но уже в два раза меньше кода\r\n};\r\n```\r\n\r\nПрожить с `(*e.*f)` вместо `(e->*f)` можно, но хотелось бы полной симметрии с C-указателями.\r\n\r\n**Ссылки**\r\n1. Имплементация такой перегрузки в C++98 от Scott Meyers: https://www.aristeia.com/Papers/DDJ_Oct_1999.pdf\r\n1. Пример для `unique_ptr`: https://godbolt.org/z/oY6joezca\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/529/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/529/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/528",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/528/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/528/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/528/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/528",
    "id": 1324519620,
    "node_id": "I_kwDOFK7cns5O8pDE",
    "number": 528,
    "title": "Добавить проверку на выравнивание в std::start_lifetime_as",
    "user": {
      "login": "John-Jasper-Doe",
      "id": 20399224,
      "node_id": "MDQ6VXNlcjIwMzk5MjI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/20399224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/John-Jasper-Doe",
      "html_url": "https://github.com/John-Jasper-Doe",
      "followers_url": "https://api.github.com/users/John-Jasper-Doe/followers",
      "following_url": "https://api.github.com/users/John-Jasper-Doe/following{/other_user}",
      "gists_url": "https://api.github.com/users/John-Jasper-Doe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/John-Jasper-Doe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/John-Jasper-Doe/subscriptions",
      "organizations_url": "https://api.github.com/users/John-Jasper-Doe/orgs",
      "repos_url": "https://api.github.com/users/John-Jasper-Doe/repos",
      "events_url": "https://api.github.com/users/John-Jasper-Doe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/John-Jasper-Doe/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-08-01T14:28:40Z",
    "updated_at": "2023-02-23T09:54:45Z",
    "closed_at": "2023-02-23T09:54:37Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Хотелось иметь возможность получения ошибки/предупреждения на этапе компиляции если структура является выровненной, а реальный размер отличается и нет никаких `#pragm` и  `__attribute__`.\r\n\r\nНапример:\r\n```cpp\r\n// Case 1\r\nstruct ProtocolHeader {\r\n    unsigned char version;\r\n    unsigned char msg_type;\r\n    unsigned char chunks_count;\r\n};\r\n...\r\n// sizeof (ProtocolHeader) = 3;\r\nProtocolHeader hdr = std::start_lifetime_as<ProtocolHeader>(data_from_net.data()); // OK\r\n...\r\n\r\n// Case 2\r\nstruct ProtocolHeader2 {\r\n    unsigned int  id;    \r\n    unsigned char version;\r\n    unsigned char msg_type;\r\n    unsigned char chunks_count;\r\n};\r\n...\r\n// sizeof (ProtocolHeader2) = 8;\r\nProtocolHeader2 hdr = std::start_lifetime_as<ProtocolHeader2>(data_from_net.data()); // ERROR:  Структура выровнена sizeof (ProtocolHeader2) = 8, размер данных = 7 (или что-то в этом роде...)\r\n...\r\n\r\n// Case 3\r\nstruct ProtocolHeader3 {\r\n    unsigned int  id;    \r\n    unsigned char version;\r\n    unsigned char msg_type;\r\n    unsigned char chunks_count;\r\n} __attribute__ ((__packed__)); \r\n...\r\n// sizeof (ProtocolHeader3) = 7;\r\nProtocolHeader3 hdr = std::start_lifetime_as<ProtocolHeader3>(data_from_net.data()); // OK\r\n...\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/528/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/528/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/527",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/527/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/527/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/527/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/527",
    "id": 1322950314,
    "node_id": "I_kwDOFK7cns5O2p6q",
    "number": 527,
    "title": "добавить std::regex .empty()",
    "user": {
      "login": "marakew",
      "id": 3596295,
      "node_id": "MDQ6VXNlcjM1OTYyOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3596295?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marakew",
      "html_url": "https://github.com/marakew",
      "followers_url": "https://api.github.com/users/marakew/followers",
      "following_url": "https://api.github.com/users/marakew/following{/other_user}",
      "gists_url": "https://api.github.com/users/marakew/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marakew/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marakew/subscriptions",
      "organizations_url": "https://api.github.com/users/marakew/orgs",
      "repos_url": "https://api.github.com/users/marakew/repos",
      "events_url": "https://api.github.com/users/marakew/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marakew/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-07-30T09:47:58Z",
    "updated_at": "2022-08-03T10:24:10Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "пните комитет добавить метод empty в regex\r\nпроверка установлен ли regex через assign или через конструктор\r\n\r\nскопипастили весь бустовый, но самый главный метод забыли\r\nпри том что во всех трех gcc/clang/msvc имплементациях regex внутреннее представление соответствует  boost::regex\r\nгде машина состояний хранится в shared_ptr\r\n\r\nт.е. мини фикс будет приблизительно такой же как и имплементация в boost::regex\r\nпроверка этого shared_ptr на ноль\r\n\r\nbool empty() const { return !_nfa_state; } \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/527/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/527/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/526",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/526/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/526/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/526/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/526",
    "id": 1322248436,
    "node_id": "I_kwDOFK7cns5Oz-j0",
    "number": 526,
    "title": "добавить возможность использовать CTAD в контексте default member initializer",
    "user": {
      "login": "sigasigasiga",
      "id": 48245894,
      "node_id": "MDQ6VXNlcjQ4MjQ1ODk0",
      "avatar_url": "https://avatars.githubusercontent.com/u/48245894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sigasigasiga",
      "html_url": "https://github.com/sigasigasiga",
      "followers_url": "https://api.github.com/users/sigasigasiga/followers",
      "following_url": "https://api.github.com/users/sigasigasiga/following{/other_user}",
      "gists_url": "https://api.github.com/users/sigasigasiga/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sigasigasiga/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sigasigasiga/subscriptions",
      "organizations_url": "https://api.github.com/users/sigasigasiga/orgs",
      "repos_url": "https://api.github.com/users/sigasigasiga/repos",
      "events_url": "https://api.github.com/users/sigasigasiga/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sigasigasiga/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-07-29T13:22:57Z",
    "updated_at": "2022-07-29T13:23:17Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\n\r\nв C++17 была добавлена прекрасная фича -- class template argument deduction (CTAD), которая избавила нас от необходимости явно указывать шаблонные параметры у классов:\r\n\r\n```c++\r\nstd::pair<int, int> before_cpp17{0, 0};\r\nstd::pair after_cpp17{0, 0};\r\n```\r\n\r\nоднако по какой-то причине эта фича не работает, если использовать её в контексте default member initializer:\r\n\r\n```c++\r\nstruct foo_t\r\n{\r\n    std::pair m_{0, 0}; // clang: error: use of class template 'pair' requires template arguments; argument deduction not allowed in non-static struct member\r\n};\r\n```\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\n\r\nярче всего это изменение будет сиять при необходимости параметризации шаблона класса лямбдой:\r\n\r\n```c++\r\ntemplate<typename F>\r\nstruct function_holder_t\r\n{\r\n    F m_fun;\r\n};\r\n\r\ntemplate<typename F> function_holder_t(F&&) -> function_holder_t<F>;\r\n\r\nfunction_holder_t g_holder{ []{} }; // works just fine\r\n\r\nstruct foo_t\r\n{\r\n    function_holder_t</* what do we even write here? */> m_holder{ []{} };\r\n};\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/526/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/526/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/525",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/525/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/525/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/525/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/525",
    "id": 1319381858,
    "node_id": "I_kwDOFK7cns5OpCti",
    "number": 525,
    "title": "Добавить в switch последовательных case-ов",
    "user": {
      "login": "kov-serg",
      "id": 5946122,
      "node_id": "MDQ6VXNlcjU5NDYxMjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5946122?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kov-serg",
      "html_url": "https://github.com/kov-serg",
      "followers_url": "https://api.github.com/users/kov-serg/followers",
      "following_url": "https://api.github.com/users/kov-serg/following{/other_user}",
      "gists_url": "https://api.github.com/users/kov-serg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kov-serg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kov-serg/subscriptions",
      "organizations_url": "https://api.github.com/users/kov-serg/orgs",
      "repos_url": "https://api.github.com/users/kov-serg/repos",
      "events_url": "https://api.github.com/users/kov-serg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kov-serg/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 20,
    "created_at": "2022-07-27T10:55:28Z",
    "updated_at": "2022-11-04T09:47:53Z",
    "closed_at": "2022-11-04T09:47:53Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Добавить в switch возможность авто увеличения case-ов как у enum-ов\r\n\r\nПримеры:\r\n```\r\nint A::step() {\r\n  switch(this->state++) {\r\n    default: return 0;\r\n    next_case: fn1(); break;\r\n    next_case: fn2(); break;\r\n    next_case: fn3(); break;\r\n    // ...\r\n    next_case: fnN(); break;\r\n  }\r\n  return 1;\r\n}\r\n```\r\nЧто бы не писать индексы явно:\r\n```\r\nint A::step() {\r\n  switch(this->state++) {\r\n    default: return 0;\r\n    case 0: fn1(); break;\r\n    case 1: fn2(); break;\r\n    case 2: fn3(); break;\r\n    // ...\r\n    case N: fnN(); break;\r\n  }\r\n  return 1;\r\n}\r\n```\r\nТак в случае вставки, удаления или перестановки последовательности шагов не надо будет вручную менять индексы. Плюс реализация тривиальна.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/525/reactions",
      "total_count": 10,
      "+1": 1,
      "-1": 2,
      "laugh": 0,
      "hooray": 0,
      "confused": 7,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/525/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/524",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/524/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/524/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/524/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/524",
    "id": 1317855652,
    "node_id": "I_kwDOFK7cns5OjOGk",
    "number": 524,
    "title": "backport import std to C++20",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-07-26T08:03:34Z",
    "updated_at": "2023-02-23T09:36:25Z",
    "closed_at": "2023-02-23T09:36:24Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В С++20 уже есть модули и import std использует обычный модуль без доработок из С++20, поэтому нет никаких препятствий использовать import std уже в С++20\r\nЭто позволит гораздо быстрее и легче переходить на модули старым проектам и конечно же ускорит компиляцию уже сейчас, а не через 5 лет\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/524/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/524/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/523",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/523/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/523/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/523/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/523",
    "id": 1302064944,
    "node_id": "I_kwDOFK7cns5Nm-8w",
    "number": 523,
    "title": "Пора уже... std::null",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-07-12T13:27:34Z",
    "updated_at": "2022-09-26T01:53:15Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Кажется в С++ нарастает количество типов которые... ну как бы \"ничего\"\r\nС++11 `std::nullptr_t` / `nullptr`\r\nC++17 `std::nullopt_t` / `std::nullopt`\r\nalso C++17 `std::monostate` (тоже обозначает \"ничего\" и умеет сравниваться)\r\nВажно отметить ещё `std::npos` `std::string::npos` и прочее, что на практике является обозначением \"ничего\" для `size_t`\r\nТеоретически был бы выгоден ещё `std::nullany`(для `std::any`), но видимо решили не вводить.\r\nХотят добавить линейную алгебру, там неизбежно появится какой то нуллгеомобъект типа точки (-inf;-inf).\r\nКороче кажется постепенно этих штук становится слишком много\r\nТак что я предлагаю универсальное решение этих проблем + задел на будущее\r\n`std::null_t` тип и значение `std::null`\r\nРеализация:\r\n```C++\r\n\r\n  template <typename T, typename... Ts>\r\n  concept one_of = (std::same_as<T, Ts> || ...);\r\n\r\n  struct null_t {\r\n    // breakes compilation for every other type(such as void*, if it was operators nullptr_t)\r\n    template <one_of<std::nullptr_t, std::nullopt_t, std::monostate> T>\r\n    consteval operator T() const noexcept {\r\n      return {};\r\n    }\r\n  };\r\n\r\n  constexpr inline null_t null = {};\r\n\r\n```\r\nК тому же это может стать заменой void для описания возвращения ничего из функции, например для уменьшения количества магии на квадратный метр, чтобы добавить в шаблонном коде к некому T ссылку/создать значение типа\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/523/reactions",
      "total_count": 14,
      "+1": 14,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/523/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/522",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/522/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/522/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/522/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/522",
    "id": 1275792509,
    "node_id": "I_kwDOFK7cns5MCwx9",
    "number": 522,
    "title": "Добавить в язык подержку nullability",
    "user": {
      "login": "klappdev",
      "id": 40568872,
      "node_id": "MDQ6VXNlcjQwNTY4ODcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/40568872?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/klappdev",
      "html_url": "https://github.com/klappdev",
      "followers_url": "https://api.github.com/users/klappdev/followers",
      "following_url": "https://api.github.com/users/klappdev/following{/other_user}",
      "gists_url": "https://api.github.com/users/klappdev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/klappdev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/klappdev/subscriptions",
      "organizations_url": "https://api.github.com/users/klappdev/orgs",
      "repos_url": "https://api.github.com/users/klappdev/repos",
      "events_url": "https://api.github.com/users/klappdev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/klappdev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-06-18T13:36:58Z",
    "updated_at": "2023-06-17T05:33:00Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Неотъемлемой частью языка являются указатели.\r\nИспользование указателей несет некоторые проблемы, в частности: разименование нулевого указателя, работа с нулевым указателями ссылающиеся на поля объекта, и т.д.\r\nКак результат имеем segmentation fault, и долгие часы дебага.\r\n\r\n```C++\r\n   int* ptr = nullptr;\r\n   int a = *ptr;                      //  segmentation fault\r\n```\r\nПоэтому всегда нужно проверять, является указатель нулевым или нет. \r\n\r\nЧасто программисты из-за невнимательности или сложной логики кода, могут не все случаи проверить валидности указателей.\r\nКак замена указателям в С++, имеются ссылки, умные указатели.\r\nНо иногда без указателей не обойтись, например использование С-библиотек, new/delete и т.д.\r\n\r\nВ Clang попытались решить проблему с указателями, добавив ключевые слова **_Nonnull, _Nullable**. \r\nАтрибуты nullability позволяют статическому анализатору подсказывать, где указатель используется некорректно.\r\n\r\n```C++\r\nint function(_Nonnull int* ptr) {\r\n     int a = *ptr;                        // warning\r\n}\r\n```\r\n\r\n\r\nНо что если в проекте не используется статический анализатор кода, или Clang компилятор. То потенциальные ошибки останутся в коде. Что не очень хорошо.\r\n\r\nЕще одним решение является реализовать оберточки над указателя - **non_null, nullable**. Если указатель, в какой-то момент не валидный, то можно бросить исключения. И в нас уже есть замечательная библиотека **gsl**. \r\n```C++\r\nint function(gsl::non_null<int*> ptr) {\r\n     int a = *ptr;                        // throw exception\r\n}\r\n```\r\nНо почему в библитеке нет gsl::nullable. И еще как минус нельзя расширить обработчик ошибок.\r\nНапример, если в проекте используется Java/C++, то хотелось кидать java-исключения с нативным стектрейсом.\r\nhttps://github.com/klappdev/firearrow/blob/master/app/src/main/cpp/util/nullability/NonNull.hpp\r\nhttps://github.com/klappdev/firearrow/blob/master/app/src/main/cpp/util/nullability/Nullable.hpp\r\n\r\nПредлагаю добавить два класса в стандартную библиотеку - **std::non_null<T*>**, **std::nullable<T*>**. Если указатель, в какой-то момент не валидный, то можно бросить исключения. \r\n\r\n```C++\r\nint function(std::non_null<int*> ptr) {\r\n     int a = *ptr;                        // throw exception\r\n}\r\n\r\nint function(std::nullable<int*> ptr) {\r\n    if (ptr != nullptr) { \r\n         int a = *ptr;                        // ok\r\n    }\r\n}\r\n```\r\nТакже добавить функцию std::set_nullability(). Для того, чтобы можно переопределить дефолтное поведения.\r\nПо аналогии с функцией - std::terminate.\r\n\r\nОчень хочется видеть подобные оберточки в С++.\r\n\r\nПолезные ссылки:\r\n* https://github.com/microsoft/GSL/blob/main/include/gsl/pointers\r\n* https://clang.llvm.org/docs/AttributeReference.html#nonnull\r\n* https://github.com/klappdev/firearrow/blob/master/app/src/main/cpp/util/nullability\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/522/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/522/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/521",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/521/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/521/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/521/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/521",
    "id": 1268237139,
    "node_id": "I_kwDOFK7cns5Ll8NT",
    "number": 521,
    "title": "Добавить свойства в C++",
    "user": {
      "login": "klappdev",
      "id": 40568872,
      "node_id": "MDQ6VXNlcjQwNTY4ODcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/40568872?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/klappdev",
      "html_url": "https://github.com/klappdev",
      "followers_url": "https://api.github.com/users/klappdev/followers",
      "following_url": "https://api.github.com/users/klappdev/following{/other_user}",
      "gists_url": "https://api.github.com/users/klappdev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/klappdev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/klappdev/subscriptions",
      "organizations_url": "https://api.github.com/users/klappdev/orgs",
      "repos_url": "https://api.github.com/users/klappdev/repos",
      "events_url": "https://api.github.com/users/klappdev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/klappdev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2022-06-11T11:09:07Z",
    "updated_at": "2022-08-01T15:10:35Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "При работе с классами, хорошей практикой, является объявление полей закрытыми. Для чтения значения полей из вне, в классе объявляют геттеры. А для записи объявляют сеттеры.\r\n\r\nВозьмём для примера класс QPoint с фреймворка Qt.\r\n```C++\r\nclass QPoint {\r\npublic:\r\n    // construct, dectructor, other\r\n    inline int x() const { return xp; }\r\n    inline int y() const { return yp; }\r\n    inline void setX(int x) { this.xp = x; }\r\n    inline void setY(int y) { this.yp = y; } \r\n  \r\nprivate:\r\n   int xp;\r\n   int yp;\r\n};\r\n```\r\nhttps://code.woboq.org/qt5/qtbase/src/corelib/tools/qpoint.h.html\r\n\r\nПри этом в большинстве случаев, геттеры и сеттеры очень простые. И не хочется писать руками.\r\n\r\nДля того, чтобы каждый раз не писать геттеры, сеттеры, ничего не мешает реализовать оберточки. \r\n```C++\r\ntemplate<typename T>\r\nclass Property {\r\npublic:\r\n    constexpr explicit Property(const T& value) : value(value) {}\r\n\r\n    constexpr Property& operator=(const T& newValue) {\r\n        this->value = newValue;\r\n        return *this;\r\n    }\r\n\r\n    constexpr operator const T&() const { return value; }\r\nprivate:\r\n    T value;\r\n};\r\n\r\nclass QPoint {\r\npublic:\r\n    // construct, dectructor, other\r\n   \r\n   Property<int> x;\r\n   Property<int> y;\r\n};\r\n```\r\nhttps://github.com/klappdev/firearrow/blob/master/app/src/main/cpp/util/property/Property.hpp\r\nhttps://github.com/klappdev/firearrow/blob/master/app/src/main/cpp/util/property/Getter.hpp\r\nhttps://github.com/klappdev/firearrow/blob/master/app/src/main/cpp/util/property/Setter.hpp\r\n\r\nКонцепция свойств(геттеров, сеттеров) существует во многих языках, таких например как Swift, Kotlin, C# и д.р., \r\nна уровне языка.\r\nХочется что б в С++ завезли такую возможность на уровне языка. Например, это могло выглядить как в С#.\r\n\r\n```C++\r\nclass QPoint {\r\npublic:\r\n    // construct, dectructor, other\r\nprivate:  \r\n   int x { set; get; }; \r\n   int y { set; get; };\r\n};\r\n```\r\nПредлагаю добавить два контекстных ключевых слова - **set, get**. Которые были бы ключевыми словами, только при объявлении поля класса.\r\nПо аналогии с обычными методам, можно бы объявлять с разными квалификаторами - &, &&, const, volatile, noexcept.\r\nВ случае если нужно не тривиальный геттер, сеттер, то код мог бы выглядеть следующим образом. \r\n```C++\r\nclass QPoint {\r\npublic:\r\n    // construct, dectructor, other\r\nprivate:  \r\n   int x { \r\n      set(int value) {\r\n          std::cout << \"invoke setter - x\" << std::endl; \r\n          this->x = value;\r\n      }; \r\n      get() const {\r\n          std::cout << \"invoke getter - x\" << std::endl; \r\n          return x;\r\n      }; \r\n   }; \r\n   int y { set; get; };\r\n};\r\n```\r\nПод капотом, компилятор генерировал те самые методы геттеры, сеттеры. \r\nСовременный С++ вносит много новых фич, которые позволяет писать меньше шаблонного кода.\r\nКонцепция свойств(геттеров, сеттеров) как раз позволяет писать меньше кода, и при этом код остается таким же читаемым.\r\nОчень хочется видеть в С++.\r\n\r\nПолезные ссылки:\r\n* https://docs.microsoft.com/ru-ru/dotnet/csharp/properties\r\n* https://kotlinlang.org/docs/properties.html\r\n* https://docs.swift.org/swift-book/LanguageGuide/Properties.html\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/521/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/521/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/520",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/520/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/520/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/520/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/520",
    "id": 1267431195,
    "node_id": "I_kwDOFK7cns5Li3cb",
    "number": 520,
    "title": "Сделать break N/ continue N для выхода из/продолжения внешних циклов.",
    "user": {
      "login": "topin89",
      "id": 25770107,
      "node_id": "MDQ6VXNlcjI1NzcwMTA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/25770107?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/topin89",
      "html_url": "https://github.com/topin89",
      "followers_url": "https://api.github.com/users/topin89/followers",
      "following_url": "https://api.github.com/users/topin89/following{/other_user}",
      "gists_url": "https://api.github.com/users/topin89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/topin89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/topin89/subscriptions",
      "organizations_url": "https://api.github.com/users/topin89/orgs",
      "repos_url": "https://api.github.com/users/topin89/repos",
      "events_url": "https://api.github.com/users/topin89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/topin89/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-06-10T11:41:26Z",
    "updated_at": "2022-06-15T21:02:49Z",
    "closed_at": "2022-06-15T21:02:48Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Тема выхода/продолжения из внешних циклов довольно древняя, и разные языки решали её по разному. В C/C++ её чаще всего решают через `goto`\r\n\r\n```c++\r\nfor(int x=0; x < width; ++x){\r\n    for(int y=0; x < heigh; ++y){\r\n        if(img[x][y] != 0 ){\r\n            goto img_processed;\r\n        }\r\n    }\r\n}\r\nimg_processed:\r\n\r\nfor(int x=0; x < width; ++x){\r\n    for(int y=0; x < heigh; ++y){\r\n        if(img2[x][y] != 0 ){goto column_processed;}\r\n    }\r\ncolumn_processed:\r\n}\r\n```\r\n\r\nА также вынося вложенные циклы в отдельную функцию/лямбду и делая `return` для выхода из вложенных циклов. Основная проблема с `goto` даже не с читаемостью, а с тем, что можно легко забыть про метки наружу цикла и сами метки должны быть уникальными, что неудобно при копипасте (вопрос о пользе и вреде копипасты не рассматриваем).\r\n\r\nВ других языках не лучше, где-то это специальные метки для `break`, как в Java или `break varname` в Visual Basic. Где-то просто никак, например в Python.\r\n\r\nИ есть баш.\r\n\r\n```bash\r\nfor folder in folder1 folder2 folder3; do\r\n    for file in $folder/*; do\r\n        if  [ -c $file ]; then\r\n            echo \"found char device $file\"\r\n            break 2  # <---\r\n        fi\r\n    done\r\ndone\r\n```\r\n\r\nАбсолютно простое решение проблемы. Хотим указать, что нам выйти из двух вложенных циклов -- берём и указываем. Заодно решается вопрос, как выйти из цикла внутри `switch`. \r\n\r\nВ нашем случае это выглядело бы так:\r\n\r\n```c++\r\nfor(int x=0; x < width; ++x){\r\n    for(int y=0; x < heigh; ++y){\r\n        if(img[x][y] != 0 ){\r\n            break 2;\r\n        }\r\n    }\r\n}\r\n\r\nfor(int x=0; x < width; ++x){\r\n    for(int y=0; x < heigh; ++y){\r\n        if(img2[x][y] != 0 ){continue 2;}\r\n    }\r\n}\r\n```\r\n\r\nПримеров применения множество. Выход из циклов внутри `switch`. Выход из while, в котором мы ждём прихода массива и если нужный элемент найден покидаем ожидание. Если вбить в гугле `c++ outer loop break`, найдётся 31 миллион результатов. 4 миллиона в Яндексе.\r\n\r\nПри этом по стандарту после break и continue не может быть никаких символов кроме `;` и пробелов, шансов нарушить обратную совместимость очень мало",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/520/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/520/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/519",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/519/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/519/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/519/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/519",
    "id": 1247049429,
    "node_id": "I_kwDOFK7cns5KVHbV",
    "number": 519,
    "title": "std::noncopyable",
    "user": {
      "login": "Izaron",
      "id": 5406399,
      "node_id": "MDQ6VXNlcjU0MDYzOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5406399?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Izaron",
      "html_url": "https://github.com/Izaron",
      "followers_url": "https://api.github.com/users/Izaron/followers",
      "following_url": "https://api.github.com/users/Izaron/following{/other_user}",
      "gists_url": "https://api.github.com/users/Izaron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Izaron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Izaron/subscriptions",
      "organizations_url": "https://api.github.com/users/Izaron/orgs",
      "repos_url": "https://api.github.com/users/Izaron/repos",
      "events_url": "https://api.github.com/users/Izaron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Izaron/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-05-24T19:46:04Z",
    "updated_at": "2022-06-18T12:45:52Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Надоело копипастить это в каждый свой проект, хочется стандартизировать `std::noncopyable`\r\n\r\nЗа эталон можно взять non copyable из CatBoost - https://github.com/catboost/catboost/blob/master/util/generic/noncopyable.h (можно еще `std::move_only`)\r\n\r\nЕсть еще `boost::noncopyable` - https://github.com/boostorg/core/blob/develop/include/boost/core/noncopyable.hpp\r\n\r\nПоискал, вроде такое еще не предлагали (???) - https://github.com/cplusplus/papers/issues?q=is%3Aissue+is%3Aopen+noncopyable+",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/519/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/519/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/518",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/518/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/518/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/518/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/518",
    "id": 1237253492,
    "node_id": "I_kwDOFK7cns5Jvv10",
    "number": 518,
    "title": "атрибут заменяющий реализацию benchmark::DoNotOptimize(..)",
    "user": {
      "login": "gleb-kov",
      "id": 41119563,
      "node_id": "MDQ6VXNlcjQxMTE5NTYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/41119563?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gleb-kov",
      "html_url": "https://github.com/gleb-kov",
      "followers_url": "https://api.github.com/users/gleb-kov/followers",
      "following_url": "https://api.github.com/users/gleb-kov/following{/other_user}",
      "gists_url": "https://api.github.com/users/gleb-kov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gleb-kov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gleb-kov/subscriptions",
      "organizations_url": "https://api.github.com/users/gleb-kov/orgs",
      "repos_url": "https://api.github.com/users/gleb-kov/repos",
      "events_url": "https://api.github.com/users/gleb-kov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gleb-kov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-05-16T14:32:29Z",
    "updated_at": "2022-05-16T14:32:29Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nДля бенчмаркинга используют функции clobber и escape (https://youtu.be/nXaxk27zwlk?t=2441). В актуальном google benchmark это функции Clobber и DoNotOptimize. Если Clobber получил адекватную реализацию с с++11 через atomic_signal_fence, то DoNotOptimize все еще остается compiler-specific asm кодом.\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\n - Стандартизированный способ, который можно использовать в бенчмарках. Сейчас есть несколько способов реализовать эту функцию.\r\n - Хочется форсировать \"грязные вычисления\" для сайд эффектов, но результат выражения бесполезен\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\n- Здесь https://github.com/google/benchmark/commit/7b03df7ff76844a39359e9233f31ca8cdb073313 то как поменялась реализация этой функции несколько лет назад\r\n- https://github.com/catboost/catboost/blob/master/util/system/compiler.h#L660\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/518/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/518/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/517",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/517/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/517/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/517/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/517",
    "id": 1213297940,
    "node_id": "I_kwDOFK7cns5IUXUU",
    "number": 517,
    "title": "std::lifetime",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-04-23T13:18:30Z",
    "updated_at": "2022-04-23T19:56:39Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В С++ возникла проблема отслеживания лайфтаймов и особенно сильно она проявляется в корутинах, где недостаточно умный компилятор не может оптимизировать аллокацию.\r\nМоя идея поможет с этими проблемами и вроде довольно изящно.\r\nСуть:\r\nПредставим, что корутина по ссылке захватила в себя объект из скоупа, где создана, а в конце корутины обращается по этой ссылке и вызывает скажем метод.\r\nЕсли эта ссылка висячая, то это уб, значит этого не может быть, а значит корутина гарантированно переживает переменную по ссылке(если это валидный код). А значит можно не аллоцировать память для этой корутины и сделать её на стеке.\r\nГрубо говоря:\r\n```C++\r\n// корутина\r\n  task Foo(lifetime_t& life) {\r\n  scope_exit { life.end() };\r\n/// ...\r\n  co_return;\r\n}\r\n\r\nvoid Bar () {\r\n  lifetime_t life;\r\n  Foo(life);\r\n}\r\n```\r\nТеперь можно добавить к этому немного поддержки стандартной библиотеки\r\n\r\n```C++\r\nconsteval auto std::current_scope() noexcept -> std::lifetime_t;\r\n\r\nstruct life {\r\n  [[no_unique_address]] std::lifetime_t& lifetime; // некая компиляторная магия позволяющая ссылке тут быть пустой\r\n  ~life() {\r\n    std::die(lifetime);\r\n  }\r\n};\r\n```\r\nstd::current_scope действует по аналогии с std::current_location() только на компиляции. Возвращает уникальное значение типа std:::lifetime_t, которое умеет сравниваться(чтобы быть использованным в качестве шаблонного параметра)\r\nТогда представим реализацию функции-корутины, возвращающей std::generator, который точно знает что всегда может быть на стеке\r\nИ специальный std::life, который является пустой обёрткой(не занимающей памяти) над std::lifetime_t, которая в деструкторе обращается по ссылке к объекту типа std::lifetime_t\r\n```C++\r\nstd::generator<int> Foo(std::life = std::current_scope()) {\r\n  co_yield 5;\r\n// в конце вызывается деструктор life, а если корутина\r\n// пережила скоуп, то это уб(обращение по невалидной ссылке), а значит аллоцировать не нужно\r\n  co_return; \r\n}\r\n```\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/517/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/517/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/516",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/516/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/516/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/516/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/516",
    "id": 1207199779,
    "node_id": "I_kwDOFK7cns5H9Ggj",
    "number": 516,
    "title": "magic_get для структур",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-04-18T16:12:14Z",
    "updated_at": "2022-08-11T17:47:18Z",
    "closed_at": "2022-08-11T17:47:05Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Недавно в стандарт был добавлен structured binding.\r\n\r\nПо умолчанию, мы можем биндить поля структур без дополнительного кода.\r\n\r\nТак же мы можем переопределить поведение по-умолчанию реализовав tuple-like интерфейс для класса или для структуры.\r\n\r\nДосадно, что мы не можем воспользоваться tuple интерфейсом, который компилятор уже делает для нас. Предлагаю сделать  доступным автосгенерированный tuple интерфейс.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/516/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/516/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/515",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/515/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/515/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/515/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/515",
    "id": 1190737100,
    "node_id": "I_kwDOFK7cns5G-TTM",
    "number": 515,
    "title": "Добавить тернарный оператор целочисленного деления",
    "user": {
      "login": "exldna",
      "id": 73162077,
      "node_id": "MDQ6VXNlcjczMTYyMDc3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73162077?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/exldna",
      "html_url": "https://github.com/exldna",
      "followers_url": "https://api.github.com/users/exldna/followers",
      "following_url": "https://api.github.com/users/exldna/following{/other_user}",
      "gists_url": "https://api.github.com/users/exldna/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/exldna/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/exldna/subscriptions",
      "organizations_url": "https://api.github.com/users/exldna/orgs",
      "repos_url": "https://api.github.com/users/exldna/repos",
      "events_url": "https://api.github.com/users/exldna/events{/privacy}",
      "received_events_url": "https://api.github.com/users/exldna/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2022-04-02T20:54:21Z",
    "updated_at": "2022-04-03T09:36:50Z",
    "closed_at": "2022-04-03T08:42:52Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Довольно часто при делении целых чисел надо получить не только их частное, но и остаток деления. \r\nПриходится писать что-то вроде:\r\n\r\n    // . . .\r\n    int x = a / b;\r\n    int y = a % b;\r\n    //  . . .\r\n\r\nПроцессоры i386+ находят оба значения за одну (довольно сложную, дорогостоящую) инструкцию, но у компиляторов не всегда есть все необходимые данные для разбора таких случаев.  В результате может сгенерироваться примерно следующий код:\r\n\r\n    ; Оптимизирующий компилятор Microsoft (R) C/C++ версии 19.31.31105 для x86 с флагами /EHs /O2\r\n    ; . . .\r\n    mov\teax, ecx\r\n    cdq\r\n    idiv\tesi\r\n    mov\tBYTE PTR _buf$[esp+12], al\r\n\r\n    mov\teax, ecx\r\n    cdq\r\n    idiv\tesi\r\n    mov\tBYTE PTR _buf$[esp+13], dl\r\n    ; . . .\r\n\r\nПроцессор дважды считает одну инструкцию, а программисты пишут две почти одинаковых строчки кода. \r\nОбе проблемы можно решить добавлением нового тернарного оператора. Вот пример возможного синтаксиса:\r\n\r\n    int  y, x = a / b : y;\r\n\r\nЭто позволит нам писать более простой и понятный код, а компиляторам - быть немного оптимальней.\r\n\r\nисходный код примера:\r\n\r\n    # include <Windows.h>\r\n\r\n    int main() {\r\n        int* a = new int{10};\r\n        int* b = new int{3};\r\n\r\n        int c = *a / *b;\r\n        int d = *a % *b;\r\n\r\n        char buf[2];\r\n        buf[0] = '0' + c;\r\n        buf[1] = '0' + d;\r\n    \r\n        HANDLE stdout = GetStdHandle(STD_OUTPUT_HANDLE);\r\n        WriteConsole(stdout, buf, 2, nullptr, NULL);\r\n    }\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/515/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/515/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/514",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/514/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/514/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/514/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/514",
    "id": 1178419440,
    "node_id": "I_kwDOFK7cns5GPUDw",
    "number": 514,
    "title": "Недостающий инструмент динамического полиморфизма в стандарте",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-03-23T17:15:07Z",
    "updated_at": "2022-03-23T17:37:13Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Мотивация частично описана тут:\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0957r6.pdf\r\nИ тут :\r\nhttps://github.com/kelbon/AnyAny\r\nЕсли очень кратко - текущие инструменты динамического полиморфизма недостаточны : \r\nвиртуальные функции и код, который с ними получается, не отражает реальных намерений программиста (бесконечные поинтеры, управление памятью, наследование и проч.), \r\nstd::any практически бесполезен (единственная его польза это деструктор, то есть гарантия что что-то удалится). \r\nstd::variant уже гораздо лучше, но неудобен в использовании, плохо расширяем(если добавляется новый тип приходится менять все места его использования), когда типов много визиторы в реальном коде становятся громадными, большие проблемы с исключениями(valueless_by_exception), а если написать std::visit с двумя визиторами можно раздуть бинарник до гигабайтов(что мягко говоря неочевидно для новичков да и опытных...)\r\n\r\nМоё предложение заполняет нишу, где variant плох, а виртуальные функции ужасны. Там, где реально нужен полиморфный **объект**\r\n\r\nПредставим что нужен класс машины, где есть двигатель и его можно менять на рантайме.\r\nКажется наилучшее выражение мысли в коде это\r\n```C++\r\nstruct Machine {\r\n  any_engine engine_;\r\n};\r\n```\r\nИ с моим предложением реализация выглядит так:\r\n\r\n```C++\r\ntemplate<typename T>\r\nstruct Go {\r\n  static int do_invoke(T self, int value) {\r\n   self.Go(value);\r\n   return value * 4;\r\n  }\r\n}\r\n\r\nusing any_engine = any_with<Go>; // здесь может передаваться произвольное количество методов\r\n```\r\nВызывать методы можно либо через invoke\\<Go\\>(engine); либо написав в классе метод (и тогда будет выглядеть как обычный класс), см. реализацию и readme.\r\nНа мой личный взгляд интерфейс гораздо удобнее чем у предлагаемого std::proxy, при этом у меня есть строгая гарантия исключений(которой нет в std::proxy) и value семантика, реализация судя по бенчмаркам практически такая же по производительности как и variant\r\nАллокатор и размер SOO буфера регулируемы, можно добавлять любое количество методов, реализовывать передачу self по копии(кстати выше в примере с машиной так и происходит) и многое другое\r\n\r\nРеализация тут:\r\n\r\nhttps://github.com/kelbon/AnyAny\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/514/reactions",
      "total_count": 4,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/514/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/513",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/513/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/513/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/513/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/513",
    "id": 1153238355,
    "node_id": "I_kwDOFK7cns5EvQVT",
    "number": 513,
    "title": "Новые математические функции: std::sincos, std::invsqrt, std::rem.",
    "user": {
      "login": "jin-x",
      "id": 16954379,
      "node_id": "MDQ6VXNlcjE2OTU0Mzc5",
      "avatar_url": "https://avatars.githubusercontent.com/u/16954379?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jin-x",
      "html_url": "https://github.com/jin-x",
      "followers_url": "https://api.github.com/users/jin-x/followers",
      "following_url": "https://api.github.com/users/jin-x/following{/other_user}",
      "gists_url": "https://api.github.com/users/jin-x/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jin-x/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jin-x/subscriptions",
      "organizations_url": "https://api.github.com/users/jin-x/orgs",
      "repos_url": "https://api.github.com/users/jin-x/repos",
      "events_url": "https://api.github.com/users/jin-x/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jin-x/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-02-27T12:47:12Z",
    "updated_at": "2023-03-25T10:30:13Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Предлагаю добавить несколько математических функций:\r\n\r\n• `void std::sincos(double arg, double& sin, double& cos)`, `std::sincos_t std::sincos(double arg)`, `struct sincos_t { double sin, cos; }` (а также sincosf, sincosl) — вычисление синуса и косинуса одной операцией, поскольку зачастую это можно реализовать более быстрым способом, чем последовательное вычисление sin и cos (аналогично как std::div позволяет получить сразу и частное, и остаток). Также будет полезно добавить функции `std::apsin`, `std::apcos`, `std::apsincos`, `std::aptan`, `std::apatan` и `std::apatan2` для приблизительного вычисления синуса, косинуса, тангенса и арктангенса (во многих случаях точность не так важна, а кол-во итераций при использовании рядов Маклорена, используемых для вычисления тригонометрических функций в SIMD, можно уменьшить).\r\n\r\n• `double std::invsqrt(double arg)` (а также invsqrtf, invsqrtl... или `std::arsqrt` от слов \"approximate reciprocal square root\") — приблизительное вычисление обратного квадратного корня (например, в x86 / x86-64 реализуется через SIMD гораздо быстрее, чем вычисление квадратного корня и деления).\r\n\r\n• `double std::rem(double x, double y)` (а также remf, reml) — остаток от деления со знаком делителя (подобное реализовано во многих языках программирования, однако отсутствует в C++).\r\n\r\n \r\n_Примеров применения масса: **работа с векторами, графика** и пр._\r\n \r\n\r\nТесты `sincos`: https://quick-bench.com/q/4eUkcNZ70coSAcrXZTgruclN7Yw (в SIMD одновременное вычисление может быть осуществлено в 2 раза быстрее, чем последовательное, с использованием 2-х ячеек одного регистра: одной для синуса, другой для косинуса).\r\n\r\nТесты `invsqrt`: https://quick-bench.com/q/8_wm4EZ8VLkoQI2hwYPmKd7QDis.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/513/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/513/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/512",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/512/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/512/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/512/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/512",
    "id": 1145791827,
    "node_id": "I_kwDOFK7cns5ES2VT",
    "number": 512,
    "title": "enum_cast<>",
    "user": {
      "login": "Uriev",
      "id": 100137073,
      "node_id": "U_kgDOBff4cQ",
      "avatar_url": "https://avatars.githubusercontent.com/u/100137073?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Uriev",
      "html_url": "https://github.com/Uriev",
      "followers_url": "https://api.github.com/users/Uriev/followers",
      "following_url": "https://api.github.com/users/Uriev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Uriev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Uriev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Uriev/subscriptions",
      "organizations_url": "https://api.github.com/users/Uriev/orgs",
      "repos_url": "https://api.github.com/users/Uriev/repos",
      "events_url": "https://api.github.com/users/Uriev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Uriev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-02-21T13:19:38Z",
    "updated_at": "2022-02-21T13:19:38Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "This conversion verifies incoming integer value against enum or enum class.\r\nPurpose: Type-safe deserialization.\r\n\r\nIf we had an enum type, that implements some external specification, we would perform a complicated verification at the deserialization stage. There is no guarantee, that all enum values are consecutive, so only one overflow/underflow check + static_cast<> may be insufficient.\r\n\r\nLet's take a look at an example:\r\nenum stdcmd\r\n{\r\n run=0x10,\r\n rerun=0x11,\r\n stop=0x20,\r\n// more values here\r\n dbgcn=0xF1,\r\n dbgdm=0xF2,\r\n};\r\nHere we should use switch-case deserialization or several overflow/underflow checking. Both implementations are clumsy and fragile (if the enum is changeable).\r\n\r\nTherefore enum_cast simplifies the verification:\r\n1. During compile time it checks, if all enum's values are unique,\r\n2. At runtime it verifies, an incoming integer corresponds to the correct enum value, throwing std::bad_cast overwise.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/512/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/512/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/511",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/511/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/511/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/511/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/511",
    "id": 1134193485,
    "node_id": "I_kwDOFK7cns5DmmtN",
    "number": 511,
    "title": "Общий интерефейс компайл тайм sized контейнеров",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-02-12T15:38:23Z",
    "updated_at": "2022-02-19T10:42:56Z",
    "closed_at": "2022-02-19T10:42:56Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "\r\nВ стародавние времена по неизвестной никому причине у `std::array` метод size не сделали `static`. Что конечно ломает ожидания человека, который логически предполагает, что узнать размер массива можно и без объекта такого массива( особенно в шаблонном коде )\r\nДля std:;array есть кривое решение - специализация `std::tuple_size_v`. А вот для std::span и метод `size` не `static` и специализации `tuple_size_v` нет. Зато есть какой то бесполезный `static constexpr size_t extent;`\r\nПредлагаю депрекейтнуть этот extent нахрен, добавить специализацию `tuple_size_v` для `std::span<T, I>` и \"удалённую\" специализацию для `std::span<T, std::dynamic_extent>;`\r\nДобавление static не предлагаю т.к. разоруться представители ABI,\r\nПолучим общий интерфейс для похожих вещей, оправдаются ожидания новичков, которые думают что можно без объекта класса у которого размер записан в типе получить его размер(без заморочек)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/511/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/511/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/510",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/510/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/510/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/510/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/510",
    "id": 1130405689,
    "node_id": "I_kwDOFK7cns5DYJ85",
    "number": 510,
    "title": "Сборщик мусора",
    "user": {
      "login": "Andreyproger",
      "id": 3163176,
      "node_id": "MDQ6VXNlcjMxNjMxNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3163176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Andreyproger",
      "html_url": "https://github.com/Andreyproger",
      "followers_url": "https://api.github.com/users/Andreyproger/followers",
      "following_url": "https://api.github.com/users/Andreyproger/following{/other_user}",
      "gists_url": "https://api.github.com/users/Andreyproger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Andreyproger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Andreyproger/subscriptions",
      "organizations_url": "https://api.github.com/users/Andreyproger/orgs",
      "repos_url": "https://api.github.com/users/Andreyproger/repos",
      "events_url": "https://api.github.com/users/Andreyproger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Andreyproger/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-02-10T16:20:01Z",
    "updated_at": "2022-04-03T08:46:26Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Сборщик мусора либо помечать участки не используемой памяти, чтобы избежать memory leak. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/510/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 3,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/510/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/509",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/509/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/509/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/509/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/509",
    "id": 1129533567,
    "node_id": "I_kwDOFK7cns5DU1B_",
    "number": 509,
    "title": "std::expected должен позволять выкидывать неизменённое пользовательское исключение",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-02-10T06:48:21Z",
    "updated_at": "2022-04-03T08:47:00Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Нужна возможность кастомизации выкидывания исключения. Обсуждение доступно по ссылке https://habr.com/ru/company/yandex/blog/649497/#comment_24051655\r\n\r\nВ идеале, нужна кастомизация, позволяющая превращать коды ошибок в исключения. Черновой интерфейс:\r\n```cpp\r\nstruct throw_bad_expected_acess {\r\n    template <class E>\r\n    [[noreturn]] void operator()(E&& e) const {\r\n        throw bad_expected_access(std::forward<E>(e))\r\n    }\r\n};\r\n\r\ntemplate<class T, class E, class C = throw_bad_expected_acess> class expected;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/509/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/509/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/508",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/508/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/508/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/508/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/508",
    "id": 1128263736,
    "node_id": "I_kwDOFK7cns5DP_A4",
    "number": 508,
    "title": "Добавить в std::runtime_error и std::logic_error (и их наследников) конструктор, который получает std::string_view",
    "user": {
      "login": "eao197",
      "id": 11836621,
      "node_id": "MDQ6VXNlcjExODM2NjIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/11836621?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eao197",
      "html_url": "https://github.com/eao197",
      "followers_url": "https://api.github.com/users/eao197/followers",
      "following_url": "https://api.github.com/users/eao197/following{/other_user}",
      "gists_url": "https://api.github.com/users/eao197/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eao197/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eao197/subscriptions",
      "organizations_url": "https://api.github.com/users/eao197/orgs",
      "repos_url": "https://api.github.com/users/eao197/repos",
      "events_url": "https://api.github.com/users/eao197/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eao197/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2022-02-09T09:18:28Z",
    "updated_at": "2022-02-12T11:53:13Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Судя по документации на cppreference и по драфту стандарта (раздел 19.2) у [std::runtime_error](https://en.cppreference.com/w/cpp/error/runtime_error) и [std::logic_error](https://en.cppreference.com/w/cpp/error/logic_error) есть конструкторы, которые получают `const std::string&` и `const char *` (при этом подразумевается, что `const char*` -- это строка с 0-символом в конце). Но нет конструктора, который бы получал `std::string_view`.\r\n\r\nПосле добавления в стандарт `std::string_view` выглядит странно, что стандартные классы исключений не могут получать описание ошибки в виде `std::string_view`.\r\n\r\nОтсутствие такого конструктора создает неудобства, например, в таких случаях:\r\n```cpp\r\n// Throws an exception if operation can't be started.\r\nvoid ensure_valid_state_for_operation(std::string_view operation_description) {\r\n  if(!check_first_condition()) throw std::runtime_error{operation_description};\r\n  if(!check_second_condition()) throw std::runtime_error{operation_description};\r\n  ...\r\n}\r\n```\r\nТакой код не скомпилируется. Нужно будет делать преобразование из string_view в string, но при этом мы можем получить две аллокации: первая при создании временного string, вторая -- при создании еще одной копии внутри runtime/logic_error (т.к. string принимается по константной ссылке и содержимое временного string-а не может быть перемещено внутрь runtime/logic_error).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/508/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/508/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/507",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/507/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/507/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/507/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/507",
    "id": 1118345021,
    "node_id": "I_kwDOFK7cns5CqJc9",
    "number": 507,
    "title": "Уточнить условие \"inline-hint\" для inline-функций",
    "user": {
      "login": "Izaron",
      "id": 5406399,
      "node_id": "MDQ6VXNlcjU0MDYzOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5406399?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Izaron",
      "html_url": "https://github.com/Izaron",
      "followers_url": "https://api.github.com/users/Izaron/followers",
      "following_url": "https://api.github.com/users/Izaron/following{/other_user}",
      "gists_url": "https://api.github.com/users/Izaron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Izaron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Izaron/subscriptions",
      "organizations_url": "https://api.github.com/users/Izaron/orgs",
      "repos_url": "https://api.github.com/users/Izaron/repos",
      "events_url": "https://api.github.com/users/Izaron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Izaron/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 8,
    "created_at": "2022-01-29T22:43:57Z",
    "updated_at": "2022-01-30T11:38:01Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Так вышло, что сейчас в C++ ключевое слово `inline` для функций (точнее, само понятие `inline`-функции) наделяет их двумяя абсолютно ортогональными друг другу effective смыслами. Понятно, что один смысл вытек из другого, но все равно это раздельные сущности. Это:\r\n\r\n1. [\\[dcl.inline\\].2](https://eel.is/c++draft/dcl.inline#2): Подсказка компилятору о том, что более предпочтительна подстановка кода из функции в место вызова, чем сам вызов функции. (В компиляторе Clang в LLVM IR этот атрибут у функции называется `inlinehint`)\r\n2. [\\[dcl.inline\\].6](https://eel.is/c++draft/dcl.inline#6): Правило, что у функции может быть несколько _определений_ (_definition_) за программу. Для отсутствия UB это должны быть одинаковые определения - что естественным образом соблюдается, т.к. обычно метод определен в хидере. (В компилятора атрибут у функции называется `linkonce_odr`, для удобства далее `linkonce`)\r\n\r\nИтого условно у функции есть два атрибута - `inlinehint` и `linkonce`.\r\n\r\n**Проблема в том, что:**\r\nСтандарт написан так, что `inlinehint` дается только функциям, где явно написан спецификатор `inline`.\r\n\r\nClang выполняет именно это, т.е. `inlinehint` ставится тогда и только тогда, когда есть спецификатор `inline`.\r\n\r\nТо есть получается вот что: `inline int random() { return 4; }` будет **И** `inlinehint`, **И** `linkonce`.\r\n\r\nА вот методы, которые по Стандарту _implicit inline functions_, как то:\r\n\r\n- инстанциации шаблонов\r\n- default и deleted члены классов, и их неявные методы\r\n- методы, чей _definition_ находится внутри _definition_ класса\r\n- `constexpr`- и `consteval`-функции (на самом деле только `constexpr`, т.к. `consteval` \"испаряется\" и в  LLVM IR его тупо нету)\r\n\r\nОни **только** `linkonce`. Надо все равно писать ключевое слово `inline`, чтобы было `linkonce`+`inlinehint`.\r\n\r\nОтсюда возникают разные неприкольные штуки:\r\n1. Стандарт пишет, что такие-то методы являются _implicitly inline_, но по факту разница между `constexpr int foo()` и `inline constexpr int foo()` **есть**, это гига контринтуитивно звучит.\r\n2. Пусть у нас функция \"обычная\" (не входит в список _implicitly inline_), мы хотим чтобы она была `linkonce`, но не хотим чтобы она была `inlinehint` (т.е. чтобы компилятор ее заоптимайзил сам по-нормальному). То мы **не можем** этого сделать, функция по-любому будет `linkonce`+`inlinehint`.\r\n\r\nМетоды починки:\r\n1. **Status quo** (не хотелось бы такого): все остаётся как есть\r\n2. **Малый путь** (я имхо верю в него): `inlinehint` объявляется для всех _inline functions_ независимо от способа, каким они стали _inline functions_ (т.е. неважно был ли у них написан спецификатор `inline` или нет)\r\n3. **Большой путь** (я в него не особо верю): вводится новое ключевое слово `linkonce`, понятие _inline functions_ переименовывается в _linkonce functions_, всё остальное остаётся по-прежнему. Если keyword `inline` наделяет метод атрибутами `inlinehint`+`linkonce`, то keyword `linkonce` мог бы наделять его только атрибутом `linkonce`.\r\n\r\n(По методам надо провести голосование и потом доработать paper в сторону выбора)\r\n\r\n**Ответы на возможные вопросы:**\r\n1. **Компиляторы же давно не обращают внимание на \"подсказки\" от программистов**\r\nЯ тоже так думал, но оказалось что нет, если в 2022 году запустить Clang под флагами без оптимизации LLVM IR, то атрибут `inlinehint` можно увидеть. А в самом LLVM IR он судя по исходникам таки влияет на анализ каких-то костов, т.е. это не дохлый атрибут.\r\n\r\n2. **Почему один атрибут вытекает из другого, если они ортогональны?**\r\nЧтобы компилятор мог в translation unit заинлайнить (`inlinehint`) функцию, TU нужно \"видеть\" исходник этой функции, то есть её тело. В общем случае это невозможно обеспечить, потому что если у нас N штук TU, то будет N определений одной и той же функции и линкер сломается. Поэтому эта функция должна являться `linkonce`, чтобы не нарушился ODR.\r\n\r\nТакая же логика для `constexpr`-функций - TU должен \"видеть\" ее, чтобы вычислить в compile-time, поэтому тут уж удобнее сделать `linkonce` автоматически.\r\n\r\nКонечно, можно было бы подойти с другого пути и объявлять такие функции `static`, но это все равно немного не то - а если внутри `static`-функции есть статические переменные, то они будут займут память не 1 раз, а N раз, и будут не \"расшариваемы\" среди разных TU.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/507/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/507/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/506",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/506/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/506/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/506/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/506",
    "id": 1118239110,
    "node_id": "I_kwDOFK7cns5CpvmG",
    "number": 506,
    "title": "Определить `template<size_t N> std::string_view::string_view(const char (&)[N]);`",
    "user": {
      "login": "pavelkryukov",
      "id": 11466405,
      "node_id": "MDQ6VXNlcjExNDY2NDA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11466405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pavelkryukov",
      "html_url": "https://github.com/pavelkryukov",
      "followers_url": "https://api.github.com/users/pavelkryukov/followers",
      "following_url": "https://api.github.com/users/pavelkryukov/following{/other_user}",
      "gists_url": "https://api.github.com/users/pavelkryukov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pavelkryukov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pavelkryukov/subscriptions",
      "organizations_url": "https://api.github.com/users/pavelkryukov/orgs",
      "repos_url": "https://api.github.com/users/pavelkryukov/repos",
      "events_url": "https://api.github.com/users/pavelkryukov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pavelkryukov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-01-29T14:46:44Z",
    "updated_at": "2022-02-05T11:22:32Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "C-массив можно инициализировать литералом или списком:\r\n```c++\r\nconst char array1[] = \"abcdefgh\";\r\nconst char array2[8] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'};\r\n```\r\n\r\nКонструктор `std::string_view` неявно преобразует ссылку на C-массив в `const char*`.\r\nДля `array1` вызовется `strlen` (использовать `N` не будем, т.к. внутри литерала может быть `\\0`).\r\n`array2` же не нуль-терминирован, и вызовет неопределённое поведение.\r\n\r\nПоэтому предлагается определить более безопасный конструктор:\r\n```c++\r\ntemplate<typename CharT>\r\ntemplate<size_t N>\r\nconstexpr std::basic_string_view<CharT>::basic_string_view(const CharT (& array)[N])\r\n    : basic_string_view(array, std::find(std::begin(array), std::end(array), CharT{}) - std::begin(array))\r\n{ }\r\n```\r\n\r\nТекущее поведение меняется только там, где оно уже было неопределённым.\r\nЕсли не делегировать конструкторы, а инициализировать поля, то можно добавить `noexcept`.\r\n\r\nМотивационный пример с UB: https://godbolt.org/z/exYY8G997\r\n\r\nP. S. Для общности можно добавить `template<typename CharT> std::char_traits<CharT>::length(const CharT* const, size_t max_length)`. Хотя там уже есть `find`…",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/506/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/506/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/505",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/505/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/505/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/505/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/505",
    "id": 1110782742,
    "node_id": "I_kwDOFK7cns5CNTMW",
    "number": 505,
    "title": "Добавить в стандарт специализацию std::formatter для thread_id",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-01-21T18:49:48Z",
    "updated_at": "2023-02-23T10:37:40Z",
    "closed_at": "2023-02-23T10:37:17Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Очевидно, что всё что умеет выводиться в потоки (имеет оператор << для стримов) должно уметь выводиться и в std::format, но на данный момент вот этот код, который по сути делает одно и то же, не компилируется.(формат не умеет работать с этим типом)\r\n```cpp\r\n  std::cout << std::this_thread::get_id();\r\n  std::cout << std::format(\"{}\", std::this_thread::get_id());\r\n```\r\nВ предложениях в С++23 не увидел этого",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/505/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/505/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/504",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/504/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/504/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/504/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/504",
    "id": 1110266279,
    "node_id": "I_kwDOFK7cns5CLVGn",
    "number": 504,
    "title": "std::string_ref как обертка над const char*",
    "user": {
      "login": "kol65536black",
      "id": 6318365,
      "node_id": "MDQ6VXNlcjYzMTgzNjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6318365?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kol65536black",
      "html_url": "https://github.com/kol65536black",
      "followers_url": "https://api.github.com/users/kol65536black/followers",
      "following_url": "https://api.github.com/users/kol65536black/following{/other_user}",
      "gists_url": "https://api.github.com/users/kol65536black/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kol65536black/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kol65536black/subscriptions",
      "organizations_url": "https://api.github.com/users/kol65536black/orgs",
      "repos_url": "https://api.github.com/users/kol65536black/repos",
      "events_url": "https://api.github.com/users/kol65536black/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kol65536black/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 14,
    "created_at": "2022-01-21T09:48:10Z",
    "updated_at": "2022-01-29T12:18:28Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Хотелось бы иметь обертку над const char* у которой implicit конструктор от const char*, определены операторы сравнения и ряд других полезных функций. Мне кажется странным, но такого нет в библиотеке до сих пор. Может быть есть на то какие-то причины. Хотелось бы обсудить эту тему.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/504/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/504/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/503",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/503/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/503/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/503/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/503",
    "id": 1108046736,
    "node_id": "I_kwDOFK7cns5CC3OQ",
    "number": 503,
    "title": "consteval для конструктора и CTAD",
    "user": {
      "login": "XRay3D",
      "id": 10693876,
      "node_id": "MDQ6VXNlcjEwNjkzODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10693876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/XRay3D",
      "html_url": "https://github.com/XRay3D",
      "followers_url": "https://api.github.com/users/XRay3D/followers",
      "following_url": "https://api.github.com/users/XRay3D/following{/other_user}",
      "gists_url": "https://api.github.com/users/XRay3D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/XRay3D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/XRay3D/subscriptions",
      "organizations_url": "https://api.github.com/users/XRay3D/orgs",
      "repos_url": "https://api.github.com/users/XRay3D/repos",
      "events_url": "https://api.github.com/users/XRay3D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/XRay3D/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2022-01-19T12:32:43Z",
    "updated_at": "2022-02-08T06:39:12Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Разрешить consteval конструктор:\r\n```c++\r\ntemplate <class Ty, Ty Val>\r\nstruct integral_constant {\r\n    consteval integral_constant (Ty Val) {\r\n        ...\r\n    }\r\n    ...\r\n};\r\n\r\ntemplate <class Ty, Ty Val>\r\nintegral_constant(Ty Val) -> integral_constant<Ty, Val>;\r\n\r\nstruct bool_constant {\r\n    static constexpr bool value;\r\n    consteval bool_constant (bool Val = false) : value{Val} {\r\n        ...\r\n    }\r\n    ...\r\n};\r\n```\r\nВозможное использование:\r\n\r\n```c++\r\nconstexpr auto thing{integral_constant(10ULL)};\r\n\r\nvoid some_func(auto param) {\r\n    ...\r\n}\r\n//вызов\r\nsome_func(integral_constant(123));\r\nsome_func(thing);\r\nsome_func(bool_constant{});\r\nsome_func(bool_constant{true});\r\n\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/503/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/503/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/502",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/502/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/502/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/502/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/502",
    "id": 1105191965,
    "node_id": "I_kwDOFK7cns5B3-Qd",
    "number": 502,
    "title": "Deal with the mess around the \"volatile\" modifier",
    "user": {
      "login": "AVI-crak",
      "id": 35156298,
      "node_id": "MDQ6VXNlcjM1MTU2Mjk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/35156298?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AVI-crak",
      "html_url": "https://github.com/AVI-crak",
      "followers_url": "https://api.github.com/users/AVI-crak/followers",
      "following_url": "https://api.github.com/users/AVI-crak/following{/other_user}",
      "gists_url": "https://api.github.com/users/AVI-crak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AVI-crak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AVI-crak/subscriptions",
      "organizations_url": "https://api.github.com/users/AVI-crak/orgs",
      "repos_url": "https://api.github.com/users/AVI-crak/repos",
      "events_url": "https://api.github.com/users/AVI-crak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AVI-crak/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2022-01-16T21:26:33Z",
    "updated_at": "2022-01-19T19:15:32Z",
    "closed_at": "2022-01-19T19:15:32Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "For x86, \"volatile\" behavior is considered normal. All data is stored on the stack and external memory, any change obliges to rewrite the variables where they are - on the stack and external memory.\r\nFor ARM, it's a mess. Data can be stored in registers, on the stack, in external memory, and in memory at a fixed address. But the intermediate unconditional saving to the stack is still used. This point is very relevant for embedded systems, where the memory size can be 4k (very small chip).\r\n\r\nI propose to change the attributes of the register space of ARM systems to \"fast memory\", at least in the form of a crutch for external variable modifiers. In this case, the place of creation and primary placement of a variable with the \"volatile\" attribute will lose the relevance of unconditional storage on the stack. But it will retain the unconditional execution of any mathematical and logical operations on a variable in the order of writing the program code, until the moment the function is out of scope. The loss of visibility outside the function to store on the stack and in a register is the same, then why pay more?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/502/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/502/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/501",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/501/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/501/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/501/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/501",
    "id": 1103608403,
    "node_id": "I_kwDOFK7cns5Bx7pT",
    "number": 501,
    "title": "Добавить возможность вычисления дэфолтных аргументов в месте вызова.",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-01-14T13:02:06Z",
    "updated_at": "2022-01-14T20:18:32Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Сейчас дефолтные аргументы для функций вычисляются в месте объявления.\r\n\r\nДополнительно к этому механизму я предлагаю добавить механизм для вычисления дефолтных аргуметнов в месте вызова.\r\n\r\nСейчас этот механизм реализуется через макрофункции (что не удобно). Например макрофункция логирования, которая инжектит в С++ функцию логирования контент из локальной области видимости, ( если он есть ), либо из аргументов, либо из членов класса, либо из неймспейса, либо из глобального неймспейса. Как результат, мы знаем кто вызвал функцию логирования, в каком контексте, и тд.\r\n\r\nВообще же горизонты применения этого функционала гораздо шире логирования. \r\nМожно запрещать или разрешать вызов API из определенных неймспейсов или классов (нечто наподобии инкапсуляции для функций). \r\nМожно специализировать поведение функций в зависимости от места вызова (например в singleThread нэймспейсе одно поведение, а в multithread другое, а в классе где есть mutable mutex c определенным именем - третье, а в юнит тестах - четвертое).\r\n\r\nГоворя языком паттернов, можно делать mixin`ы на функциях.\r\n\r\nИнструмент котороый может получится - будет с удивительными возможностями многие из которых еще предстоит открыть. Значительно повысит выразительность кода. И уберёт один из последних рубежей где прочно закрепился препроцессор.\r\n\r\nКрасивый синтаксис (и главное простой и выразительный) я не придумал, он может быть чем то наподобии:\r\n\r\n```\r\nint log( const string &context = declevaluate( getContext() ), const string & line = declevaluate( __LINE__) , const string & var );\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/501/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/501/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/500",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/500/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/500/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/500/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/500",
    "id": 1102549844,
    "node_id": "I_kwDOFK7cns5Bt5NU",
    "number": 500,
    "title": "Запретить писать inline для constexpr-функций и переменных",
    "user": {
      "login": "Izaron",
      "id": 5406399,
      "node_id": "MDQ6VXNlcjU0MDYzOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5406399?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Izaron",
      "html_url": "https://github.com/Izaron",
      "followers_url": "https://api.github.com/users/Izaron/followers",
      "following_url": "https://api.github.com/users/Izaron/following{/other_user}",
      "gists_url": "https://api.github.com/users/Izaron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Izaron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Izaron/subscriptions",
      "organizations_url": "https://api.github.com/users/Izaron/orgs",
      "repos_url": "https://api.github.com/users/Izaron/repos",
      "events_url": "https://api.github.com/users/Izaron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Izaron/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 9,
    "created_at": "2022-01-13T23:12:10Z",
    "updated_at": "2022-01-16T23:00:50Z",
    "closed_at": "2022-01-16T18:41:49Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "`constexpr`- и `consteval`-методы и constexpr-переменные неявно объявлены `inline`\r\n[[dcl.constexpr]](http://eel.is/c++draft/dcl.constexpr#1.sentence-3)\r\n\r\nЭто логично - если у них есть шанс вычислиться в compile-time, то им можно немного обойти ODR. Потому что вычислить метод, не видя его определения в текущем translation unit, невозможно by desing.\r\n\r\nОднако многие программисты, наверное, либо не знают это, либо добавляют `inline` \"для надежности\".\r\nВ результате **вагон** проектов самой разной крутости имеют кучу `inline constexpr`/`inline consteval`\r\nhttps://github.com/search?p=1&q=inline+constexpr&type=Code\r\n(clang и gcc не выводят warning на это, всем пофигу)\r\n\r\nЕсть возможность \"упростить\" язык, одновременно повышая \"грамотность\" программистов, выводя ошибку о том, что метод уже является `inline`.\r\n\r\n**UPD**: `inline constexpr`-переменные смысл всё же имеют. А методы и static data members - нет.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/500/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/500/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/499",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/499/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/499/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/499/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/499",
    "id": 1099920750,
    "node_id": "I_kwDOFK7cns5Bj3Vu",
    "number": 499,
    "title": "make template and typename more optional",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2022-01-12T06:12:03Z",
    "updated_at": "2022-01-12T10:10:31Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_Описание:_\r\nЕсли разрешить на декларации классов/структур писать концепт и это будет означать, что класс и все специализации класса должны соответствовать этому концепту, то мы получим\r\n1. Явный шаблонный интерфейс(а не как раньше неявный)\r\n2. Возможность компилятору понимать какие алиасы/ шаблоны обязаны присутствовать в классе и его специализациях, а значит можно будет не писать typename / template, это позволит сделать нормальный интерфейс тупла(с внутренним гетом), добавить в стандарт базовые инструменты работы с вариадиками(например std::type_list и внутри него шаблоны для работы с паком, например ::containts<T> / expand<Foo<typename...> > и прочее)\r\n3.  Улучшение читаемости кода\r\n4. Возможность проверить наличие ошибок на уровне концептов(противоречивых условий в них и ошибки в местах их использующих в шаблонном коде)\r\n\r\n_Примеры_\r\n```cpp\r\ntemplate<typename...>\r\nstd::ranges::random_access_range struct MyClass {\r\n// много кода, из которого долго понимать что перед нами\r\n};\r\n\r\ntemplate<typename T>\r\nconcept metafunction = requires (T) { typename T::type };\r\n\r\ntemplate<typename T>\r\nmetafunction struct type_identity { using type = T; };\r\n\r\n... где то в другом месте ...\r\ntemplate<metafunction F>\r\nvoid Foo() {\r\nF::type value; // без typename\r\n}\r\n// или я сделал специализацию класса MyVector и у него итератор\r\n// не соответствует концепту random_access_iterator - ошибка компиляции! Классно же\r\n```\r\n\r\nИли вот другой пример, чего явно не хватает в стандарте - работы с вариадиками(тем более что после добавления в стандарт скорость компиляции подобного кода из-за интринсиков вырастет в сотни раз)\r\n```cpp\r\ntemplate<typename T>\r\nconcept type_list_interface = requires (T) {\r\n typename T::template get<0>;\r\n { T::template contains<int> } -> std::same_as<bool>;\r\n}\r\ntemplate<typename...>\r\ntype_list_interface struct type_list { ... };\r\n\r\n... где в пользовательском коде ...\r\n\r\ntemplate<typename... Types>\r\nauto Foo(Types&&... args) {\r\nif constexpr (type_list<Types...>::contains<double>) (\r\n return 3;\r\n}\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/499/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/499/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/498",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/498/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/498/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/498/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/498",
    "id": 1097276605,
    "node_id": "I_kwDOFK7cns5BZxy9",
    "number": 498,
    "title": "Стандартная библиотека корутин",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2022-01-09T19:07:08Z",
    "updated_at": "2022-01-11T10:57:35Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_Описание_:\r\nНам очевидно нужна поддержка корутин в стандарте. Минимальный набор готовых корутин, инфраструктура вокруг них(utility), концепты, набор \"сделай сам\" для кастомизации под конкретные нужды.\r\n\r\n_Примеры_\r\nСмешной и неэффективный пример, потому что все итак знают, что генераторы полезны\r\n```cpp\r\n\r\ntemplate<std::ranges::borrowed_range... Ranges>\r\nauto zip(Ranges&&... rs)->generator<std::tuple<decltype(std::declval<Ranges>()[0])...>> {\r\n  for (size_t i = 0; ((i < rs.size()) && ...); ++i)\r\n      co_await yield(rs[i]...);\r\n      // yield это специальный тип, когда хочется yield значение\r\n      // сконструировать прямо тут из многих аргументов\r\n      // (иначе это воспринимается как init list)\r\n}\r\n\r\nvoid zip_user {\r\n  std::vector<char> vec;\r\n  vec.resize(10, 'c');\r\n  std::string sz = \"Hello world\";\r\n  for (auto [a,b,c] : zip(vec, sz, std::string_view(sz)))\r\n      std::format_to(std::ostream_iterator<char>(std::cout), \"{}{}{}\\n\", a, b, c);\r\n}\r\n```\r\nНужны корутины также и для асинхронного кода, конечно же\r\n```cpp\r\nkelbon::logical_thread Multithread(std::atomic<int32_t>& value, std::allocator<std::byte>) {\r\n// В этом примере я игнорирую стоп токен, но вообще можно его использовать,\r\n// хотя всё равно по умолчанию на каждом co_await проверяется запрошен ли стоп\r\n  auto my_stop_token = co_await this_coro::stop_token;\r\n  co_await jump_on(another_thread);\r\n  for (auto i : std::views::iota(0, 100)) ++value; // do my job\r\n}\r\n\r\nvoid Moo() {\r\n  std::atomic<int32_t> value;\r\n  std::vector<logical_thread> workers;\r\n  for (int i = 0; i < 10; ++i)\r\n    workers.emplace_back(Multithread(value, std::allocator<std::byte>{}));\r\n// здесь вызывается деструктор вектора, который вызывает деструкторы корутин\r\n// и мы дожидаемся выполнения всех логических потоков\r\n}\r\n\r\n```\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\nЕсть\r\nhttps://github.com/kelbon/UndefinedBehavior_GoldEdition\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/498/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/498/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/497",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/497/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/497/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/497/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/497",
    "id": 1097241238,
    "node_id": "I_kwDOFK7cns5BZpKW",
    "number": 497,
    "title": "std::ranges не должны игнорировать & && перегрузки begin / end",
    "user": {
      "login": "kelbon",
      "id": 58717435,
      "node_id": "MDQ6VXNlcjU4NzE3NDM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/58717435?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kelbon",
      "html_url": "https://github.com/kelbon",
      "followers_url": "https://api.github.com/users/kelbon/followers",
      "following_url": "https://api.github.com/users/kelbon/following{/other_user}",
      "gists_url": "https://api.github.com/users/kelbon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kelbon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kelbon/subscriptions",
      "organizations_url": "https://api.github.com/users/kelbon/orgs",
      "repos_url": "https://api.github.com/users/kelbon/repos",
      "events_url": "https://api.github.com/users/kelbon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kelbon/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2022-01-09T16:32:11Z",
    "updated_at": "2022-01-20T07:38:05Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Если в случае range based for loop игнорировать такие перегрузки ещё адекватно, то в случае ranges это приводит к проблемам, например, пусть у меня есть условный генератор - корутина, тогда в в случае && для интеграции с std::ranges я бы мог перегрузить begin для &&,, создав владеющий итератор(владеющий coroutine_handle)\r\nПри этом метод end() является **статическим**, поэтому никаких проблем с вызовом end после вызова перегруженного для && метода нет.\r\n```cpp\r\n// здесь owner - coroutine_handle\r\n  auto begin() && {\r\n    struct iterator_owner : iterator {\r\n      using iterator::iterator;\r\n      iterator_owner(iterator_owner&& other) noexcept : owner(std::exchange(other.owner, nullptr)) {}\r\n      iterator_owner& operator=(iterator_owner&& other) noexcept { std::swap(owner, other.owner); }\r\n      ~iterator_owner() {\r\n        if (owner) owner.destroy();\r\n      }\r\n    };\r\n    this->my_handle.resume();\r\n    return iterator_owner{{this->release()}};\r\n  }\r\n```\r\nТогда пользователь мог бы безопасно писать\r\n```cpp\r\ntemplate <typename T, typename Alloc>\r\nconstexpr bool ::std::ranges::enable_borrowed_range<kelbon::generator<T, Alloc>> = true;\r\n\r\nvoid Foo() {\r\n  auto make_generator = []() -> kelbon::generator<int> {\r\n    for (auto i = 0; i < 100; ++i)\r\n      co_yield i;\r\n  };\r\n  for (auto v : make_generator() | std::views::all)\r\n    std::cout << v;\r\n}\r\n```\r\nСейчас произойдёт UB, т.к. внутри ranges не происходит forward ренжа, и выберется не та перегрузка begin, скорее всего рантайм ошибка(в лучшем случае)\r\n\r\nКак я предлагаю это исправить:\r\nИсправить текст стандарта\r\n```cpp\r\n    template<borrowed_­range R>\r\n      requires convertible-to-non-slicing<iterator_t<R>, I> &&\r\n               convertible_­to<sentinel_t<R>, S>\r\n    constexpr subrange(R&& r, make-unsigned-like-t<iter_difference_t<I>> n)\r\n      requires (K == subrange_kind::sized)\r\n        : subrange{ranges::begin(r), ranges::end(r), n} {}\r\n```\r\nhttps://eel.is/c++draft/range.subrange#ctor-6.2\r\nhttps://eel.is/c++draft/range.subrange#access-10\r\nДобавив `std::forward<decltype(r)>`\r\n\r\nЛибо добавить перегрузки с requires, если будет страшно за abi",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/497/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/497/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/496",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/496/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/496/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/496/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/496",
    "id": 1096380664,
    "node_id": "I_kwDOFK7cns5BWXD4",
    "number": 496,
    "title": "Compound literals",
    "user": {
      "login": "NN---",
      "id": 580536,
      "node_id": "MDQ6VXNlcjU4MDUzNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/580536?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NN---",
      "html_url": "https://github.com/NN---",
      "followers_url": "https://api.github.com/users/NN---/followers",
      "following_url": "https://api.github.com/users/NN---/following{/other_user}",
      "gists_url": "https://api.github.com/users/NN---/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NN---/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NN---/subscriptions",
      "organizations_url": "https://api.github.com/users/NN---/orgs",
      "repos_url": "https://api.github.com/users/NN---/repos",
      "events_url": "https://api.github.com/users/NN---/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NN---/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-01-07T14:45:14Z",
    "updated_at": "2022-02-10T21:13:26Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "C99 поддерживает создание временного объекта непосредственно при передаче.\r\nБыло бы хорошо иметь поддержку в C++.\r\n\r\n```cpp\r\nint *p = (int[]){2, 4}; // creates an unnamed static array of type int[2]\r\n                        // initializes the array to the values {2, 4}\r\n                        // creates pointer p to point at the first element of the array\r\nconst float *pc = (const float []){1e0, 1e1, 1e2}; // read-only compound literal\r\n \r\nint main(void)\r\n{\r\n    int n = 2, *p = &n;\r\n    p = (int [2]){*p}; // creates an unnamed automatic array of type int[2]\r\n                       // initializes the first element to the value formerly held in *p\r\n                       // initializes the second element to zero\r\n                       // stores the address of the first element in p\r\n \r\n    struct point {double x,y;};\r\n    void drawline1(struct point from, struct point to);\r\n    void drawline2(struct point *from, struct point *to);\r\n    drawline1((struct point){.x=1, .y=1},  // creates two structs with block scope \r\n              (struct point){.x=3, .y=4}); // and calls drawline1, passing them by value\r\n    drawline2(&(struct point){.x=1, .y=1},  // creates two structs with block scope \r\n              &(struct point){.x=3, .y=4}); // and calls drawline2, passing their addresses\r\n}\r\n```\r\n\r\nhttps://en.cppreference.com/w/c/language/compound_literal",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/496/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/496/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/495",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/495/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/495/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/495/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/495",
    "id": 1091721974,
    "node_id": "I_kwDOFK7cns5BElr2",
    "number": 495,
    "title": "добавить новые std::this_thread::sleep_for/sleep_until с аргументом stop_token",
    "user": {
      "login": "marakew",
      "id": 3596295,
      "node_id": "MDQ6VXNlcjM1OTYyOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3596295?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marakew",
      "html_url": "https://github.com/marakew",
      "followers_url": "https://api.github.com/users/marakew/followers",
      "following_url": "https://api.github.com/users/marakew/following{/other_user}",
      "gists_url": "https://api.github.com/users/marakew/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marakew/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marakew/subscriptions",
      "organizations_url": "https://api.github.com/users/marakew/orgs",
      "repos_url": "https://api.github.com/users/marakew/repos",
      "events_url": "https://api.github.com/users/marakew/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marakew/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2022-01-01T02:50:30Z",
    "updated_at": "2022-01-01T07:21:10Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "sub думаю в комментариях не нуждается\r\nс boost::thread слизали все \r\nкроме самого распространенного применения когда с ожиданием boost::this_thread::sleep_for\r\nкоторый можно прервать по с boost::thread::interrupt()\r\nпотом в std::jthread добавили stop_token, а про sleep похоже забыли/забили\r\n\r\nso забит\r\nна вопросы, \"- а как реализовать прерывающийся sleep?\"\r\nсоветами - \"напишите сами, там три четыре строки кода\"\r\n\r\nwtf зачем их писать, когда imho это должно быть в стандарте",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/495/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/495/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/494",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/494/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/494/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/494/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/494",
    "id": 1090769566,
    "node_id": "I_kwDOFK7cns5BA9Ke",
    "number": 494,
    "title": "Сделать слово `requires` контекстно-зависимым",
    "user": {
      "login": "leha-bot",
      "id": 10153298,
      "node_id": "MDQ6VXNlcjEwMTUzMjk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/10153298?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leha-bot",
      "html_url": "https://github.com/leha-bot",
      "followers_url": "https://api.github.com/users/leha-bot/followers",
      "following_url": "https://api.github.com/users/leha-bot/following{/other_user}",
      "gists_url": "https://api.github.com/users/leha-bot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leha-bot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leha-bot/subscriptions",
      "organizations_url": "https://api.github.com/users/leha-bot/orgs",
      "repos_url": "https://api.github.com/users/leha-bot/repos",
      "events_url": "https://api.github.com/users/leha-bot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leha-bot/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-12-29T22:04:04Z",
    "updated_at": "2021-12-31T17:18:43Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В 20-ку концепты принесли новый ключевик `requires`, который, по идее, используется только в определенных местах (в декларации функции, в описании шаблона, етц - поправьте, список сумбурно привел)\r\n\r\nОднако это приводит к тому, что существующий код ломается, см например ,сюда:\r\n\r\nhttps://github.com/rpm-software-management/createrepo_c/issues/181\r\n\r\n(Где-то это уже поменяли в недрах RPM/libsolv, но это привело к нарушению обратной совместимости и костылям, см например тут: https://github.com/openSUSE/libsolv/pull/477/files )\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/494/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/494/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/493",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/493/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/493/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/493/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/493",
    "id": 1088741589,
    "node_id": "I_kwDOFK7cns5A5ODV",
    "number": 493,
    "title": "Relax field designators order",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 7,
    "created_at": "2021-12-26T10:20:42Z",
    "updated_at": "2022-01-14T20:17:38Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В C++20 добавили field designators https://en.cppreference.com/w/cpp/language/aggregate_initialization. \r\n\r\nЭто замечательный функционал который может значительно расширить декларативные возможности C++, и позволит использовать язык в тех контекстах, подобных use-кейсам yml\\json\\css.\r\n\r\nНо есть одна печальная оговорка, которая сводит на нет полезность этой фичи. Инициализаторы должны быть в порядке обьявления. Это приводит к тому, что автор класса диктует дизайн для инициализации, объявление становится \"замороженным\" после публикации интерфейса, и любой рефакторинг связанный с порядком и количеством членов класса становится дорогим и нежелательным.\r\n\r\nСудя по компилятору Clang - https://godbolt.org/z/c9dWTrnKx , то нет проблемы компилировать код с любым порядком инициализаторов ( он это умеет делать в любой версии, но в последней с ворнингом ). Компиляторы gcc msvc - отказываются.\r\n\r\n\r\n```\r\nstruct point \r\n{\r\n    int x; // << хочу рефакторить порядок объявления членов класса, без изменения клиентского кода\r\n    int y;\r\n};\r\n\r\nint main() {\r\n    point a = { \r\n        .y=2, // << Хочу дизайнить инициализацию в любом порядке, для выражения смысла локального контекста\r\n        .x=4,\r\n        };\r\n\r\n    cout << a.x << \" \" << a.y << endl;  \r\n}\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/493/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/493/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/492",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/492/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/492/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/492/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/492",
    "id": 1085950340,
    "node_id": "I_kwDOFK7cns5AukmE",
    "number": 492,
    "title": "Запретить возврат ссылок на временные объекты",
    "user": {
      "login": "b2soft",
      "id": 6034932,
      "node_id": "MDQ6VXNlcjYwMzQ5MzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6034932?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/b2soft",
      "html_url": "https://github.com/b2soft",
      "followers_url": "https://api.github.com/users/b2soft/followers",
      "following_url": "https://api.github.com/users/b2soft/following{/other_user}",
      "gists_url": "https://api.github.com/users/b2soft/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/b2soft/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/b2soft/subscriptions",
      "organizations_url": "https://api.github.com/users/b2soft/orgs",
      "repos_url": "https://api.github.com/users/b2soft/repos",
      "events_url": "https://api.github.com/users/b2soft/events{/privacy}",
      "received_events_url": "https://api.github.com/users/b2soft/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 7,
    "created_at": "2021-12-21T15:27:16Z",
    "updated_at": "2022-01-09T16:21:00Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "На данный момент возвращать ссылку на временный объект является UB. Можно считать ill-formed код, если функция возвращает ссылку (без учета cv-квалифаеров) и в return statement указан возврат локальной/рвалуе переменной.\r\n```\r\nint& GetRef()\r\n{\r\n    int x = 42;\r\n    return x; // Хорошо бы тут Compilation Error returning reference to local variable\r\n}\r\n```\r\n\r\nПозволит увидеть подобные ошибки на этапе компиляции, вместо UB на рантайме. Следует отметить, что в компиляторе MSVC подобный код еще и работает нормально, что создает ложное впечатление о \"правильности\" кода и его переносимости (GCC будет писать ворнинг -Wreturn-local-addr на такой возврат). Также, механизм определения подобного кода существует (ворнинг в GCC), но не у всех включен + не все включают Treat Warning as Errors. А ворнинг достаточно критичный и не всегда заметный, по моему мнению.\r\nЯ тяжело себе представляю, в каком случае возврат ссылки на локальную переменную вообще является корректным использованием механизма ссылок.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/492/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/492/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/491",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/491/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/491/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/491/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/491",
    "id": 1083835961,
    "node_id": "I_kwDOFK7cns5AmgY5",
    "number": 491,
    "title": "Уточнить поведение `std::forward_list::merge`",
    "user": {
      "login": "pavelkryukov",
      "id": 11466405,
      "node_id": "MDQ6VXNlcjExNDY2NDA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11466405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pavelkryukov",
      "html_url": "https://github.com/pavelkryukov",
      "followers_url": "https://api.github.com/users/pavelkryukov/followers",
      "following_url": "https://api.github.com/users/pavelkryukov/following{/other_user}",
      "gists_url": "https://api.github.com/users/pavelkryukov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pavelkryukov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pavelkryukov/subscriptions",
      "organizations_url": "https://api.github.com/users/pavelkryukov/orgs",
      "repos_url": "https://api.github.com/users/pavelkryukov/repos",
      "events_url": "https://api.github.com/users/pavelkryukov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pavelkryukov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-12-18T13:43:49Z",
    "updated_at": "2022-01-06T18:27:56Z",
    "closed_at": "2022-01-05T10:39:22Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Для двусвязного списка `std::list` в [n4901](https://github.com/cplusplus/draft/releases/tag/n4901) в описании метода `merge` есть такая ремарка:\r\n\r\n> _Effects_: If **`addressof(x) == this`**, does nothing;\r\n\r\nДля односвязного списка `std::forward_list` об этом случае ничего не сказано.\r\nИз-за этого поведение имплементаций различно:\r\n\r\n* libstdc++ [проверок не делает](https://github.com/gcc-mirror/gcc/blob/cc032ec1ecb34b006f42e170ccb9d76aa42fd8eb/libstdc%2B%2B-v3/include/bits/forward_list.tcc#L364-L384), улетает в бесконечный цикл\r\n* libc++ делает [проверку](\r\nhttps://github.com/llvm/llvm-project/blob/ff94bd1bc92efb2a116fb2963d0425a529d3be89/libcxx/include/forward_list#L1584-L1596)\r\n* то же верно и для [MS STL](\r\nhttps://github.com/microsoft/STL/blob/303df3dae6f5ed9fe4f1c35257f663af8355584a/stl/inc/forward_list#L1234-L1241)\r\n\r\nПоэтому предлагается:\r\n * либо явно зафиксировать неопределённое поведение\r\n * либо вставить вышеупомянутую ремарку и для `std::forward_list::merge`  (что предпочтительнее).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/491/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/491/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/490",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/490/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/490/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/490/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/490",
    "id": 1074256938,
    "node_id": "I_kwDOFK7cns5AB9wq",
    "number": 490,
    "title": "Ослабить требование, что элемент span-а должен иметь complete type",
    "user": {
      "login": "AndreyG",
      "id": 235190,
      "node_id": "MDQ6VXNlcjIzNTE5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/235190?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AndreyG",
      "html_url": "https://github.com/AndreyG",
      "followers_url": "https://api.github.com/users/AndreyG/followers",
      "following_url": "https://api.github.com/users/AndreyG/following{/other_user}",
      "gists_url": "https://api.github.com/users/AndreyG/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AndreyG/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AndreyG/subscriptions",
      "organizations_url": "https://api.github.com/users/AndreyG/orgs",
      "repos_url": "https://api.github.com/users/AndreyG/repos",
      "events_url": "https://api.github.com/users/AndreyG/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AndreyG/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-12-08T10:33:57Z",
    "updated_at": "2023-10-22T09:16:41Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Собственно, идея в заголовке. Черновик (очень-очень сырой) proposal-а содержит [мотивацию](https://github.com/AndreyG/cpp-papers/blob/main/span-of-incomplete-element-type.md#motivation-and-scope), так что просто повторю ее здесь.\r\nСейчас (в C++20) такой естественный код не валиден:\r\n```cpp\r\nclass Element;\r\n\r\nclass Storage {\r\n  ...\r\n  span<Element> get_elements();\r\n};\r\n\r\nextern void process(span<Element>);\r\n\r\nvoid do_something(Storage& storage) {\r\n  process(storage.get_elements());\r\n}\r\n```\r\nхотя с точки зрения здравого смысла `span<Element>` должен быть эквивалентен `pair<Element*, size_t>`, а значит фундаментальной причины, запрещать код выше, не существует.\r\n\r\nПри этом понятно, что для большинства методов `span`-а нужно чтобы `ElementType` был complete. Это не проблема, прецедент уже есть -- `vector` [разрешает](https://eel.is/c++draft/vector#overview-4) инстанцировать класс incomplete типом, но требует, чтобы тип элемента стал complete перед инстанциацией всех member-ов `vector`-а:\r\n>An incomplete type T may be used when instantiating vector if the allocator meets the allocator completeness requirements. T shall be complete before any member of the resulting specialization of vector is referenced.\r\n\r\n Для `span`-а хочется ослабить требования до *почти* таких же, но copy/move-операции для `span`-а (они тривиальные) необходимо также разрешить даже когда тип элемента incomplete.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/490/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/490/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/489",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/489/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/489/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/489/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/489",
    "id": 1071974000,
    "node_id": "I_kwDOFK7cns4_5QZw",
    "number": 489,
    "title": "Добавить для std::string  метод count()",
    "user": {
      "login": "IllidanSR",
      "id": 24667137,
      "node_id": "MDQ6VXNlcjI0NjY3MTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/24667137?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/IllidanSR",
      "html_url": "https://github.com/IllidanSR",
      "followers_url": "https://api.github.com/users/IllidanSR/followers",
      "following_url": "https://api.github.com/users/IllidanSR/following{/other_user}",
      "gists_url": "https://api.github.com/users/IllidanSR/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/IllidanSR/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/IllidanSR/subscriptions",
      "organizations_url": "https://api.github.com/users/IllidanSR/orgs",
      "repos_url": "https://api.github.com/users/IllidanSR/repos",
      "events_url": "https://api.github.com/users/IllidanSR/events{/privacy}",
      "received_events_url": "https://api.github.com/users/IllidanSR/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-12-06T10:20:02Z",
    "updated_at": "2021-12-27T14:11:36Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Часто бывает нужно проверить есть ли в строке определённая подстрока, вернув количество вхождений.  Во многих языках для строк существует метод `.count(patter)` возвращающий количество вхождений подстроки в строке. В C++ есть std::count, но он работает только с char в качестве паттерна, что выглядит не совсем подходящим.\r\nПредложение: добавить в класс string метод count принимающий в качестве аргумента паттерн поиска и возвращающий количество вхождений паттерна в строку",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/489/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/489/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/488",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/488/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/488/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/488/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/488",
    "id": 1071235321,
    "node_id": "I_kwDOFK7cns4_2cD5",
    "number": 488,
    "title": "Сохранение Variadic Template через using",
    "user": {
      "login": "kin4stat",
      "id": 26118089,
      "node_id": "MDQ6VXNlcjI2MTE4MDg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/26118089?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kin4stat",
      "html_url": "https://github.com/kin4stat",
      "followers_url": "https://api.github.com/users/kin4stat/followers",
      "following_url": "https://api.github.com/users/kin4stat/following{/other_user}",
      "gists_url": "https://api.github.com/users/kin4stat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kin4stat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kin4stat/subscriptions",
      "organizations_url": "https://api.github.com/users/kin4stat/orgs",
      "repos_url": "https://api.github.com/users/kin4stat/repos",
      "events_url": "https://api.github.com/users/kin4stat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kin4stat/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-12-04T15:42:15Z",
    "updated_at": "2021-12-07T08:13:26Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Сделать возможным сохранять Variadic Template через using.\r\n\r\nНапример\r\n```cpp\r\ntemplate <typename Pointer>\r\nstruct function_traits;\r\n\r\ntemplate <typename Ret, typename Class, typename... Args>\r\nstruct function_traits<Ret(Class::*)(Args...)> {\r\n    static constexpr auto args_count = sizeof...(Args);\r\n    static constexpr auto function_convention = cconv::cthiscall;\r\n    using args… = Class*, Args...;\r\n    using return_type = Ret;\r\n};\r\n\r\ntemplate <typename Ret, typename... Args>\r\nstruct function_traits<Ret(CCDECL*)(Args...)> {\r\n    static constexpr auto args_count = sizeof...(Args);\r\n    static constexpr auto convention = cconv::ccdecl;\r\n    using args... = Args...;\r\n    using return_type = Ret;\r\n};\r\ntemplate <typename Ret, typename... Args>\r\nstruct function_traits<Ret(Args...)> {\r\n    static constexpr auto args_count = sizeof...(Args);\r\n    static constexpr auto convention = cconv::ccdecl;\r\n    using args… = Args...;\r\n    using return_type = Ret;\r\n};\r\n\r\ntemplate<typename Function>\r\nclass Foo{\r\n    using function = function_traits<Function>;\r\n    using Args... = typename function::args;\r\n    using Ret = typename function::return_type;\r\n}\r\n````\r\n\r\n\r\nВ текущих реалиях мы вынуждены сохранять variadic template в std::tuple(либо в своей обертке), что не всегда удобно. Например, чтобы распаковать аргументы обратно в шаблон, нам придется писать еще одну спецификацию под std::tuple\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/488/reactions",
      "total_count": 11,
      "+1": 11,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/488/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/487",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/487/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/487/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/487/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/487",
    "id": 1065737051,
    "node_id": "I_kwDOFK7cns4_hdtb",
    "number": 487,
    "title": "Итератор на последний элемент контейнера(до end())",
    "user": {
      "login": "simulacrus",
      "id": 79246839,
      "node_id": "MDQ6VXNlcjc5MjQ2ODM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/79246839?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/simulacrus",
      "html_url": "https://github.com/simulacrus",
      "followers_url": "https://api.github.com/users/simulacrus/followers",
      "following_url": "https://api.github.com/users/simulacrus/following{/other_user}",
      "gists_url": "https://api.github.com/users/simulacrus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/simulacrus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/simulacrus/subscriptions",
      "organizations_url": "https://api.github.com/users/simulacrus/orgs",
      "repos_url": "https://api.github.com/users/simulacrus/repos",
      "events_url": "https://api.github.com/users/simulacrus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/simulacrus/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 30,
    "created_at": "2021-11-29T08:18:40Z",
    "updated_at": "2021-12-11T13:51:32Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Итератор на последний элемент до end()\r\n\r\nТаким образом:\r\n1. В forward_list появляется возможность вставить элемент в конец, не итерируясь по всем элементам\r\n\r\nПоявится новый метод с названием: prev_end() или bend() или before_end()\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/487/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/487/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/486",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/486/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/486/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/486/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/486",
    "id": 1052271731,
    "node_id": "I_kwDOFK7cns4-uGRz",
    "number": 486,
    "title": "Возможность создать POD-структуры, для которых тип определяется расположением элементов, concept structs",
    "user": {
      "login": "topin89",
      "id": 25770107,
      "node_id": "MDQ6VXNlcjI1NzcwMTA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/25770107?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/topin89",
      "html_url": "https://github.com/topin89",
      "followers_url": "https://api.github.com/users/topin89/followers",
      "following_url": "https://api.github.com/users/topin89/following{/other_user}",
      "gists_url": "https://api.github.com/users/topin89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/topin89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/topin89/subscriptions",
      "organizations_url": "https://api.github.com/users/topin89/orgs",
      "repos_url": "https://api.github.com/users/topin89/repos",
      "events_url": "https://api.github.com/users/topin89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/topin89/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-11-12T18:21:33Z",
    "updated_at": "2021-12-26T11:46:56Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Идея является альтернативой/дополнением к https://github.com/cpp-ru/ideas/issues/485\r\n\r\n## Сама идея\r\nСделать возможным, чтобы часть POD-типов была одинаковой не когда полностью совпадают имена типов и членов типа, а только когда совпадает расположение каждого типа внутри. Пример\r\n\r\n```c++\r\nconcept struct Coords{\r\n    float x; //имена не играют роли\r\n    float y;\r\n    \r\n    float len() { return std::hypot(x,y); }\r\n};\r\n\r\nconcept struct xy{\r\n    float X;\r\n    float Y;\r\n    \r\n    float len_sq() { return x*x + y*y; }\r\n};\r\n\r\nstd::vector<Coords> a{ {1,2}, {3,4}, {5,6} };\r\nstd::vector<xy> b = std::move(a); // Должно компилироваться\r\n```\r\n\r\nПоскольку есть тонны написанного кода, в который новомодные concept struct никто не добавит, может быть, стоит явно сказать компилятору про совпадения типов\r\n\r\n```c++\r\nstruct Coords{\r\n    float x; //имена не играют роли\r\n    float y;\r\n    \r\n    float len() { return std::hypot(x,y); }\r\n};\r\n\r\nstruct xy{\r\n    float X;\r\n    float Y;\r\n    \r\n    float len_sq() { return x*x + y*y; }\r\n};\r\n\r\nconcept struct coords = {Coords, xy}; // не знаю, как не использовать новые ключевые слова\r\n\r\n```\r\n\r\n## Применение\r\nОдин в один с https://github.com/cpp-ru/ideas/issues/485\r\nСуществует достаточно много разных структур координат или rgb-цвета и других подобных, с одинаковым расположением элементов но формально разными типами. И хотя для простых указателей на них ещё можно делать reinterpret_cast и надеяться на лучшее, для вещей вроде `vector<vector<Coords>>` фокус уже не прокатывает.\r\n\r\n## Возможные проблемы\r\n\r\nФормальное определение одинаковости. Особенно с учётом всех константно-волатильных указателей. Вряд ли смогу сформулировать сам.\r\n\r\nВозможно, тоже будут какие-то проблемы со строгим разыменованием, но опять же, не уверен.\r\n\r\nОпределённо прибавиться работы блокам проверки одинаковости типов, не представляю сколько там её вывалиться. Как вариант, просто объявить любое несовпадение UB и внутри пусть компилятор будет уверен, что одно точно алиас другого до того дня, когда проверки реально введут.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/486/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/486/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/485",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/485/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/485/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/485/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/485",
    "id": 1052195221,
    "node_id": "I_kwDOFK7cns4-tzmV",
    "number": 485,
    "title": "Что-то вроде dealiasing_cast<T*>(T2*) для POD-массивов с одинаковой компоновкой (layout'ом)",
    "user": {
      "login": "topin89",
      "id": 25770107,
      "node_id": "MDQ6VXNlcjI1NzcwMTA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/25770107?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/topin89",
      "html_url": "https://github.com/topin89",
      "followers_url": "https://api.github.com/users/topin89/followers",
      "following_url": "https://api.github.com/users/topin89/following{/other_user}",
      "gists_url": "https://api.github.com/users/topin89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/topin89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/topin89/subscriptions",
      "organizations_url": "https://api.github.com/users/topin89/orgs",
      "repos_url": "https://api.github.com/users/topin89/repos",
      "events_url": "https://api.github.com/users/topin89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/topin89/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2021-11-12T17:23:04Z",
    "updated_at": "2022-08-28T04:12:53Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "## Сама идея\r\n\r\nХочется иметь возможность явно говорить компилятору, что указатель на структуру\r\n\r\n```c++\r\nstruct xy{\r\n    int x;\r\n    int y;\r\n};\r\n```\r\n\r\nможно считать указателям на эту:\r\n\r\n```c++\r\nstruct Coords{\r\n    int column;\r\n    int row;\r\n};\r\n```\r\n\r\n## Применение\r\nСтруктуры вроде `lib1::Color` или `lib2::Coords` применяются во многих библиотеках, и как правило в них используются одни и те же типы, расположение и часто названия переменных. Это одни и те же структуры, и это одни и те же массивы структур. Но `reinterpret_cast<Coords*>(xy_pointer)` невозможен без нарушения Strict Aliasing. Следовательно, если результат одной библиотеки нужно передать как аргумент в другую, нужно сильно извернуться.\r\n\r\nЭто или копирование всего массива, или, если библиотека поддерживает итераторы, написание итератора-конвертера. Или забить и писать `reinterpret_cast` и надеятся на лучшее. В конце концов, в clang'е прокатывает даже\r\n\r\n```c++\r\nstd::vector<long> a;\r\nstd::vector<double> &b = *reinterpret_cast< std::vector<double>* >(&a);\r\n```\r\nКонечно, кроме случаев, когда не прокатывает.\r\n\r\nЕсли библиотека поддерживает std::span на вход, было бы возможно сделать\r\n\r\n```\r\nstd::span<A> a{...};\r\nstd::span<B> b;\r\nstd::memcpy(a, b, sizeof(A));\r\n```\r\n\r\nно опять же, в момент взятия значения из B* Где-то в потрохах span'а, будет нарушения строгости и неопределённое поведение.\r\n\r\n## Ожидаемые проблемы\r\n\r\nСамо правило строгого разыменования взялось не от хорошей жизни. Тревис Доунс [хорошо описал](https://travisdowns.github.io/blog/2019/08/26/vector-inc.html), а в PVS-Studio [хорошо перевели](https://habr.com/ru/company/pvs-studio/blog/475636/), как отсутствие подобного ограничения влияет на банальный обход по вектору char'ов. И, если я правильно понял, сама возможность подобного преобразования может порушить часть оптимизаций.\r\n\r\nДумаю, это можно обойти через std::launder (если я правильно понял механизм отмывания памяти) или разрешив только преобразование к указателям на константы.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/485/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/485/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/484",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/484/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/484/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/484/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/484",
    "id": 1044074496,
    "node_id": "I_kwDOFK7cns4-O1AA",
    "number": 484,
    "title": "`std::is_default_destructible` и друзья",
    "user": {
      "login": "pavelkryukov",
      "id": 11466405,
      "node_id": "MDQ6VXNlcjExNDY2NDA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11466405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pavelkryukov",
      "html_url": "https://github.com/pavelkryukov",
      "followers_url": "https://api.github.com/users/pavelkryukov/followers",
      "following_url": "https://api.github.com/users/pavelkryukov/following{/other_user}",
      "gists_url": "https://api.github.com/users/pavelkryukov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pavelkryukov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pavelkryukov/subscriptions",
      "organizations_url": "https://api.github.com/users/pavelkryukov/orgs",
      "repos_url": "https://api.github.com/users/pavelkryukov/repos",
      "events_url": "https://api.github.com/users/pavelkryukov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pavelkryukov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-11-03T20:17:39Z",
    "updated_at": "2021-11-05T21:10:37Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Предлагается ввести следующие _type traits_:\r\n\r\n```c++\r\nnamespace std {\r\n    template<class T> struct is_default_destructible;\r\n    template<class T> struct is_default_copy_constructible;\r\n    template<class T> struct is_default_move_constructible;\r\n    template<class T> struct is_default_copy_assignable;\r\n    template<class T> struct is_default_move_assignable;\r\n} // namespace std\r\n```\r\n\r\nЭти структуры предоставляют `::value == true` тогда и только тогда, когда соответствующая функция определяется компилятором:\r\n\r\n- явно посредством синтаксиса `= default;`\r\n- неявно при отсутствии какой-либо декларации.\r\n\r\n`is_default_XXX` — более строгое условие, чем `is_XXX`, но менее строгое, чем `is_trivially_XXX`.\r\n\r\n## Примеры\r\n\r\n```c++\r\nstruct A {\r\n    int a;\r\n};\r\n\r\nstatic_assert(std::is_copy_constructible<A>::value);\r\nstatic_assert(std::is_default_copy_constructible<A>::value);\r\nstatic_assert(std::is_trivially_copy_constructible<A>::value);\r\n\r\nstruct B {\r\n    std::string b;\r\n};\r\n\r\nstatic_assert(std::is_copy_constructible<B>::value);\r\nstatic_assert(std::is_default_copy_constructible<B>::value);\r\nstatic_assert(std::is_trivially_copy_constructible<B>::value == false);\r\n\r\nstruct C {\r\n    std::string c;\r\n    C(const C& rhs) : c(rhs.c + \"_copy\") { }\r\n};\r\n\r\nstatic_assert(std::is_copy_constructible<C>::value);\r\nstatic_assert(std::is_default_copy_constructible<C>::value == false);\r\nstatic_assert(std::is_trivially_copy_constructible<C>::value == false);\r\n\r\nstruct D {\r\n    std::unique_ptr<std::string> d;\r\n};\r\n\r\nstatic_assert(std::is_copy_constructible<D>::value == false);\r\nstatic_assert(std::is_default_copy_constructible<D>::value == false);\r\nstatic_assert(std::is_trivially_copy_constructible<D>::value == false);\r\n```\r\n\r\n## Мотивация\r\n\r\nНаличие свойства `is_default_...` говорит, что объект этого типа может быть безопасно создан/скопирован/перемещён/уничтожен применением операции к каждому из полей, при этом нет ограничений на каждое поле.\r\nТакие _type traits_ обобщают работу с агрегатами, в частности, их преобразование в кортежи и обратно через Boost.PFR, и преобразование в менее стандартные структуры данных (например, SoA).\r\n\r\nНа текущий момент С++ имеет _type trait_ `is_aggregate`, имеющий похожий функционал.\r\nОднако, соответствующим ему типам позволено иметь явно определённые операторы присваивания и деструкторы:\r\n\r\n```c++\r\nstruct Aggregate {\r\n    std::string a;\r\n    std::string b;\r\n    std::string c;\r\n    Aggregate& operator=(const Aggregate& rhs) { std::tie(a, b, c) = std::tie(c, a, b); return *this; }\r\n    Aggregate& operator=(Aggregate&& rhs)      { std::tie(a, b, c) = std::tie(b, c, a); return *this; }\r\n    ~Aggregate() { std::cout << \"Destructor\\n\"; }\r\n};\r\n\r\nstatic_assert(std::is_aggregate_v<Aggregate>);\r\n\r\nstatic_assert(std::is_copy_assignable<Aggregate>::value);\r\nstatic_assert(std::is_default_copy_assignable<Aggregate>::value == false);\r\nstatic_assert(std::is_trivially_copy_assignable<Aggregate>::value == false);\r\n```\r\n\r\n## Замечания\r\n\r\n### Декларация и определение\r\n\r\nОтметим, что для следующего кода установить истинность _type trait_ невозможно:\r\n```c++\r\n// a.h\r\nstruct DontKnow {\r\n    ~DontKnow();\r\n};\r\n\r\nstatic_assert(std::is_default_destructible<DontKnow>::value == false);\r\n\r\n// a.cpp\r\nDontKnow::~DontKnow() = default;\r\n```\r\n\r\n### Короткая форма\r\n\r\nВ духе C++17 вводятся короткие формы:\r\n```c++\r\nnamespace std {\r\n    template<class T> bool is_default_destructible_v       = is_default_destructible<T>::value;\r\n    template<class T> bool is_default_copy_constructible_v = is_default_copy_constructible<T>::value;\r\n    template<class T> bool is_default_move_constructible_v = is_default_move_constructible<T>::value;\r\n    template<class T> bool is_default_copy_assignable_v    = is_default_copy_assignable<T>::value;\r\n    template<class T> bool is_default_move_assignable_v    = is_default_move_assignable<T>::value;\r\n} // namespace std\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/484/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/484/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/483",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/483/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/483/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/483/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/483",
    "id": 1039524838,
    "node_id": "I_kwDOFK7cns499ePm",
    "number": 483,
    "title": "Операторы ввода/вывода для miliseconds, seconds, etc.",
    "user": {
      "login": "blacktea",
      "id": 42189825,
      "node_id": "MDQ6VXNlcjQyMTg5ODI1",
      "avatar_url": "https://avatars.githubusercontent.com/u/42189825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blacktea",
      "html_url": "https://github.com/blacktea",
      "followers_url": "https://api.github.com/users/blacktea/followers",
      "following_url": "https://api.github.com/users/blacktea/following{/other_user}",
      "gists_url": "https://api.github.com/users/blacktea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blacktea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blacktea/subscriptions",
      "organizations_url": "https://api.github.com/users/blacktea/orgs",
      "repos_url": "https://api.github.com/users/blacktea/repos",
      "events_url": "https://api.github.com/users/blacktea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blacktea/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-10-29T12:39:14Z",
    "updated_at": "2023-10-22T09:33:37Z",
    "closed_at": "2023-10-22T09:29:19Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Предлагаю добавить операторы ввода/вывода(operator>>, operator<<) для std::chrono::duration.\r\nЭто будет удобно считывать из потока значения периода. Так же избавляет от создания временной переменой.\r\n\r\nНапример, необходимо считать из стандартного ввода продолжительность чего либо измеряемое в секундах.\r\n\r\n```\r\nint period;\r\nstd::cin >> period; \r\nstd::chrono::seconds periodSecs{ period };\r\n```\r\nКак видно, приходится создавать доп. переменную `period` для создания duration.\r\n\r\nС выводом дела обстоят чуть проще, но все равно нужно вызывать count(). Вместо этого можно было писать:\r\n\r\n```\r\nstd::chrono::seconds periodSecs{ 5 };\r\nstd::cout << periodSecs;\r\n```\r\n\r\nКажется, добавление операторов не ломает какой либо код.\r\n\r\nПолезные ссылки:\r\n* https://en.cppreference.com/w/cpp/chrono/duration\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/483/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/483/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/482",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/482/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/482/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/482/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/482",
    "id": 1034487425,
    "node_id": "I_kwDOFK7cns49qQaB",
    "number": 482,
    "title": "Рефлексия над pointer-to-member на этапе компиляции",
    "user": {
      "login": "pavelkryukov",
      "id": 11466405,
      "node_id": "MDQ6VXNlcjExNDY2NDA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/11466405?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pavelkryukov",
      "html_url": "https://github.com/pavelkryukov",
      "followers_url": "https://api.github.com/users/pavelkryukov/followers",
      "following_url": "https://api.github.com/users/pavelkryukov/following{/other_user}",
      "gists_url": "https://api.github.com/users/pavelkryukov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pavelkryukov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pavelkryukov/subscriptions",
      "organizations_url": "https://api.github.com/users/pavelkryukov/orgs",
      "repos_url": "https://api.github.com/users/pavelkryukov/repos",
      "events_url": "https://api.github.com/users/pavelkryukov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pavelkryukov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2021-10-24T18:49:24Z",
    "updated_at": "2023-10-22T09:42:28Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "У поля структуры есть три базовых представления:\r\n- порядковый номер в структуре (индекс)\r\n- смещение относительно начала структуры (`offsetof`)\r\n- pointer-to-member\r\n\r\nПреобразование между тремя представлениями сделать сложно. Между первым и вторым конвертирует [Type Loophole](https://github.com/alexpolt/luple), но у этого трюка есть много ограничений, низкая скорость компиляции и т. д. Третье подключить можно, но с ещё большими ухищрениями (https://github.com/boostorg/pfr/issues/60).\r\n\r\nПри этом последнее представление и наиболее полно, и наиболее надёжно реализовано в C++ (и С).\r\nПредлагается считать его основным, и попросить компилятор объявить переменные, через которые определяются все преобразования:\r\n\r\n```c++\r\nnamespace ptm { // pointer-to-member\r\n\r\ntemplate<typename T>\r\nconstexpr size_t number_of_members = $$$;\r\n\r\ntemplate<typename T, typename R, R T::* member>\r\nconstexpr size_t index_of_member = $$$;\r\n\r\ntemplate<typename T, size_t N>\r\nstruct type_of_member { using type = $$$; };\r\n\r\ntemplate<typename T, size_t N, typename R = type_of_member<T, N>::type>\r\nstruct type_of_pointer_to_member { using type = R T::*; }\r\n\r\ntemplate<typename T, size_t N>\r\nconstexpr type_of_pointer_to_member<T, N> pointer_to_member = $$$;\r\n\r\n} // namespace ptm\r\n\r\n```\r\n\r\nВ результате имплементация [Boost.PFR](https://github.com/boostorg/pfr) сильно сократится:\r\n\r\n```c++\r\n\r\nnamespace details {\r\n\r\ntemplate<typename T, int ... N>\r\nauto structure_tie(T& object, std::index_sequence<N...>)\r\n{\r\n    return std::tie(*(object.*ptm::pointer_to_member<T,N>)...);\r\n}\r\n\r\n} // namespace details\r\n\r\ntemplate<typename T>\r\nauto structure_tie(T& object)\r\n{\r\n    return details::structure_tie(object, std::make_index_sequence<ptm::number_of_members<T>>{});\r\n}\r\n\r\n```\r\n\r\nОтсюда же порождается имплементация #468:\r\n\r\n```c++\r\nnamespace details {\r\n\r\ntemplate<typename T, int ... N>\r\nconstexpr auto tuple_of_memptrs(std::index_sequence<N...>)\r\n{\r\n    return std::tuple(ptm::pointer_to_member<T,N>)...);\r\n}\r\n\r\n} // namespace details\r\n\r\ntemplate<typename T>\r\nconstexpr auto tuple_of_memptrs()\r\n{\r\n    return details::tuple_of_memptrs(std::make_index_sequence<ptm::number_of_members<T>>());\r\n}\r\n\r\n```\r\n\r\nНе самым оптимальным образом, но порождается [PR0908](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0908r0.html)\r\n\r\n```c++\r\n\r\nnamespace details {\r\n\r\ntemplate<size_t I, typename T, typename R>\r\nconstexpr auto offsetof_impl(R T::* member)\r\n{\r\n    static_assert(I < ptm::number_of_members<T>);\r\n    if constexpr (!std::is_same_v<R, ptm::type_of_member<T, I>>)\r\n        return offsetof_impl<I + 1>(member);\r\n    else if (ptm::pointer_to_member<T, I> != member)\r\n        return offsetof_impl<I + 1>(member);\r\n    else\r\n        return offsetof(T, ptm::pointer_to_member<T, I>);\r\n}\r\n\r\n} // namespace details\r\n\r\ntemplate<typename T, typename R>\r\nauto offsetof_dynamic(R T::* member)\r\n{\r\n    return details::offsetof_impl<0>(member);\r\n}\r\n\r\n```\r\n\r\n`index_of_member` может быть использован для метапрограммирования нестандартного расположения полей (SoA, упаковка и т. д.)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/482/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/481",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/481/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/481/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/481/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/481",
    "id": 1014598231,
    "node_id": "I_kwDOFK7cns48eYpX",
    "number": 481,
    "title": "Управление квалификаторами методов",
    "user": {
      "login": "infy-infy",
      "id": 42450030,
      "node_id": "MDQ6VXNlcjQyNDUwMDMw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42450030?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/infy-infy",
      "html_url": "https://github.com/infy-infy",
      "followers_url": "https://api.github.com/users/infy-infy/followers",
      "following_url": "https://api.github.com/users/infy-infy/following{/other_user}",
      "gists_url": "https://api.github.com/users/infy-infy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/infy-infy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/infy-infy/subscriptions",
      "organizations_url": "https://api.github.com/users/infy-infy/orgs",
      "repos_url": "https://api.github.com/users/infy-infy/repos",
      "events_url": "https://api.github.com/users/infy-infy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/infy-infy/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-10-03T23:48:08Z",
    "updated_at": "2021-10-17T18:56:26Z",
    "closed_at": "2021-10-17T18:56:26Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "1. Предлагаю введение нового ключевого слова **declqual** для вычисления квалификаторов метода. `declqual(T)` должен \"возвращать\" квалификаторы, принимая на вход тип. Рассмотрим механику работы на следующем примере:\r\n\r\n```\r\ntemplate<typename T>\r\nclass Wrapper\r\n{\r\npublic:\r\n    T get() declqual(T) { return _value;}\r\nprivate:\r\n    T _value;\r\n};\r\n```\r\n\r\nВ данном случае, если T не является ссылкой или является lvalue ссылкой, то квалификатор метода будет `&`. Если T это константная ссылка (строго говоря, тип `const T&` или `const T&&` это ссылка на константный тип, но все привыкли говорить \"константная ссылка\"), то квалификаторы будут, соответственно, `const &` или `const &&.` Если T это rvalue ссылка, то квалификатор будет `&&`.\r\n\r\n2. Выражение `declqual(auto)` будет создавать все варианты квалификаторов по мере того, как компилятор будет натыкаться на очередной вариант использования. На самом деле, юзкейс этого выражения и является основным мотиватором этой идеи: с помощью этого выражения можно будет избавиться от дублирования кода или использования уродливого const_cast в геттерах. Например:\r\n\r\nРаньше:\r\n```\r\nclass Wrapper\r\n{\r\npublic:\r\nauto& get_by_key(std::string_view k, SomeType& def) const {\r\n    if (auto it = _map.find(k); it != _map.end()) {\r\n       return it->second;\r\n    }\r\n    return def;\r\n}\r\n\r\n// Non-const version 1: code duplicate\r\nauto& get_by_key(std::string_view k, SomeType& def) {\r\n    if (auto it = _map.find(k); it != _map.end()) {\r\n       return it->second;\r\n    }\r\n    return def;\r\n}\r\n\r\n// Non-const version 2: ugly const casts\r\nauto& get_by_key(std::string_view k, SomeType& def) {\r\n    auto& result = const_cast<const Wrapper*>(this)->getByKey(k, def);\r\n    return const_cast<SomeType&>(result);\r\n}\r\nprivate:\r\n    std::map<std::string, SomeType, std::less<>> _map;\r\n};\r\n```\r\nСтало\r\n```\r\nclass Wrapper\r\n{\r\npublic:\r\nauto& get_by_key(std::string_view k, SomeType& def) declqual(auto) & {\r\n    if (auto it = _map.find(k); it != _map.end()) {\r\n       return it->second;\r\n    }\r\n    return def;\r\n}\r\nprivate:\r\n    std::map<std::string, SomeType, std::less<>> _map;\r\n};\r\n```\r\n\r\nКак можно заметить, в последнем примере стоит `&` после выражения: я предлагаю оставлять возможность сокращать количество вариаций за счет явного указания квалификаторов после выражение `declqual`. В примере выше это означает, что `get_by_key` может иметь квалификаторы только `const&` или `&` (ну и формально, конечно, варианты с `volatile`). Явное указание может производится либо непосредственной подстановкой руками, либо с помощью того же `declqual`. Например:\r\n\r\n```\r\ntemplate<typename T>\r\nclass Wrapper\r\n{\r\npublic:\r\n    // instead of conditional_t there could be some magical trait that removes cv qualifiers from references\r\n    T get() declqual(auto) declqual(std::conditional_t<std::std::is_rvalue_reference_v<T>, int&&, int&>) { return _value;}\r\nprivate:\r\n    T _value;\r\n};\r\n```\r\nВ данном случае второй declqual говорит о том, что ссылочный квалификатор get() может быть либо && (если T - это rvalue ссылка), либо & (когда тип lvalue ссылка или не ссылка). Поэтому declqual(auto) может варьировать только cv квалификаторы для конкретного класса.\r\n\r\nобъявление `T get() declqual(auto) const volatile &` не должно считаться ошибкой, т.к. в такое может \"вычислиться\" declqual(...) в шаблонном коде. Тогда declqual(auto) тут не будет иметь никакого эффекта, т.к. все квалификаторы указаны явно.\r\n\r\nОднако этого может оказаться недостаточно, если мы хотим явно запрещать cv квалификаторы. По аналогии с consteval предлагаю ввести подобную запись:\r\n`T get() declqual(auto) !volatile &` - это означает, что варьироваться может только const квалификатор, а volatile всегда отсутствует. Разумеется, разрешить подобное только при использовании declqual(auto), чтобы нельзя было обычные методы помечать как !const или !volatile. \r\n\r\nЯ вижу данный инструментарий логичным продолжением функциональности explicit(bool), которая убивает сразу двух зайцев - во-первых, дает возможность управлять квалификаторами методов из шаблонного кода, во-вторых - избавляет язык от проблемы геттеров. \r\nОднако нужно придумать более мощные примеры полезного использования declqual(T), текущие демонстрируют только принцип работы. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/481/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/481/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/480",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/480/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/480/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/480/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/480",
    "id": 1007870288,
    "node_id": "I_kwDOFK7cns48EuFQ",
    "number": 480,
    "title": "Разбить stl классы по headers",
    "user": {
      "login": "olegpublicprofile",
      "id": 74463792,
      "node_id": "MDQ6VXNlcjc0NDYzNzky",
      "avatar_url": "https://avatars.githubusercontent.com/u/74463792?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/olegpublicprofile",
      "html_url": "https://github.com/olegpublicprofile",
      "followers_url": "https://api.github.com/users/olegpublicprofile/followers",
      "following_url": "https://api.github.com/users/olegpublicprofile/following{/other_user}",
      "gists_url": "https://api.github.com/users/olegpublicprofile/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/olegpublicprofile/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/olegpublicprofile/subscriptions",
      "organizations_url": "https://api.github.com/users/olegpublicprofile/orgs",
      "repos_url": "https://api.github.com/users/olegpublicprofile/repos",
      "events_url": "https://api.github.com/users/olegpublicprofile/events{/privacy}",
      "received_events_url": "https://api.github.com/users/olegpublicprofile/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-09-27T08:45:52Z",
    "updated_at": "2021-09-27T14:16:06Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Вместо того, что бы каждый раз искать какой header нужно подключить нужно открывать С++ документацию и смотреть в  каком header находится STL класс. Пример Qt библиотека, там каждый класс в отдельном header и легко понять какой header нужно добавить в include\r\n\r\nНапример :\r\n\r\n- Старый код:\r\n\r\n```cpp\r\n#include <utility>\r\n\r\nint main()\r\n{\r\n\tstd::pair<int, int> pair;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n- Новый код:\r\n\r\n```cpp\r\n#include <pair>\r\n\r\nint main()\r\n{\r\n\tstd::pair<int, int> pair;\r\n\treturn 0;\r\n}\r\n```\r\n\r\nВозможная реализация: https://github.com/olegpublicprofile/stdeasy\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/480/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/480/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/479",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/479/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/479/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/479/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/479",
    "id": 999704106,
    "node_id": "I_kwDOFK7cns47lkYq",
    "number": 479,
    "title": "constexpr- и consteval-классы",
    "user": {
      "login": "Izaron",
      "id": 5406399,
      "node_id": "MDQ6VXNlcjU0MDYzOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5406399?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Izaron",
      "html_url": "https://github.com/Izaron",
      "followers_url": "https://api.github.com/users/Izaron/followers",
      "following_url": "https://api.github.com/users/Izaron/following{/other_user}",
      "gists_url": "https://api.github.com/users/Izaron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Izaron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Izaron/subscriptions",
      "organizations_url": "https://api.github.com/users/Izaron/orgs",
      "repos_url": "https://api.github.com/users/Izaron/repos",
      "events_url": "https://api.github.com/users/Izaron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Izaron/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-09-17T20:38:33Z",
    "updated_at": "2021-09-23T04:54:00Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Посмотрите на любую библиотеку, в которой showcase возможностей constexpr-а:\r\n[frozen](https://github.com/serge-sans-paille/frozen/blob/master/include/frozen/set.h)\r\n[constexpr_all_the_things](https://github.com/lefticus/constexpr_all_the_things/blob/master/src/include/cx_vector.h)\r\n\r\nВозникает стойкое ощущение, что классам/структурам не хватает объявления \"пометь все мои функции как constexpr\" или (начиная с С++20) \"как consteval\". Это может быть важно с модой на constexpr в последнее время.\r\n\r\nПредлагаю иметь возможность объявлять constexpr- и consteval-классы, чтобы запись\r\n```cpp\r\nconstexpr class conststr {  // <<< пометка класса constexpr\r\n    const char* p;\r\n    std::size_t sz;\r\npublic:\r\n    template<std::size_t N>\r\n    conststr(const char(&a)[N]): p(a), sz(N - 1) {}\r\n \r\n    char operator[](std::size_t n) const\r\n    {\r\n        return n < sz ? p[n] : throw std::out_of_range(\"\");\r\n    }\r\n    std::size_t size() const { return sz; }\r\n};\r\n```\r\nбыла эквивалентна\r\n```cpp\r\nclass conststr {\r\n    const char* p;\r\n    std::size_t sz;\r\npublic:\r\n    template<std::size_t N>\r\n    constexpr conststr(const char(&a)[N]): p(a), sz(N - 1) {} // <<< пометка метода constexpr\r\n \r\n    constexpr char operator[](std::size_t n) const // <<< пометка метода constexpr\r\n    {\r\n        return n < sz ? p[n] : throw std::out_of_range(\"\");\r\n    }\r\n    constexpr std::size_t size() const { return sz; } // <<< пометка метода constexpr\r\n};\r\n```\r\nАналогично можно ввести объявление `consteval class conststr`, которое будет семантически отличаться.\r\n\r\nP. S. Надеюсь, эта идея не слишком очевидна, чтобы ее не предложил кто-то другой =)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/479/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/479/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/478",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/478/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/478/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/478/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/478",
    "id": 997555410,
    "node_id": "I_kwDOFK7cns47dXzS",
    "number": 478,
    "title": "Краткий синтаксис для ограничения шаблонных шаблонных аргументов концептами",
    "user": {
      "login": "Mrkol",
      "id": 2286419,
      "node_id": "MDQ6VXNlcjIyODY0MTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2286419?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Mrkol",
      "html_url": "https://github.com/Mrkol",
      "followers_url": "https://api.github.com/users/Mrkol/followers",
      "following_url": "https://api.github.com/users/Mrkol/following{/other_user}",
      "gists_url": "https://api.github.com/users/Mrkol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Mrkol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Mrkol/subscriptions",
      "organizations_url": "https://api.github.com/users/Mrkol/orgs",
      "repos_url": "https://api.github.com/users/Mrkol/repos",
      "events_url": "https://api.github.com/users/Mrkol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Mrkol/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-09-15T22:00:36Z",
    "updated_at": "2021-09-15T22:05:06Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Так сейчас можно:\r\n```cpp\r\ntemplate<class Derived, class Base>\r\nconcept DerivedFrom = std::derived_from<Derived, Base>;\r\n\r\ntemplate<DerivedFrom<NiceClass> T>\r\nvoid foo(T t) { ... }\r\n```\r\nА вот так нельзя:\r\n```cpp\r\ntemplate<template<class...> class Template, class... Ts>\r\nconcept Instantiatible = requires { typename Template<Ts...>; };\r\n\r\n// ошибка: краткий синтаксис работает только с концептами над типами\r\ntemplate<Instantiatible<int, float, bool> Template>\r\nvoid foo(Template<int, float, bool> t) { ... }\r\n```\r\nПример конечно тривиальный, но \"в жизни\" это тоже бывает полезно. При параметризации кода по контейнеру для данных часто нужен любой контейнер, обладающий какими-то свойствами (например любой упорядоченный ассоциативный контейнер). Ещё один юзкейс -- [policy based design](https://en.wikipedia.org/wiki/Modern_C%2B%2B_Design#Policy-based_design), где политики обычно являются шаблонами, удовлетворяющими каким-либо свойствам. В обоих случаях приятнее сразу писать какой именно шаблон нужен, а не дописывать всё повторно в requires-clause.\r\nС ходу в голову не приходит хороших причин, почему для типов этот сахар поддерживается, а для других сущностей -- нет.\r\n\r\nАналогичная ситуация наблюдается и с нетиповыми шаблонными аргументами вроде целых чисел, однако не уверен, что их поддержка имеет практический смысл.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/478/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/478/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/477",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/477/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/477/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/477/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/477",
    "id": 988604358,
    "node_id": "MDU6SXNzdWU5ODg2MDQzNTg=",
    "number": 477,
    "title": "API для ресурсов в С++",
    "user": {
      "login": "Izaron",
      "id": 5406399,
      "node_id": "MDQ6VXNlcjU0MDYzOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5406399?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Izaron",
      "html_url": "https://github.com/Izaron",
      "followers_url": "https://api.github.com/users/Izaron/followers",
      "following_url": "https://api.github.com/users/Izaron/following{/other_user}",
      "gists_url": "https://api.github.com/users/Izaron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Izaron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Izaron/subscriptions",
      "organizations_url": "https://api.github.com/users/Izaron/orgs",
      "repos_url": "https://api.github.com/users/Izaron/repos",
      "events_url": "https://api.github.com/users/Izaron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Izaron/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-09-05T21:40:19Z",
    "updated_at": "2022-02-19T10:52:58Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "### API ресурсов\r\n\r\nИдея в том, чтобы реализовать в C++ понятие \"ресурсов\" (или \"архива\"). API для них будет в условном `std::resources` или `std::archive`.\r\n\r\n\"Ресурс\" - это файл любого расширения (изображения, звук, текст, видео, 3d-модельки, ..., набор байт), который с использованием нового API можно было бы \"вшить\" в исполняемый бинарник приложения (и не только туда, но об этом позже), и не загружать его \"руками\" после старта приложения, откуда-то из внешней директории.\r\n\r\nAPI разбивается на 2 части:\r\n\r\n1. Указание файлов для \"ресурсов\" и настроек по их хранению - compile-time.\r\n2. Обращение к этим файлам - run-time.\r\n\r\nУсловный пример кода по частям:\r\n\r\n1. В неком из `.cpp`-файлов проекта определяется статический объект апишки, который constexpr-ово инициализируется, и куда мы указываем все директории/файлы для зашивания, кодек их сжатия (более мощный уменьшит бинарь, но будет чуть медленнее), и т.д.:\r\n```\r\nstatic constinit const auto resources_holder = std::resources\r\n    ::load_resources({\"images/\", \"models/\", \"license/MIT.txt\"});\r\n```\r\n2. В рантайме можно обращаться к файлам:\r\n```\r\nconst std::span<std::byte> logo = resources_holder.get_resource(\"images/logo.png\");\r\n```\r\n\r\n### Техническая реализация (кратко, отбросив мелочи)\r\nЕсли говорить про большинство Unix-ов: для объектных файлов и бинарей используется формат [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format).\r\nДля хранения ресурсов подходит секция `.rodata`. Эту секцию загрузчик во время старта приложения загружает в read-only режиме и держит в RAM.\r\n\r\nЗначит, в процессе компиляции перед линковкой, объектный файл того `.cpp`, где создается объект из 1 пункта, должен в `.rodata` содержать массив байт - загруженные ресурсы. Отсюда следует, что динамические и статические библиотеки могут являться носителями ресурсов наравне с бинарями.\r\n\r\n### Польза\r\n\r\nБолее быстрый запуск приложений, которые читают всякие файлы при старте. Более cache-friendly по сравнению с файлами, которых загрузили куда попало в кучу. Меньше головной боли для небольших приложений, которые имеют внешние ресурсы.\r\n\r\nML-приложения могут проще обращаться к своим моделькам из RAM.\r\n\r\nОсобенно неплохо будет для игр, где обычно много ресурсов (кроме тех, где они весят суммарно 100гб и то загружаются, то выгружаются из RAM).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/477/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/477/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/476",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/476/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/476/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/476/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/476",
    "id": 978137135,
    "node_id": "MDU6SXNzdWU5NzgxMzcxMzU=",
    "number": 476,
    "title": "Запретить удаление incomplete классов",
    "user": {
      "login": "sergii-rybin-tfs",
      "id": 80316799,
      "node_id": "MDQ6VXNlcjgwMzE2Nzk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/80316799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sergii-rybin-tfs",
      "html_url": "https://github.com/sergii-rybin-tfs",
      "followers_url": "https://api.github.com/users/sergii-rybin-tfs/followers",
      "following_url": "https://api.github.com/users/sergii-rybin-tfs/following{/other_user}",
      "gists_url": "https://api.github.com/users/sergii-rybin-tfs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sergii-rybin-tfs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sergii-rybin-tfs/subscriptions",
      "organizations_url": "https://api.github.com/users/sergii-rybin-tfs/orgs",
      "repos_url": "https://api.github.com/users/sergii-rybin-tfs/repos",
      "events_url": "https://api.github.com/users/sergii-rybin-tfs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sergii-rybin-tfs/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-08-24T14:04:07Z",
    "updated_at": "2021-12-26T12:48:42Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_Запретить удаление incomplete классов_\r\n\r\nClang & G++ выдают варнинг о UB.\r\nVisual Studio компилирует такой код без варнингов.\r\n\r\nСамо поведение компилятора в этой ситуации ставит в тупик большинство специалистов, и часто является нежелательным (из за утечки памяти и ресурсов в агрегатах). А сама ошибка весьма распространена при попытках реализовать pimpl и подобные паттерны (А так же при изменении порядка инклудов).\r\n\r\nБез этой функции, язык будет более предсказуемым и безопасным.\r\n\r\nПолезные ссылки:\r\n* https://en.cppreference.com/w/cpp/language/delete\r\n* https://godbolt.org/z/xKeG3Y1xb\r\n* https://stackoverflow.com/questions/4325154/delete-objects-of-incomplete-type\r\n* https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP57-CPP.+Do+not+cast+or+delete+pointers+to+incomplete+classes\r\n\r\nПример кода:\r\n\r\n```C++\r\nclass a;\r\na* val;\r\nvoid foo()\r\n{\r\n    delete val;\r\n}\r\n\r\nclass a{\r\n    ~a() = delete;\r\n};\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/476/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/476/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/475",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/475/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/475/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/475/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/475",
    "id": 972050809,
    "node_id": "MDU6SXNzdWU5NzIwNTA4MDk=",
    "number": 475,
    "title": "Убрать некоторые перегрузки для `std::array` с нулевым размером",
    "user": {
      "login": "unterumarmung",
      "id": 39276703,
      "node_id": "MDQ6VXNlcjM5Mjc2NzAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39276703?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/unterumarmung",
      "html_url": "https://github.com/unterumarmung",
      "followers_url": "https://api.github.com/users/unterumarmung/followers",
      "following_url": "https://api.github.com/users/unterumarmung/following{/other_user}",
      "gists_url": "https://api.github.com/users/unterumarmung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/unterumarmung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/unterumarmung/subscriptions",
      "organizations_url": "https://api.github.com/users/unterumarmung/orgs",
      "repos_url": "https://api.github.com/users/unterumarmung/repos",
      "events_url": "https://api.github.com/users/unterumarmung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/unterumarmung/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 7,
    "created_at": "2021-08-16T19:51:34Z",
    "updated_at": "2021-09-05T19:54:48Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В текущем варианте функции `front`, `back`, `operator[]` имеют неопределенное поведение, если `array.size() == 0`.\r\nДанное решение видимо было сделано, чтобы специализации `std::array<T, 0>` удовлетворяли требованию [`SequenceContainer`](https://en.cppreference.com/w/cpp/named_req/SequenceContainer). Но точно ли массив нулевого размера является sequence container? Тем более, на cppreference указано, что для `std::array` есть исключения.\r\n\r\nУдаление перегрузок данных перегрузок имеет два преимущества:\r\n* Убирается UB там, где это легко и удобно заменяется ошибкой компиляции, как для реализаций стандартной библиотеки, так и для её пользователей.\r\n* Данные функции можно сделать `noexcept`, так как в них больше нет UB.\r\n\r\nНедостаток один:\r\n* Специализации `std::array<T, 0>` перестают удовлетворять требованию `SequenceContainer`. Кажется, это не является большой потерей.\r\n\r\nПсевдокод реализации:\r\n\r\n```cpp\r\ntemplate <typename T, size_t N>\r\nstruct array\r\n{\r\n...\r\n    reference front() noexcept requires N != 0;\r\n    const_reference front() const noexcept requires N != 0;\r\n    reference back() noexcept requires N != 0;\r\n    const_reference back() const noexcept requires N != 0;\r\n    reference operator[](size_type pos) noexcept requires N != 0;\r\n    const_reference operator[](size_type pos) const noexcept requires N != 0;\r\n...\r\n};\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/475/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/475/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/474",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/474/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/474/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/474/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/474",
    "id": 969717622,
    "node_id": "MDU6SXNzdWU5Njk3MTc2MjI=",
    "number": 474,
    "title": "Упрощение синтаксиса захвата лямбда функций ",
    "user": {
      "login": "AI-Decay",
      "id": 55590011,
      "node_id": "MDQ6VXNlcjU1NTkwMDEx",
      "avatar_url": "https://avatars.githubusercontent.com/u/55590011?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AI-Decay",
      "html_url": "https://github.com/AI-Decay",
      "followers_url": "https://api.github.com/users/AI-Decay/followers",
      "following_url": "https://api.github.com/users/AI-Decay/following{/other_user}",
      "gists_url": "https://api.github.com/users/AI-Decay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AI-Decay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AI-Decay/subscriptions",
      "organizations_url": "https://api.github.com/users/AI-Decay/orgs",
      "repos_url": "https://api.github.com/users/AI-Decay/repos",
      "events_url": "https://api.github.com/users/AI-Decay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AI-Decay/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 12,
    "created_at": "2021-08-12T23:00:11Z",
    "updated_at": "2021-10-03T23:14:49Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Описание идеи\r\n\r\nВ С++ мы имеем:\r\n```\r\nint variable = 0; \r\nauto a = [variable]() {} - Захват по значению\r\nauto a = [&variable]() {} - Захват по ссылке \r\nauto a = [variable = std::move(variable)]() {} - Но для захвата с перемещением \r\nнеобходимо использовать синтаксис с переименованием \r\n```\r\n\r\nПредлагаю для простоты и однородности использовать подобный синтаксис:\r\n`auto a = [&&variable]() {} // тождественно равно auto a = [variable = std::move(variable)]() {}\r\n`\r\n\r\n\r\nПример использования:\r\n```\r\n\r\nint main() {\r\n\r\n    auto enableButtons = [](bool enabled) {\r\n\r\n    };\r\n\r\n    auto callback = [&&enableButtons]() {\r\n        enableButtons(true);\r\n    };\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/474/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/474/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/473",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/473/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/473/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/473/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/473",
    "id": 963503212,
    "node_id": "MDU6SXNzdWU5NjM1MDMyMTI=",
    "number": 473,
    "title": "Модуляризация Стандартной библиотеки: сделать стандартный модуль для стектрейса",
    "user": {
      "login": "leha-bot",
      "id": 10153298,
      "node_id": "MDQ6VXNlcjEwMTUzMjk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/10153298?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leha-bot",
      "html_url": "https://github.com/leha-bot",
      "followers_url": "https://api.github.com/users/leha-bot/followers",
      "following_url": "https://api.github.com/users/leha-bot/following{/other_user}",
      "gists_url": "https://api.github.com/users/leha-bot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leha-bot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leha-bot/subscriptions",
      "organizations_url": "https://api.github.com/users/leha-bot/orgs",
      "repos_url": "https://api.github.com/users/leha-bot/repos",
      "events_url": "https://api.github.com/users/leha-bot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leha-bot/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-08-08T19:51:55Z",
    "updated_at": "2021-08-08T19:51:55Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "# Описание идеи\r\nВ рамках глобальной цели, поставленной Комитетом по модуляризации и по принципу \"не платишь за то, что не надо\" предлагаю сделать стандартное имя модуля для стектрейса как `std.stacktrace`.\r\n\r\nЭто поможет тем, кому будет слишком тяжело таскать информацию о стектрейсе, и реализаторам Стандартной Библиотеки, т.к. они могут инкапсулировать реализации получения стектрейса в \"Разделы Модулей\", например, `std.stacktrace:libunwind` - реализация получения стектрейса с помощью `libunwind`,\r\n`std.stacktrace:noop` - реализация-заглушка.\r\n\r\n\r\n# Код с реализацией идеи\r\n\r\nБудет тут: github.com/leha-bot/STL  , ветка `feature/stacktrace`",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/473/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/473/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/472",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/472/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/472/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/472/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/472",
    "id": 963287704,
    "node_id": "MDU6SXNzdWU5NjMyODc3MDQ=",
    "number": 472,
    "title": "Сохранение/переключения контекста выполнения",
    "user": {
      "login": "night-beast",
      "id": 26147018,
      "node_id": "MDQ6VXNlcjI2MTQ3MDE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26147018?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/night-beast",
      "html_url": "https://github.com/night-beast",
      "followers_url": "https://api.github.com/users/night-beast/followers",
      "following_url": "https://api.github.com/users/night-beast/following{/other_user}",
      "gists_url": "https://api.github.com/users/night-beast/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/night-beast/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/night-beast/subscriptions",
      "organizations_url": "https://api.github.com/users/night-beast/orgs",
      "repos_url": "https://api.github.com/users/night-beast/repos",
      "events_url": "https://api.github.com/users/night-beast/events{/privacy}",
      "received_events_url": "https://api.github.com/users/night-beast/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-08-07T19:13:08Z",
    "updated_at": "2023-11-21T11:28:00Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Для реализации stackful корутин нужно иметь возможность сохранять/переключать контекст выполнения.\r\n\r\nВ POSIX для этого были функции makecontext/swapcontext но на текущий момент они deprecated\r\nЕсть реализация под Unix https://github.com/kaniini/libucontext, а так же платформонезависимая реализация в Boost.context\r\n\r\nХотелось бы иметь такую базовую вещь в стандарте\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/472/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/472/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/471",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/471/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/471/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/471/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/471",
    "id": 957555686,
    "node_id": "MDU6SXNzdWU5NTc1NTU2ODY=",
    "number": 471,
    "title": "Концепты в объявлении класса ",
    "user": {
      "login": "kol65536black",
      "id": 6318365,
      "node_id": "MDQ6VXNlcjYzMTgzNjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6318365?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kol65536black",
      "html_url": "https://github.com/kol65536black",
      "followers_url": "https://api.github.com/users/kol65536black/followers",
      "following_url": "https://api.github.com/users/kol65536black/following{/other_user}",
      "gists_url": "https://api.github.com/users/kol65536black/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kol65536black/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kol65536black/subscriptions",
      "organizations_url": "https://api.github.com/users/kol65536black/orgs",
      "repos_url": "https://api.github.com/users/kol65536black/repos",
      "events_url": "https://api.github.com/users/kol65536black/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kol65536black/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-08-01T18:23:11Z",
    "updated_at": "2021-08-01T21:29:27Z",
    "closed_at": "2021-08-01T19:04:48Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Есть предложение добавить возможность прописывать концепты в месте где прописываем наследование.\r\n```c++\r\nclass SomeClass : public SomeParent1, SomeConcept1, SomeConcept2\r\n```\r\nПри этом подразумевается, что компилятор должен проверить класс требованиям концепта. Если не соответствует концепту, то код не компилируется.\r\n\r\nТак же думаю, был бы полезен способ описывать концепт в стиле трейтов или тайпклассов. Т.е. указать, что должны быть функции или поля с определенными именами.\r\nПример:\r\n```c++\r\ntemplate<typename T>\r\nconcept class SomeConcept1\r\n{\r\npublic:\r\n     void add(T& item);           //требование, что класс должен иметь метод с названием add с соответствующей  сигнатурой\r\n     void remove(T& item);     //требование, что класс должен иметь метод с названием remove с соответствующей  сигнатурой\r\n};\r\n```\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/471/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/470",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/470/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/470/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/470/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/470",
    "id": 952254058,
    "node_id": "MDU6SXNzdWU5NTIyNTQwNTg=",
    "number": 470,
    "title": "Float16 как builtin тип",
    "user": {
      "login": "ilnurkh",
      "id": 22670232,
      "node_id": "MDQ6VXNlcjIyNjcwMjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/22670232?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ilnurkh",
      "html_url": "https://github.com/ilnurkh",
      "followers_url": "https://api.github.com/users/ilnurkh/followers",
      "following_url": "https://api.github.com/users/ilnurkh/following{/other_user}",
      "gists_url": "https://api.github.com/users/ilnurkh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ilnurkh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ilnurkh/subscriptions",
      "organizations_url": "https://api.github.com/users/ilnurkh/orgs",
      "repos_url": "https://api.github.com/users/ilnurkh/repos",
      "events_url": "https://api.github.com/users/ilnurkh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ilnurkh/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-07-25T11:27:06Z",
    "updated_at": "2022-08-11T11:42:14Z",
    "closed_at": "2022-08-11T11:38:28Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nСделать поддержку этого типа в языке.\r\nОтдельно стоит прописать неоднозначность операций. (можно поднимать до fp32 и после операции опускать назад, а можно так не делеть. Можно делать так для цепочки операций, а можно делать усечение после каждой). В общем сложностей много, надо начать с этим как-то работать.\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nВесь нейроночный ml на нём. Пора уже и поддержать\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\nhttps://github.com/catboost/catboost/tree/master/library/cpp/float16\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/470/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/470/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/469",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/469/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/469/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/469/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/469",
    "id": 952246981,
    "node_id": "MDU6SXNzdWU5NTIyNDY5ODE=",
    "number": 469,
    "title": "Поддержка run-time-cpu-dispatch",
    "user": {
      "login": "ilnurkh",
      "id": 22670232,
      "node_id": "MDQ6VXNlcjIyNjcwMjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/22670232?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ilnurkh",
      "html_url": "https://github.com/ilnurkh",
      "followers_url": "https://api.github.com/users/ilnurkh/followers",
      "following_url": "https://api.github.com/users/ilnurkh/following{/other_user}",
      "gists_url": "https://api.github.com/users/ilnurkh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ilnurkh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ilnurkh/subscriptions",
      "organizations_url": "https://api.github.com/users/ilnurkh/orgs",
      "repos_url": "https://api.github.com/users/ilnurkh/repos",
      "events_url": "https://api.github.com/users/ilnurkh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ilnurkh/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-07-25T10:44:23Z",
    "updated_at": "2021-07-25T10:44:23Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nЕсть проблема - что сложно делать несколько реализаций (напирмер под sse-vs-avx) одной и той же функции.\r\nБыло бы здорово уметь сказать комплияторо-линковщику:\r\n1. есть определяемая на старте функция\r\n2. вот список реализаций\r\n3. вот эта функция на старте (либо лениво?) выберет конечную реализацию\r\n\r\nГлавное что хочется - чтобы вызывающий код вызывал фиксированный символ, а указатель туда бы подставился прозрачно. Цель - минимизация расходов на runtim-cpu-dispatching\r\n\r\nЗаодно это поднимает вопрос чтобы в стандарте появились какие-нибудь  std::cpu::have_avx512() а так constexpr варианты, а также функции или макросы std::cpu::can_have_avx512() (означает что запуск возможен на платформе с этим флагом), при std::cpu::can_have_avx512() == false гарантируется что ни один translation-unit не будет собран с -mavx512\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nВезде будет полезна\r\n\r\n_<Код c реализацией вашей идеи, если есть>_\r\n\r\n\r\nПолезные ссылки:\r\n* https://quick-bench.com/ - онлайн бенчмарк, поможет вам продемонстрировать эффективность вашего подхода\r\n* https://godbolt.org/ - онлайн дизассемблер\r\n* https://eel.is/c++draft/ - черновик стандарта C++ с возможностью ссылаться на конкретные параграфы\r\n* https://wg21.link/ - универсальная ссылка на международные proposal или баги в С++, например https://wg21.link/P1000 ссылается на документ P1000, а https://wg21.link/cwg100 на 100 баг в ядре языка\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/469/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/469/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/468",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/468/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/468/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/468/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/468",
    "id": 949027755,
    "node_id": "MDU6SXNzdWU5NDkwMjc3NTU=",
    "number": 468,
    "title": "Structured bindings for member pointers",
    "user": {
      "login": "denzor200",
      "id": 16864786,
      "node_id": "MDQ6VXNlcjE2ODY0Nzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/16864786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/denzor200",
      "html_url": "https://github.com/denzor200",
      "followers_url": "https://api.github.com/users/denzor200/followers",
      "following_url": "https://api.github.com/users/denzor200/following{/other_user}",
      "gists_url": "https://api.github.com/users/denzor200/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/denzor200/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/denzor200/subscriptions",
      "organizations_url": "https://api.github.com/users/denzor200/orgs",
      "repos_url": "https://api.github.com/users/denzor200/repos",
      "events_url": "https://api.github.com/users/denzor200/events{/privacy}",
      "received_events_url": "https://api.github.com/users/denzor200/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-07-20T19:58:37Z",
    "updated_at": "2021-11-19T06:35:10Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Нынешний Structured bindings позволяет нам извлекать ссылки на поля агрегата, при условии что нам известен размер агрегата.\r\nПредлагаю дополнительно добавить возможность извлекать member pointers на поля агрегата. Каким я вижу новый синтаксис: \r\n```\r\nstruct Aggregate\r\n{\r\n\tint first;\r\n\tchar second;\r\n\tdouble third;\r\n};\r\n\r\nauto [first_memptr, second_memptr, third_memptr] = &Aggregate::;\r\n\r\nauto obj = Aggregate{};\r\n\r\nobj.*first_memptr = 100;\r\nobj.*second_memptr = 'c';\r\nobj.*third_memptr = 3.14;\r\n\r\nstd::cout << obj.first << \" \" << obj.second << \" \" << obj.third << std::endl; ///< will print \"100 c 3.14\"\r\n```\r\n\r\nИзвлеченные member pointers могут быть constexpr\r\n```\r\nconstexpr auto tuple_of_memptrs() noexcept {\r\n  auto [first_memptr, second_memptr, third_memptr] = &Aggregate::;\r\n  return std::tuple{first_memptr, second_memptr, third_memptr};\r\n}\r\n\r\nconstexpr auto memptrs = tuple_of_memptrs();\r\n```\r\n\r\nТак же не забываем, что у некоторых агрегатов не может быть member pointers(например, при наличии битовых полей). В таких случаях придется выдавать ошибку компиляции.\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/468/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/467",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/467/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/467/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/467/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/467",
    "id": 947581829,
    "node_id": "MDU6SXNzdWU5NDc1ODE4Mjk=",
    "number": 467,
    "title": "Добавить значение \"успех\" в errc ",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-07-19T12:03:39Z",
    "updated_at": "2023-06-30T20:50:16Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Необходимо дабавить значение std::errc:success.\r\nИспользовать enum class для кода возврата и считать что успех это дефолтно сконструированный enum который содержит значение не перечисленное в обьявлении помоему шизофрения. (Да и выглядит не очень)\r\n\r\nПример из  https://en.cppreference.com/w/cpp/utility/to_chars\r\n```\r\nint main()\r\n{\r\n    std::array<char, 10> str;\r\n \r\n    if(auto [ptr, ec] = std::to_chars(str.data(), str.data() + str.size(), 42);\r\n       ec == std::errc())\r\n         std::cout << std::string_view\r\n           (str.data(), ptr);              // C++20, uses string_view(first, last)\r\n      //   (str.data(), ptr - str.data()); // C++17, uses string_view(ptr, length)\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/467/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/467/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/466",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/466/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/466/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/466/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/466",
    "id": 946041698,
    "node_id": "MDU6SXNzdWU5NDYwNDE2OTg=",
    "number": 466,
    "title": "Добавить метод \"split\" в класс std::string",
    "user": {
      "login": "aburmagin",
      "id": 83090480,
      "node_id": "MDQ6VXNlcjgzMDkwNDgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/83090480?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aburmagin",
      "html_url": "https://github.com/aburmagin",
      "followers_url": "https://api.github.com/users/aburmagin/followers",
      "following_url": "https://api.github.com/users/aburmagin/following{/other_user}",
      "gists_url": "https://api.github.com/users/aburmagin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aburmagin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aburmagin/subscriptions",
      "organizations_url": "https://api.github.com/users/aburmagin/orgs",
      "repos_url": "https://api.github.com/users/aburmagin/repos",
      "events_url": "https://api.github.com/users/aburmagin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aburmagin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-07-16T07:58:50Z",
    "updated_at": "2022-02-22T22:44:49Z",
    "closed_at": "2022-02-22T19:37:17Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Во множестве языков, таких как \r\n\r\nJava: \r\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#split(java.lang.String)\r\n\r\nC#:\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.string.split?view=net-5.0#System_String_Split_System_Char___\r\n\r\nPython:\r\nhttps://docs.python.org/3/library/stdtypes.html#str.split\r\n\r\nRust:\r\nhttps://doc.rust-lang.org/std/primitive.str.html#method.split\r\n\r\nGo: \r\nhttps://pkg.go.dev/strings#Split\r\n\r\nуже есть метод, позволяющий разделить строку на подстроки с использованием разделителя (сепаратора)\r\n\r\nОчень хотелось бы видеть такой же метод в классе строки языка C++.\r\n\r\nИдея будет полезна в большом числе случаев, учитывая то, что это достаточно популярная задача.\r\n\r\nНа данный момент для её решения используется множество разных способов, выглядящих громоздко:\r\nhttps://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c\r\n\r\nМетод принимает один параметр - разделитель, тип которого - char или std::string.\r\n\r\nПример использования:\r\n\r\n```\r\n#include <string>\r\n\r\nint main(){\r\nstd::string string = \"foo,bar,baz\";\r\nstd::vector<std::string> tokens = string.split(',');\r\n\r\nfor (const auto& token: tokens)\r\n    std::cout << token << std::endl;\r\n\r\nreturn 0;\r\n}\r\n```\r\n\r\n```\r\nOutput:\r\nfoo\r\nbar\r\nbaz\r\n\r\n```\r\n\r\nВ случае невозможности разделения строки можно кидать исключение, либо придумать другой способ обработки ошибки.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/466/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/466/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/465",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/465/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/465/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/465/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/465",
    "id": 946002449,
    "node_id": "MDU6SXNzdWU5NDYwMDI0NDk=",
    "number": 465,
    "title": "Частичное описание структуры/класса (только методы, не обязательно все)",
    "user": {
      "login": "osheter",
      "id": 87515424,
      "node_id": "MDQ6VXNlcjg3NTE1NDI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/87515424?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/osheter",
      "html_url": "https://github.com/osheter",
      "followers_url": "https://api.github.com/users/osheter/followers",
      "following_url": "https://api.github.com/users/osheter/following{/other_user}",
      "gists_url": "https://api.github.com/users/osheter/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/osheter/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/osheter/subscriptions",
      "organizations_url": "https://api.github.com/users/osheter/orgs",
      "repos_url": "https://api.github.com/users/osheter/repos",
      "events_url": "https://api.github.com/users/osheter/events{/privacy}",
      "received_events_url": "https://api.github.com/users/osheter/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-07-16T06:58:42Z",
    "updated_at": "2021-07-16T08:09:46Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Компилятор C++ позволяет объявить имя типа без его полного описания (т.н. предварительное объявление). В дальнейшем это имя можно использовать в виде ссылки или указателя на тип. Если же переменная или поле данного типа используется для вызова метода, то в этой точке требуется иметь полное описание типа. Такое ограничение во многих случаях является избыточным, например если метод не виртуальный или даже статический.\r\n\r\nЧастичное предварительное описание методов типа позволит, там где это возможно, значительно улучшить читабельность кода, скрыть многие детали реализации, убрав их из заголовочных файлов и даже, в некоторых случаях, сократить время компиляции.\r\n\r\nСокрытие деталей реализации в C++ сегодня производится либо с помошью PIMPL либо введением интерфейсов. Интерфейсы наиболее близки частичному описанию, но все же их основная цель - это дать описание абстрактного интерфейса, который затем реализуется как правило группой нескольких различных классов. Если же класс только один, то выделение его публичных методов в отдельный интерфейс - это излишнее переусложнение. Мое предложение частичного описания класса упрощает данный подход, позволяя обходиться только одним именем класса.\r\n\r\nКонкретный синтаксис данной идеи может быть реализован с помощью extern или введением нового зарезервированного слова partial или forward (partial class, like in C#) или с помощью атрибута [[partial]] перед class/struct.\r\n\r\nПример использования:\r\n\r\n```\r\n// .h file \r\nextern struct worker\r\n{\r\n  void work();\r\n};\r\n\r\ninline void do_work(worker& w)\r\n{\r\n  w.work();\r\n}\r\n```\r\n\r\n```\r\n// .cpp file\r\nstruct worker\r\n{\r\n  void work(); // optional declaration\r\nprivate:\r\n  int x=0;\r\n};\r\n\r\nvoid worker::work() \r\n{\r\n  x++;\r\n}\r\n```\r\n\r\nДругой способ (менее удобный на мой взгляд) это разрешить объявлять только заголовок метода:\r\n```\r\nclass foo;\r\nvoid foo::bar() const; // is it automatically public?\r\nstatic foo::bar2();\r\n```\r\n\r\nДолжно ли частичное описание класса затем повторяться в полном описании? Скорее всего не обязательно, хотя дублирование описаний не запрещено.\r\nВозможно ли существование класса на основании только частичных описаний? Наверное нет, потому что, если частичного описания достаточно, то зачем объявлять его частичным?\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/465/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/465/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/464",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/464/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/464/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/464/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/464",
    "id": 938308480,
    "node_id": "MDU6SXNzdWU5MzgzMDg0ODA=",
    "number": 464,
    "title": "Добавит   возможности вызвать лямбду рекурсивно сам себя",
    "user": {
      "login": "raidenluikang",
      "id": 24319853,
      "node_id": "MDQ6VXNlcjI0MzE5ODUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/24319853?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raidenluikang",
      "html_url": "https://github.com/raidenluikang",
      "followers_url": "https://api.github.com/users/raidenluikang/followers",
      "following_url": "https://api.github.com/users/raidenluikang/following{/other_user}",
      "gists_url": "https://api.github.com/users/raidenluikang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raidenluikang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raidenluikang/subscriptions",
      "organizations_url": "https://api.github.com/users/raidenluikang/orgs",
      "repos_url": "https://api.github.com/users/raidenluikang/repos",
      "events_url": "https://api.github.com/users/raidenluikang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raidenluikang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-07-06T22:30:05Z",
    "updated_at": "2021-10-17T18:57:50Z",
    "closed_at": "2021-10-17T18:57:50Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Сейчас лямбду нельзя вызвать сам себя. Для этого иногда придумывает разные хитрости, который не очень то элегантный.\r\nНапример\r\n\r\n```\r\nstd::function< int (int ) > factorial = [&] (int n) -> int\r\n{\r\n     if (n < 2) return 1;\r\n     else return factorial(n-1) * n;\r\n};\r\n\r\n// usage\r\n  factorial(10);\r\n\r\n\r\n```\r\nлибо, такой\r\n```\r\n\r\n   auto factorial = [](auto self,  int n) -> int\r\n{\r\n      if (n < 2) return 1;\r\n     else return self( self, n - 1) * n ;\r\n};\r\n\r\n\r\n// usage:\r\n factorial(  factorial,  10);\r\n\r\n```\r\n\r\nМожет быть есть ещё другие приёмы, но все они не так элегантно и просто, как вызвать рекурсивной функцией, либо есть накладной расходы как `std::function`.\r\n\r\nДва типа решение могу предлагать:\r\n1. Добавить ключегого слово `self`   или `this_ptr`  тому подобное внутри лямбда.\r\n2. Захватить   название лямбда по умолчание.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/464/reactions",
      "total_count": 4,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/464/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/463",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/463/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/463/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/463/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/463",
    "id": 936494419,
    "node_id": "MDU6SXNzdWU5MzY0OTQ0MTk=",
    "number": 463,
    "title": "добавить функцию exception_type(p) для std::exception_ptr",
    "user": {
      "login": "gleb-kov",
      "id": 41119563,
      "node_id": "MDQ6VXNlcjQxMTE5NTYz",
      "avatar_url": "https://avatars.githubusercontent.com/u/41119563?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gleb-kov",
      "html_url": "https://github.com/gleb-kov",
      "followers_url": "https://api.github.com/users/gleb-kov/followers",
      "following_url": "https://api.github.com/users/gleb-kov/following{/other_user}",
      "gists_url": "https://api.github.com/users/gleb-kov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gleb-kov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gleb-kov/subscriptions",
      "organizations_url": "https://api.github.com/users/gleb-kov/orgs",
      "repos_url": "https://api.github.com/users/gleb-kov/repos",
      "events_url": "https://api.github.com/users/gleb-kov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gleb-kov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-07-04T16:31:57Z",
    "updated_at": "2021-08-08T12:36:23Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nХочется знать информацию о типе исключения из std::exception_ptr. \r\n\r\nНапример, с помощью функции с сигнатурой:\r\n`std::type_info* exception_type(std::exception_ptr)`\r\n\r\nСмотрелось бы лучше как метод у std::exception_ptr, возвращающий const std::type_info&, но тип std::exception_ptr не специфирован.\r\n\r\nНечто похожее: __cxa_current_exception_type\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nЛоггирование и дебаг\r\n```\r\ntry {\r\n  ...\r\n} catch(...) {\r\n  std::cerr << \"Caught exception \" << std::exception_type(std::current_exception())->name() << \", exit.\";\r\n  // или std::current_exception()->type().name()\r\n  ...\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/463/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/463/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/462",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/462/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/462/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/462/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/462",
    "id": 926482934,
    "node_id": "MDU6SXNzdWU5MjY0ODI5MzQ=",
    "number": 462,
    "title": "добавить логический оператор XOR (исключающее ИЛИ)",
    "user": {
      "login": "toughengineer",
      "id": 20643126,
      "node_id": "MDQ6VXNlcjIwNjQzMTI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/20643126?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toughengineer",
      "html_url": "https://github.com/toughengineer",
      "followers_url": "https://api.github.com/users/toughengineer/followers",
      "following_url": "https://api.github.com/users/toughengineer/following{/other_user}",
      "gists_url": "https://api.github.com/users/toughengineer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toughengineer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toughengineer/subscriptions",
      "organizations_url": "https://api.github.com/users/toughengineer/orgs",
      "repos_url": "https://api.github.com/users/toughengineer/repos",
      "events_url": "https://api.github.com/users/toughengineer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toughengineer/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-06-21T18:27:29Z",
    "updated_at": "2022-01-19T19:51:14Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Сабж.  \r\nПредлагаю символ `^^` по модели остальных оперторов: `&` и `&&`, `|` и `||`.\r\n\r\nДля булевых аргументов в качестве исключающего ИЛИ работает `!=`, например:\r\n```c++\r\nconst bool smart = isSmart();\r\nconst bool handsome = isHandsome();\r\nconst bool isPossible = smart != handsom;\r\n```\r\n\r\nНо всё равно в этом случае читаемость ниже плинтуса и парсинг физического смысла такого выражения будет не мгновенным.\r\n\r\nДля типов кроме булева всё ещё грустнее, потому что `!=` в отличие от логических операторов не делает контекстного преобразования в булев тип. Например, такое:\r\n```c++\r\nint i = 42;\r\nvoid *ptr = nullptr;\r\nconst auto sadsob = i != ptr; // не работает\r\nconst auto visibledisgust = !!i != !!ptr; // *sigh*\r\n```\r\n\r\nС логическим исключающим ИЛИ имхо выглядит намного лучше:\r\n```c++\r\nint i = 42;\r\nvoid *ptr = nullptr;\r\nconst auto uwu = i ^^ ptr;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/462/reactions",
      "total_count": 8,
      "+1": 6,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 1,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/462/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/461",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/461/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/461/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/461/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/461",
    "id": 923764952,
    "node_id": "MDU6SXNzdWU5MjM3NjQ5NTI=",
    "number": 461,
    "title": "std::format - позволить указывать переменные для подстановки прямо внутри строки",
    "user": {
      "login": "Aegel5",
      "id": 10333681,
      "node_id": "MDQ6VXNlcjEwMzMzNjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/10333681?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Aegel5",
      "html_url": "https://github.com/Aegel5",
      "followers_url": "https://api.github.com/users/Aegel5/followers",
      "following_url": "https://api.github.com/users/Aegel5/following{/other_user}",
      "gists_url": "https://api.github.com/users/Aegel5/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Aegel5/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Aegel5/subscriptions",
      "organizations_url": "https://api.github.com/users/Aegel5/orgs",
      "repos_url": "https://api.github.com/users/Aegel5/repos",
      "events_url": "https://api.github.com/users/Aegel5/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Aegel5/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 7,
    "created_at": "2021-06-17T10:34:20Z",
    "updated_at": "2021-07-30T22:12:53Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Такой формат уже реализован в С#, пример:\r\n```\r\nint a = 10;\r\nint b = 20;\r\nvar res = $\"Vars: a={a}, b={b}!\";\r\n```\r\nИ это невероятно удобный инструмент. Я не понимаю, почему другие языки не реализовывают подобный функционал.\r\n\r\nКак конкретно реализовать это в С++ я не знаю, возможно тоже добавить `$` перед строкой:\r\n```\r\nint a = 10;\r\nint b = 20;\r\nauto res = $\"Vars: a={a}, b={b}!\";\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/461/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/461/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/460",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/460/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/460/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/460/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/460",
    "id": 907340951,
    "node_id": "MDU6SXNzdWU5MDczNDA5NTE=",
    "number": 460,
    "title": "basic_string_view noexcept",
    "user": {
      "login": "NN---",
      "id": 580536,
      "node_id": "MDQ6VXNlcjU4MDUzNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/580536?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NN---",
      "html_url": "https://github.com/NN---",
      "followers_url": "https://api.github.com/users/NN---/followers",
      "following_url": "https://api.github.com/users/NN---/following{/other_user}",
      "gists_url": "https://api.github.com/users/NN---/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NN---/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NN---/subscriptions",
      "organizations_url": "https://api.github.com/users/NN---/orgs",
      "repos_url": "https://api.github.com/users/NN---/repos",
      "events_url": "https://api.github.com/users/NN---/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NN---/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-05-31T10:29:49Z",
    "updated_at": "2021-06-07T07:53:45Z",
    "closed_at": "2021-06-07T07:53:44Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_<Описание вашей идеи>_\r\nКак известно конструктор basic_string_view , а также remove_prefix не являются noexcept.\r\nНет никаких причин, кроме исторических, не объявить их как noexcept.\r\nВ принципе весь класс мог бы быть noexcept.\r\n\r\n_<Примеры, где ваша идея будет полезна. Чем больше примеров и чем большую аудиторию они охватывают - тем лучше>_\r\nПолезность noexcept в местах без исключений вполне очевидна.\r\nПолучаем больше оптимизаций от компилятора.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/460/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/460/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/459",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/459/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/459/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/459/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/459",
    "id": 904998751,
    "node_id": "MDU6SXNzdWU5MDQ5OTg3NTE=",
    "number": 459,
    "title": "for для нескольких контейнеров",
    "user": {
      "login": "XRay3D",
      "id": 10693876,
      "node_id": "MDQ6VXNlcjEwNjkzODc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10693876?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/XRay3D",
      "html_url": "https://github.com/XRay3D",
      "followers_url": "https://api.github.com/users/XRay3D/followers",
      "following_url": "https://api.github.com/users/XRay3D/following{/other_user}",
      "gists_url": "https://api.github.com/users/XRay3D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/XRay3D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/XRay3D/subscriptions",
      "organizations_url": "https://api.github.com/users/XRay3D/orgs",
      "repos_url": "https://api.github.com/users/XRay3D/repos",
      "events_url": "https://api.github.com/users/XRay3D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/XRay3D/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2021-05-28T09:04:02Z",
    "updated_at": "2021-10-17T19:01:56Z",
    "closed_at": "2021-10-17T19:01:45Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Вместо классического цикла с переменной ++i доработать range based for для нескольких контейнеров и соответственно итерироваться до границ наименьшего из них.\r\n\r\nEсли переданы std::array или обычные массивы фиксированной длины размеры которых не равны выдавать варнинг времени компиляции.\r\n\r\nБыло:\r\n``` c++\r\nvoid MeasureModel::setRowsEnabled(const std::vector<Qt::CheckState>& checkStates) {\r\n    for (int i = 0; i < RowCount; ++i) {\r\n        if(m_rowEnabled[i] != checkStates[i]) {\r\n            m_rowEnabled[i] = checkStates[i];\r\n            emit dataChanged();\r\n        }\r\n    }\r\n}\r\n``` \r\nстало\r\n``` c++\r\nvoid MeasureModel::setRowsEnabled(const std::vector<Qt::CheckState>& checkStates)\r\n{\r\n    for (auto& checkStateDst, auto checkStateSrc : m_rowEnabled, checkStates) {\r\n        if (checkStateDst != checkStateSrc) {\r\n            checkStateDst = checkStateSrc;\r\n            emit dataChanged();\r\n        }\r\n    }\r\n}\r\n``` \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/459/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/459/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/458",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/458/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/458/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/458/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/458",
    "id": 894718427,
    "node_id": "MDU6SXNzdWU4OTQ3MTg0Mjc=",
    "number": 458,
    "title": "Конструктор стандартных контейнеров от итераторов разного типа и Ranges",
    "user": {
      "login": "kirillgrachoff",
      "id": 35011824,
      "node_id": "MDQ6VXNlcjM1MDExODI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35011824?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirillgrachoff",
      "html_url": "https://github.com/kirillgrachoff",
      "followers_url": "https://api.github.com/users/kirillgrachoff/followers",
      "following_url": "https://api.github.com/users/kirillgrachoff/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirillgrachoff/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirillgrachoff/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirillgrachoff/subscriptions",
      "organizations_url": "https://api.github.com/users/kirillgrachoff/orgs",
      "repos_url": "https://api.github.com/users/kirillgrachoff/repos",
      "events_url": "https://api.github.com/users/kirillgrachoff/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirillgrachoff/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2021-05-18T19:44:02Z",
    "updated_at": "2022-02-19T10:44:55Z",
    "closed_at": "2022-02-19T10:44:55Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "# Почему больно без этого\r\nВозьмём код на С++. Вполне обычный код.\r\n```cpp\r\nstd::vector<char> v;\r\n// something useful\r\nstd::string s(v.begin(), v.end());\r\n```\r\nРаботает.\r\n\r\nТеперь вспомним про замечательные ***Ranges***.\\\r\nЧто теперь хочется?\\\r\nА хочется вот так:\r\n```cpp\r\nstd::string text = \"this is simple text\";\r\nfor (auto subs : std::ranges::split_view(text, ' ')) {\r\n    // либо так:\r\n    std::string word(std::ranges::begin(subs), std::ranges::end(subs));\r\n    // либо так:\r\n    std::string word(subs);\r\n}\r\n```\r\n\r\nНо ни то, ни другое не компилируется т.к. у std::string (и у других контейнеров) нет таких штук.\r\n\r\n# Предложение\r\nДобавить к каждому std контейнеру **хотя бы** конструктор от двух итераторов разного типа (это несложно).\r\nВсего лишь добавить\r\n```cpp\r\ntemplate <typename InputIterFirst, typename InputIterLast>\r\nrequires Comparable<InputIterFirst, InputIterLast>\r\nstd::string(InputIterFirst first, InputIterLast last) {}\r\n```\r\nГде `Comparable<T, U>` - это `concept`, отвечающий за то, чтобы их можно было сравнивать друг с другом.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/458/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/458/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/457",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/457/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/457/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/457/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/457",
    "id": 886386988,
    "node_id": "MDU6SXNzdWU4ODYzODY5ODg=",
    "number": 457,
    "title": "Установка приоритетов потокам",
    "user": {
      "login": "maksimus1210",
      "id": 15178782,
      "node_id": "MDQ6VXNlcjE1MTc4Nzgy",
      "avatar_url": "https://avatars.githubusercontent.com/u/15178782?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maksimus1210",
      "html_url": "https://github.com/maksimus1210",
      "followers_url": "https://api.github.com/users/maksimus1210/followers",
      "following_url": "https://api.github.com/users/maksimus1210/following{/other_user}",
      "gists_url": "https://api.github.com/users/maksimus1210/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maksimus1210/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maksimus1210/subscriptions",
      "organizations_url": "https://api.github.com/users/maksimus1210/orgs",
      "repos_url": "https://api.github.com/users/maksimus1210/repos",
      "events_url": "https://api.github.com/users/maksimus1210/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maksimus1210/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 9,
    "created_at": "2021-05-11T07:51:30Z",
    "updated_at": "2021-08-02T09:31:14Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_В STL и Boost есть классы для работы с потоками, но устанавливать приоритеты потокам приходится через сторонние библиотеки как pthread. \r\n Для каждой ОС этот код разный, хотелось бы иметь стандартные средства для управления приоритетом потока._\r\n\r\n`std::thread thread([](){ std::cout << \"Hello world!\" }, std::thread::priority::high_priority);`",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/457/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/457/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/456",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/456/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/456/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/456/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/456",
    "id": 884771779,
    "node_id": "MDU6SXNzdWU4ODQ3NzE3Nzk=",
    "number": 456,
    "title": "Убрать зависимость core language features от заголовков <initializer_list> и <compare>",
    "user": {
      "login": "oficsu",
      "id": 35731382,
      "node_id": "MDQ6VXNlcjM1NzMxMzgy",
      "avatar_url": "https://avatars.githubusercontent.com/u/35731382?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/oficsu",
      "html_url": "https://github.com/oficsu",
      "followers_url": "https://api.github.com/users/oficsu/followers",
      "following_url": "https://api.github.com/users/oficsu/following{/other_user}",
      "gists_url": "https://api.github.com/users/oficsu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/oficsu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/oficsu/subscriptions",
      "organizations_url": "https://api.github.com/users/oficsu/orgs",
      "repos_url": "https://api.github.com/users/oficsu/repos",
      "events_url": "https://api.github.com/users/oficsu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/oficsu/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-05-10T18:05:26Z",
    "updated_at": "2021-05-10T20:05:10Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "На текущий момент есть места, где чисто-языковые возможности зависят от типов, объявленных в заголовках стандартной библиотеки. Следующие примеры являются невалидным C++:\r\n```cpp\r\nauto x = {0, 42};\r\nusing initializer_list = decltype(x);\r\n\r\nusing strong_ordering = decltype(0 <=> 42);\r\n```\r\nНа практике, не включив заголовки `<initializer_list>` и `<compare>` мы не имеем права сделать такие базовые вещи, как:\r\na) инициализировать переменную;\r\nb) сравнить два числа\r\n\r\n\r\n\r\n**Вывод типов через выражение**\r\n\r\nОднако, на деле, у нас допустим похожий механизм — мы имеем право вывести `size_t` через языковые конструкции, [чем, например, пользуется компилятор](https://github.com/gcc-mirror/gcc/commit/6fb7e3c29188ab7cde0b963957caf6182536c77d#diff-8983eec8ace181a18d4daf8759a9a9e5481fac638e1d6f89688ff7433cb388d0R4):\r\n```cpp\r\nusing size_t = decltype(sizeof 0);\r\n```\r\nАналогичным образом мы могли бы определить `std::initializer_list` и `std::strong_ordering`:\r\n```cpp\r\nauto x = {0, 42};\r\nusing initializer_list = decltype(x);\r\nusing strong_ordering = decltype(0 <=> 42);\r\n```\r\nСейчас это ошибка компиляции. Если посмотреть на [вывод трёх компиляторв](https://godbolt.org/z/7EnqYY1cY), каждый из них понимает, где здесь ошибка и прямым текстом требует подключить нужные заголовоки. Но если им достоверно известно, какой заголовок подключать — очень большой вопрос, зачем этот заголовок, собственно, нужен, тем более, почему он нужен для определения типа, использующегося в языковой фиче \r\n\r\nКроме того, если позволить такую реализацию, вопрос `<compare>` всё ещё остаётся нерешённым в полной мере, поскольку там определяются также `std::weak_ordering` и `std::partial_ordering`\r\n\r\n\r\n\r\n**Ключевые слова-типы**\r\n\r\nКак более надёжная альтернатива (пусть, и менее эстетичная) — пойти по стопам комитета стандартизации C и добавить встроенные языковые типы, например `_Initializer_list`, `_Strong_ordering`, `_Weak_ordering`, `_Partial_ordering`, а в `std::` сделать на них лишь алиасы\r\n\r\n\r\n\r\nПочему это плохо? Во-первых, такая зависимость не вяжется с желанием иметь отчуждаемую стандартную библиотеку. Во-вторых, буду честен, в первую очередь это крайне уродливая зависимость с эстетической точки зрения. Из реальных практических примеров проблемы — встречались случаи обхода другими программистами этой проблемы в случаях, когда имелся компилятор свежей версии, а библиотеки под него нет — в этом случае ничего не остаётся, кроме как написать недостающую типы в пространстве имён `std::`, что формально является неопределённым поведением\r\n\r\nЯ думаю, в C++ есть и другие примеры зависимости языка от собственной стандартной библиотеки, которые также стоит исправить, если будут найдены\r\n\r\nБез заглядывания в стандарт, я склонен считать, что проблема здесь две. Самая незначительная из них — вординг стандарта, но вторая серьёзнее — ABI. Как дальше манглить условный `_Initializer_list`? Всё ещё как `std::initializer_list`? Однако, если кто-то сможет найти другие проблемы — буду рад комментариям\r\n\r\nСсылки на сообщения топика, изначально натолкнувшего на эту идею: [#⁢1](https://t.me/ProCxx/448728), [#⁢2](https://t.me/ProCxx/449094), [#⁢3](https://t.me/ProCxx/449096), [#⁢4](https://t.me/ProCxx/449109), [#⁢5](https://t.me/ProCxx/449126), [#⁢6](https://t.me/ProCxx/449269), [#⁢7](https://t.me/ProCxx/449293)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/456/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/456/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/455",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/455/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/455/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/455/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/455",
    "id": 883770181,
    "node_id": "MDU6SXNzdWU4ODM3NzAxODE=",
    "number": 455,
    "title": "`chain`, `zip` для итераторов и диапазонов",
    "user": {
      "login": "GeorgyFirsov",
      "id": 11062067,
      "node_id": "MDQ6VXNlcjExMDYyMDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/11062067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GeorgyFirsov",
      "html_url": "https://github.com/GeorgyFirsov",
      "followers_url": "https://api.github.com/users/GeorgyFirsov/followers",
      "following_url": "https://api.github.com/users/GeorgyFirsov/following{/other_user}",
      "gists_url": "https://api.github.com/users/GeorgyFirsov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GeorgyFirsov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GeorgyFirsov/subscriptions",
      "organizations_url": "https://api.github.com/users/GeorgyFirsov/orgs",
      "repos_url": "https://api.github.com/users/GeorgyFirsov/repos",
      "events_url": "https://api.github.com/users/GeorgyFirsov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GeorgyFirsov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-05-10T08:59:41Z",
    "updated_at": "2022-02-19T10:59:32Z",
    "closed_at": "2022-02-19T10:59:31Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "### Суть\r\nВ целом сама идея, думаю, и из заголовка ясна. Предлагаю добавить такие функции, как `zip` и `chain`.\r\n\r\nПервая возвращает адаптер, итератор которого содержит кортеж из ссылок/значений (этот момент вообще требуется дополнительно обдумать, как такое лучше реализовать, возможно в комментах напишу продолжение), полученных из соответствующих переданным контейнерам/диапазонам итераторов. При этом если один диапазон короче другого, то следует итерироваться до конца самого короткого. Хотя в целом тут можно добавить вариант с проверкой равенства длин диапазонов.\r\n\r\nВторая же \"ставит\" один диапазон за другим, позволяя по окончании первого перейти к элементам второго. Внутренние типы диапазонов должны совпадать или хотя бы быть приводимыми друг к другу или к общему родителю (если ссылки или указатели).\r\n\r\nСтоит отметить, что ограничиваться двумя аргументами не представляется рациональным - данные концепции нетрудно обобщаются на произвольное количество диапазонов.\r\n\r\n### Примеры\r\nДумаю, примеров можно подобрать много и во многих областях, когда требуется проитерироваться по нескольким последовательностям примерно следующим образом (концепт):\r\n\r\n```cpp\r\nstd::vector<int> SomeValues = ...;\r\nstd::vector<std::string> SomeStrings = ...;\r\n\r\nfor (const auto& Pair : zip(SomeValues, SomeStrings)) {\r\n  // Pair это std::tuple<const int&, const std::string&> \r\n}\r\n```\r\n\r\n```cpp\r\nstd::vector<int> SomeValues = ...;\r\nstd::list<int> SomeOtherValues = ...;\r\n\r\nfor (int Value : chain(SomeValues, SomeOtherValues)) {\r\n  // Сначала идут значения из SomeValues, а потом - из SomeOtherValues\r\n}\r\n```\r\n\r\n### Реализация\r\nРеализацию `zip` можно найти в бусте. `chain` же в целом не представляет большой сложности в реализации.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/455/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/455/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/454",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/454/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/454/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/454/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/454",
    "id": 880995471,
    "node_id": "MDU6SXNzdWU4ODA5OTU0NzE=",
    "number": 454,
    "title": "Добавить move-only  std::function ",
    "user": {
      "login": "raidenluikang",
      "id": 24319853,
      "node_id": "MDQ6VXNlcjI0MzE5ODUz",
      "avatar_url": "https://avatars.githubusercontent.com/u/24319853?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/raidenluikang",
      "html_url": "https://github.com/raidenluikang",
      "followers_url": "https://api.github.com/users/raidenluikang/followers",
      "following_url": "https://api.github.com/users/raidenluikang/following{/other_user}",
      "gists_url": "https://api.github.com/users/raidenluikang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/raidenluikang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/raidenluikang/subscriptions",
      "organizations_url": "https://api.github.com/users/raidenluikang/orgs",
      "repos_url": "https://api.github.com/users/raidenluikang/repos",
      "events_url": "https://api.github.com/users/raidenluikang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/raidenluikang/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-05-08T16:05:13Z",
    "updated_at": "2021-10-17T19:03:30Z",
    "closed_at": "2021-10-17T19:03:21Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "_std::function не поддерживает move-only functors_\r\n\r\n_std::function <int ()> f = [ m = std::make_unique<int>() ] (){ return *m; };   не компилируется_\r\n\r\n_https://godbolt.org/z/hKhneEWz3_\r\n\r\n```\r\ntemplate <typename R, typename ... Args >\r\nclass function < R(Args ... ) >\r\n{\r\n   // ....\r\n    template <typename F>\r\n     function ( F && f) ; // -->почему f  требуется чтобы она было копируемый? \r\n};\r\n```\r\n\r\n\r\nПолезные ссылки:\r\n* https://godbolt.org/z/hKhneEWz3 - онлайн дизассемблер\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/454/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/454/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/453",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/453/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/453/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/453/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/453",
    "id": 876560224,
    "node_id": "MDU6SXNzdWU4NzY1NjAyMjQ=",
    "number": 453,
    "title": "constexpr `to_chars`/`from_chars`",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Neargye",
        "id": 7997966,
        "node_id": "MDQ6VXNlcjc5OTc5NjY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Neargye",
        "html_url": "https://github.com/Neargye",
        "followers_url": "https://api.github.com/users/Neargye/followers",
        "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
        "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
        "organizations_url": "https://api.github.com/users/Neargye/orgs",
        "repos_url": "https://api.github.com/users/Neargye/repos",
        "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Neargye/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-05-05T15:15:13Z",
    "updated_at": "2022-08-11T11:35:48Z",
    "closed_at": "2022-08-11T11:35:48Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Хотелось бы иметь стандартный способ перевести строку в число и обратно на этапе компиляции. Сейчас для этого приходится либо писать свои реализации, либо брать что-то из boost/etc.\r\n\r\n```cpp\r\nconstexpr std::optional<int> to_int(std::string_view s) {\r\n    int value;\r\n\r\n    if (auto [p, err] = std::from_chars(s.begin(), s.end(), value); err == std::errc{}) {\r\n        return value;\r\n    } else {\r\n        return std::nullopt;\r\n    }\r\n}\r\n\r\nstatic_assert(to_int(\"42\") == 42);\r\nstatic_assert(to_int(\"foo\") == std::nullopt);\r\n```\r\n\r\n\r\nПропозл для целочисленных числес сейчас находится в работе:\r\nhttps://github.com/cplusplus/papers/issues/984\r\nhttps://wg21.link/p2291\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/453/reactions",
      "total_count": 10,
      "+1": 10,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/453/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/452",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/452/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/452/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/452/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/452",
    "id": 870202497,
    "node_id": "MDU6SXNzdWU4NzAyMDI0OTc=",
    "number": 452,
    "title": "std::basic_string::trim",
    "user": {
      "login": "GeorgyFirsov",
      "id": 11062067,
      "node_id": "MDQ6VXNlcjExMDYyMDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/11062067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GeorgyFirsov",
      "html_url": "https://github.com/GeorgyFirsov",
      "followers_url": "https://api.github.com/users/GeorgyFirsov/followers",
      "following_url": "https://api.github.com/users/GeorgyFirsov/following{/other_user}",
      "gists_url": "https://api.github.com/users/GeorgyFirsov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GeorgyFirsov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GeorgyFirsov/subscriptions",
      "organizations_url": "https://api.github.com/users/GeorgyFirsov/orgs",
      "repos_url": "https://api.github.com/users/GeorgyFirsov/repos",
      "events_url": "https://api.github.com/users/GeorgyFirsov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GeorgyFirsov/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-04-28T17:52:14Z",
    "updated_at": "2021-08-17T17:13:47Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "### Суть\r\nДобавить в шаблон класса строки методы `trim_left`, `trim_right` и `trim`, которые обрезают пробельные символы слева, справа или по обеим сторонам строчки.\r\n\r\n### Применение\r\nПолезно, к примеру, при построчном чтении файлов, при обработке ввода от пользователя и тому подобных случаях. Часто на моей практике встречаются ситуации, когда пробельные символы по сторонам строчки необходимо убрать.\r\n\r\n### Пример реализации\r\n#### Возможная реализация\r\n```cpp\r\nconstexpr basic_string& trim_left()\r\n{\r\n    const auto is_not_space = std::not_fn(static_cast<int(*)(int)>(std::isspace));\r\n    this->erase(cbegin(), std::find_if(cbegin(), cend(), is_not_space));\r\n    return *this;\r\n}\r\n\r\nconstexpr basic_string& trim_right()\r\n{\r\n    const auto is_not_space = std::not_fn(static_cast<int(*)(int)>(std::isspace));\r\n    this->erase(std::find_if(crbegin(), crend(), is_not_space).base(), cend());\r\n    return *this;\r\n}\r\n\r\nconstexpr basic_string& trim()\r\n{\r\n    return trim_left().trim_right();\r\n}\r\n```\r\n\r\n#### Как можно сейчас\r\n```cpp\r\n// C++17 и новее\r\n\r\ntemplate<typename Char, typename Traits, typename Allocator>\r\nconstexpr basic_string<Char, Traits, Allocator>& trim_left(basic_string<Char, Traits, Allocator>& s)\r\n{\r\n    const auto is_not_space = std::not_fn(static_cast<int(*)(int)>(std::isspace));\r\n    s.erase(s.cbegin(), std::find_if(s.cbegin(), s.cend(), is_not_space));\r\n    return s;\r\n}\r\n\r\ntemplate<typename Char, typename Traits, typename Allocator>\r\nconstexpr basic_string<Char, Traits, Allocator>& trim_right(basic_string<Char, Traits, Allocator>& s)\r\n{\r\n    const auto is_not_space = std::not_fn(static_cast<int(*)(int)>(std::isspace));\r\n    s.erase(std::find_if(s.crbegin(), s.crend(), is_not_space).base(), s.cend());\r\n    return s;\r\n}\r\n\r\ntemplate<typename Char, typename Traits, typename Allocator>\r\nconstexpr basic_string<Char, Traits, Allocator>& trim(basic_string<Char, Traits, Allocator>& s)\r\n{\r\n    return trim_left(trim_right(s));\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/452/reactions",
      "total_count": 6,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/452/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/451",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/451/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/451/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/451/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/451",
    "id": 868809758,
    "node_id": "MDU6SXNzdWU4Njg4MDk3NTg=",
    "number": 451,
    "title": "Определение `noexcept`-спецификации самим компилятором",
    "user": {
      "login": "deiuch",
      "id": 26200443,
      "node_id": "MDQ6VXNlcjI2MjAwNDQz",
      "avatar_url": "https://avatars.githubusercontent.com/u/26200443?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/deiuch",
      "html_url": "https://github.com/deiuch",
      "followers_url": "https://api.github.com/users/deiuch/followers",
      "following_url": "https://api.github.com/users/deiuch/following{/other_user}",
      "gists_url": "https://api.github.com/users/deiuch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/deiuch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/deiuch/subscriptions",
      "organizations_url": "https://api.github.com/users/deiuch/orgs",
      "repos_url": "https://api.github.com/users/deiuch/repos",
      "events_url": "https://api.github.com/users/deiuch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/deiuch/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-27T12:43:41Z",
    "updated_at": "2021-05-18T22:34:50Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В некоторых шаблонных функциях мы для полноты картины можем написать в `noexcept(...)` содержимое самой функции по сути. Это вызывает бессмысленное дублирование кода. При этом компилятор, по спецификациям `noexcept` вызываемых из этой функций вполне может сам вычислить, точно ли функция не будет выбрасывать исключений, или это потенциально возможно. Хочется научиться перекладывать эту ответственность на компилятор путём внедрения какого-то дополнения к `noexcept`-спецификации.\r\n\r\nПример предлагаемого синтаксиса (предмет для дискуссии): `void foo() noexcept(auto) {}`\r\n\r\nДанная возможность позволит в простых случаях не дублировать код функции внутри `noexcept`, и при этом активнее пропагировать эту информацию без дополнительных усилий по проверке сигнатур вызываемых функций. Плюс это упростит использование `noexcept` в шаблонах функций, где многие типы или сигнатуры не будут известны до момента инстанцирования.\r\n\r\nТакже можно будет по этой причине всё же ввести `noexcept` для стандартных контейнеров, но который будет определяться деталями имплементации метода стандартного контейнера (к примеру, который может начать бросать исключения в дебажной сборке), и о таком `noexcept` нужно будет меньше беспокоиться далее в использующем его коде.\r\n\r\nОбратной стороной медали будет замедление времени компиляции. Поэтому можно ограничивать использование этого спецификатора в code style на каких-то базовых случаях (для уменьшения дублирования кода, к примеру).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/451/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/451/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/450",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/450/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/450/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/450/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/450",
    "id": 868057406,
    "node_id": "MDU6SXNzdWU4NjgwNTc0MDY=",
    "number": 450,
    "title": "расширить возможности синтаксических анализаторов при помощи Nullable и NotNull",
    "user": {
      "login": "neshkeev",
      "id": 4223091,
      "node_id": "MDQ6VXNlcjQyMjMwOTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4223091?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/neshkeev",
      "html_url": "https://github.com/neshkeev",
      "followers_url": "https://api.github.com/users/neshkeev/followers",
      "following_url": "https://api.github.com/users/neshkeev/following{/other_user}",
      "gists_url": "https://api.github.com/users/neshkeev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/neshkeev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/neshkeev/subscriptions",
      "organizations_url": "https://api.github.com/users/neshkeev/orgs",
      "repos_url": "https://api.github.com/users/neshkeev/repos",
      "events_url": "https://api.github.com/users/neshkeev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/neshkeev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-26T19:21:57Z",
    "updated_at": "2021-04-26T20:56:31Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "# Описание\r\n\r\nВ Java существуют [jsr 305](https://jcp.org/en/jsr/detail?id=305) и [jsr 308](https://jcp.org/en/jsr/detail?id=308), которые стандартизировали поддержку указания программистом в каких местах возможно, а в каких невозможны `null` значения. Компания JetBrains пошла немного дальше и добавила ещё [Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) аннотацию, которая позволяет указывать взаимосвязи между входными и выходными параметрами функции. Intellij IDEA имеет очень эффективный статический анализатор, который позволяет на этапе разработки отлавливать большое количество проблем, связанных с разыменовыванием `null` указателя.\r\n\r\nРеализовать эту идею можно при помощи пустых `#define` макросов:\r\n```c\r\n#define __Nullable\r\n#define __NotNull\r\n#define __Contract(...)\r\n```\r\n\r\n# Примеры\r\n\r\n1. Возврат `null` значения из функции, которая должна вернуть `__NotNull`:\r\n\r\n```c\r\n__NotNull int* getId() {\r\n    return null; // нарушение контракта\r\n}\r\n````\r\n2. Функция может возвратить `null`, но клиентский код не проверяет возвращаемое значение:\r\n\r\n```c\r\n__Nullable int* getId();\r\n\r\nint* idPointer = getId();\r\nstd::cout << *idPointer; // segfault\r\n```\r\n3. Если аргумент функции `null` то функция должна вернуть новый объект:\r\n```c\r\n__Contract(\"null -> new\") int* ensureNotNull(int* v) {\r\n    return v; // забыли соблюсти контракт\r\n}     \r\n```\r\n# Имеющиеся решения\r\n\r\n`clang` [предлагает](https://clang.llvm.org/docs/analyzer/developer-docs/nullability.html) свои `__nullable` и `__nonnull` аннотации",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/450/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/450/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/449",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/449/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/449/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/449/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/449",
    "id": 867086812,
    "node_id": "MDU6SXNzdWU4NjcwODY4MTI=",
    "number": 449,
    "title": "Специализация clock_time_conversion для system и steady",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-25T18:58:38Z",
    "updated_at": "2021-06-11T12:25:17Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В С++20 наконец-то стало возможным конвертировать время между часами, но не появилось специализации для конвентирования системных часов в монотонные и обратно.  На сколько я помню, для них гарантируется что они тикают с одинаковой скоростью и перевод одних в другие тривиален если знать разницу. Разница вычисляется просто (и её можно кешировать). Отдельно надо обратить внимание на то, что системные часы переключаемые и это надо отслеживать для перевычисления разницы. Например localtime на linux делает это вызовом fstat для файла со временем и проверяет что он не изменился. (Неприятно конечно делать системный вызов на каждую конвертацию, но все-же возможно. Может быть это можно сделать оптимальней, например два vdso вызова могут быть быстрее fstat)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/449/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/449/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/448",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/448/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/448/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/448/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/448",
    "id": 867080284,
    "node_id": "MDU6SXNzdWU4NjcwODAyODQ=",
    "number": 448,
    "title": "Structure bindings и structure matching в аргументах функции",
    "user": {
      "login": "kirillgrachoff",
      "id": 35011824,
      "node_id": "MDQ6VXNlcjM1MDExODI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35011824?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirillgrachoff",
      "html_url": "https://github.com/kirillgrachoff",
      "followers_url": "https://api.github.com/users/kirillgrachoff/followers",
      "following_url": "https://api.github.com/users/kirillgrachoff/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirillgrachoff/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirillgrachoff/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirillgrachoff/subscriptions",
      "organizations_url": "https://api.github.com/users/kirillgrachoff/orgs",
      "repos_url": "https://api.github.com/users/kirillgrachoff/repos",
      "events_url": "https://api.github.com/users/kirillgrachoff/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirillgrachoff/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-25T18:29:31Z",
    "updated_at": "2021-05-03T00:22:48Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "# Распаковка структур данных прямо в аргументах функции\r\nИногда очень хочется делать structure matching в аргументах функции.\r\n\r\nВ C++ есть передача аргументов по значению. Т.е. конструктор копирования выполняется до кода функции.\r\n\r\nХотелось бы делать что-то похожее на structure binding.\r\n```cpp\r\nusing Type = std::tuple<int, char, std::string>;\r\n```\r\n```cpp\r\nvoid foo(Type& [a, b, c]) {\r\n    std::cout << a << ' ' << b << ' ' << c << '\\n';\r\n}\r\n```\r\nЗдесь `type(a) == int&; type(b) == char&; type(c) = std::string&`.\r\n\r\n```cpp\r\nvoid foo(Type [a, b, c]) {\r\n    std::cout << a << ' ' << b << ' ' << c << '\\n';\r\n}\r\n```\r\nЗдесь `type(a) == int; type(b) == char; type(c) == std::string`\r\n\r\n```cpp\r\nvoid foo(Type&& [a, b, c]) {\r\n    std::cout << a << ' ' << b << ' ' << c << '\\n';\r\n}\r\n```\r\nЗдесь `type(a) == int&&; type(b) == char&&; type(c) == std::string&&`\r\n\r\n### Предложение\r\nВвести такой синтаксис.\r\n### Почему это удобно\r\nВы не заводите новых имён в функции.\r\nБез этого нужно было бы писать так:\r\n```cpp\r\nvoid foo(Type type) {\r\n    auto& [a, b, c] = type;\r\n    // ...\r\n}\r\n````\r\n```cpp\r\nvoid foo(Type& type) {\r\n    auto& [a, b, c] = type;\r\n    // ...\r\n}\r\n```\r\nПроблема налицо: появляется новое имя `type` и можно забыть написать `auto&`, чтобы не вызвать лишний конструктор копирования.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/448/reactions",
      "total_count": 5,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 1,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/448/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/447",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/447/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/447/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/447/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/447",
    "id": 867075955,
    "node_id": "MDU6SXNzdWU4NjcwNzU5NTU=",
    "number": 447,
    "title": "Structured bindings syntax extensions",
    "user": {
      "login": "kirillgrachoff",
      "id": 35011824,
      "node_id": "MDQ6VXNlcjM1MDExODI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35011824?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirillgrachoff",
      "html_url": "https://github.com/kirillgrachoff",
      "followers_url": "https://api.github.com/users/kirillgrachoff/followers",
      "following_url": "https://api.github.com/users/kirillgrachoff/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirillgrachoff/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirillgrachoff/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirillgrachoff/subscriptions",
      "organizations_url": "https://api.github.com/users/kirillgrachoff/orgs",
      "repos_url": "https://api.github.com/users/kirillgrachoff/repos",
      "events_url": "https://api.github.com/users/kirillgrachoff/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirillgrachoff/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-04-25T18:10:35Z",
    "updated_at": "2021-04-25T18:10:35Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "# Что это такое сейчас\r\nПусть есть код:\r\n```\r\nauto value = make_tuple(10, 'a', std::string(\"YourName\"));\r\nВ стандарте C++17 стало возможным писать такой код:\r\n```cpp\r\nauto [a, b, c] = value\r\nauto& [x, y, z] = value;\r\n```\r\n## Идея No 1\r\nНо (да, такое бывает) может быть такое, что хочется сделать что-то такое, но не заводить новые переменные.\r\nТ.е. что-то такое:\r\n```cpp\r\nauto [a, b, c] = value;\r\nif (conditional_function(a)) {\r\n    [a, b, c] = value2;\r\n}\r\n```\r\nНо такое невозможно сделать сейчас.\r\n### Предложение\r\nВвести дополнительный синтаксис\r\n```cpp\r\ntypeA a;\r\ntypeB b;\r\ntypeC c;\r\n// some code...\r\n[a, b, c] = value;\r\n```\r\nТ.е. хотелось бы сделать возможным structured bindings в присваивании.\r\n\r\n## Идея No 2\r\nВот есть то, что есть выше и в стандарте 17 года.\r\nХотелось бы иметь возможность и заводить переменные этой инструкцией, и инициализировать уже существующие.\r\n\r\n### Предложение\r\nМожно писать типы в инструкции из идеи 1.\r\n\r\nХотелось бы сделать валидным такую вещь:\r\n```cpp\r\n[a, b, std::string& name] = value;\r\n[int x, b, c] = value;\r\n```\r\nТ.е. появилось 2 новых переменных: int x и std::string& name.\r\n```cpp\r\n[int& x, char y, const std::string& z] = value;\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/447/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/447/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/446",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/446/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/446/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/446/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/446",
    "id": 866993658,
    "node_id": "MDU6SXNzdWU4NjY5OTM2NTg=",
    "number": 446,
    "title": "Отказ от с++",
    "user": {
      "login": "Vitalii-Shmidt",
      "id": 52749170,
      "node_id": "MDQ6VXNlcjUyNzQ5MTcw",
      "avatar_url": "https://avatars.githubusercontent.com/u/52749170?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Vitalii-Shmidt",
      "html_url": "https://github.com/Vitalii-Shmidt",
      "followers_url": "https://api.github.com/users/Vitalii-Shmidt/followers",
      "following_url": "https://api.github.com/users/Vitalii-Shmidt/following{/other_user}",
      "gists_url": "https://api.github.com/users/Vitalii-Shmidt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Vitalii-Shmidt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Vitalii-Shmidt/subscriptions",
      "organizations_url": "https://api.github.com/users/Vitalii-Shmidt/orgs",
      "repos_url": "https://api.github.com/users/Vitalii-Shmidt/repos",
      "events_url": "https://api.github.com/users/Vitalii-Shmidt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Vitalii-Shmidt/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-25T12:01:36Z",
    "updated_at": "2021-04-25T14:25:10Z",
    "closed_at": "2021-04-25T14:25:10Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "предлагаю отказаться от с++ и запретить на нем писать, как-либо его пропагандировать. Удалить с++ из сети.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/446/reactions",
      "total_count": 6,
      "+1": 2,
      "-1": 4,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/446/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/445",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/445/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/445/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/445/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/445",
    "id": 864593583,
    "node_id": "MDU6SXNzdWU4NjQ1OTM1ODM=",
    "number": 445,
    "title": "Добавление spinlock",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-04-22T06:34:34Z",
    "updated_at": "2021-04-25T14:36:59Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В С++20 добавили барьеры и семафоры. Почему спинлок опять обошли? Непонятно...\r\n\r\nДумаю каждый велосипедил свой спинлок (через pthread_spin или std::atomic_flag. А теперь вообще можно через std::atomic::wait)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/445/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/445/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/444",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/444/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/444/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/444/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/444",
    "id": 862654856,
    "node_id": "MDU6SXNzdWU4NjI2NTQ4NTY=",
    "number": 444,
    "title": "Добавить бинарный поиск возвращающий итератор",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-04-20T10:11:36Z",
    "updated_at": "2021-04-25T17:41:04Z",
    "closed_at": "2021-04-25T14:30:40Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Думаю этот велосипед писал каждый.\r\n\r\nРеализация:\r\n```\r\ntemplate<class ForwardIt, class T, class Compare>\r\nForwardIt binary_search(ForwardIt first, ForwardIt last, const T& value, Compare comp)\r\n{\r\n    auto it = std::lower_bound(first, last, value, comp);\r\n    if (it != last && comp(value, *it))\r\n        return last;\r\n    return it;\r\n}\r\n```\r\n\r\nИмя нового алгоритма остается открытым\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/444/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/444/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/443",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/443/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/443/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/443/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/443",
    "id": 860622564,
    "node_id": "MDU6SXNzdWU4NjA2MjI1NjQ=",
    "number": 443,
    "title": "Доработка find у *_set контейнеров",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-18T09:57:44Z",
    "updated_at": "2021-04-24T17:45:26Z",
    "closed_at": "2021-04-22T14:28:34Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Очень часто в кодовых базах я встречал что-то вроде\r\n```\r\nstruct SName {\r\n// ...\r\n    std::string str;\r\n// ...\r\n};\r\n\r\nstd::map<const char*, SName> map;\r\nSName sname;\r\nmap.insert(sname.str.c_str(), sname);\r\nstd::string find_str;\r\nauto it = map.find(find_str.c_str());\r\n```\r\n\r\n\r\nЭтот код ужасен, и не только с виду, но и неся кучу скрытых и очень опасных моментов (в которых легко отстрелить себе ногу).\r\n\r\nЯ вижу несколько возможных решений. Либо find будет принимать компаратор умеющий сравнивать элемент из set с переданным в find значением, либо map придется параметризовывать не только компаратором но и \"отображением\" (по-моему что-то такое появилось в ranges). Проблематично тк четвертым параметром шаблона у set идет Allocator который если сделать пятым то поломается совместимость, а если добавить после него то станет некрасиво и поломается то что аллокатор всегда последний \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/443/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/443/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/442",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/442/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/442/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/442/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/442",
    "id": 859703836,
    "node_id": "MDU6SXNzdWU4NTk3MDM4MzY=",
    "number": 442,
    "title": "Пофиксить потенциально разную семантику у `typedef` и `using`",
    "user": {
      "login": "yeputons",
      "id": 1297325,
      "node_id": "MDQ6VXNlcjEyOTczMjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1297325?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yeputons",
      "html_url": "https://github.com/yeputons",
      "followers_url": "https://api.github.com/users/yeputons/followers",
      "following_url": "https://api.github.com/users/yeputons/following{/other_user}",
      "gists_url": "https://api.github.com/users/yeputons/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yeputons/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yeputons/subscriptions",
      "organizations_url": "https://api.github.com/users/yeputons/orgs",
      "repos_url": "https://api.github.com/users/yeputons/repos",
      "events_url": "https://api.github.com/users/yeputons/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yeputons/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 3771028573,
        "node_id": "LA_kwDOFK7cns7gxVRd",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23-ru-comment",
        "name": "C++23-ru-comment",
        "color": "21DB3A",
        "default": false,
        "description": "Идея, которую можно попробовать отправить коментарием от страны к C++23"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-04-16T10:53:03Z",
    "updated_at": "2022-02-19T11:02:25Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Мелочь, навеянная вот этим вопросом на SO: https://stackoverflow.com/questions/48613758/using-vs-typedef-is-there-a-subtle-lesser-known-difference\r\n\r\n[`dcl.typedef`/2](https://eel.is/c++draft/dcl.typedef#2) сообщает, что `using A = struct {};` и `typedef struct {} A;` должны быть эквивалентны:\r\n\r\n> A typedef-name can also be introduced by an alias-declaration. ... Such a typedef-name has the same semantics as if it were introduced by the typedef specifier. ...\r\n\r\nДальше можно посмотреть конструкцию `typedef struct {} A;` на верхнем уровне кода, которая относительно ожидаемо заводит тип `A` с external linkage из-за правила [`basic.link]/4.3`](https://eel.is/c++draft/basic.link#4.3). Но, к сожалению, это правило пишет про \"typedef declaration\", что можно интерпретировать как \"typedef declaration, but not alias declaration\". То есть `using A = struct {};` уже не линкуется.\r\n\r\nВероятно, GCC этим и занимается: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99931\r\n\r\nПредлагаю поправить и поменять в этом месте \"typedef declaration\" на что-то вроде \"typedef declaration or alias declaration\". Наверняка захочется зацепить ещё соседние кусочки про `enum`.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/442/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/442/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/441",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/441/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/441/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/441/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/441",
    "id": 858022937,
    "node_id": "MDU6SXNzdWU4NTgwMjI5Mzc=",
    "number": 441,
    "title": "std::unique_any - не требующий копируемости вариант std::any",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-14T15:40:44Z",
    "updated_at": "2023-10-22T09:44:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Изначально, std::any позиционировался как безопасная замена `void*`, но что-то пошло не по плану.\r\nВ С++20 нет возможности поместить в std::any некопируемые типы, например типы содержащие std::unqiue_ptr или std::mutex.\r\n\r\n### Решение - std::unique_any\r\n\r\nОтдельный класс `std::unique_any` полностью повторяющий интерфейс `std::any` но без конcтруторов копирования и операторов присвоения от unique_any http://eel.is/c++draft/any.class.general\r\n\r\nПример использования:\r\n```cpp\r\nstd::unique_any var;\r\nvar = 42;\r\nvar.emplace(std::in_place<std::mutex>);\r\n\r\nvar.reset();\r\n\r\nstd::lock_guard lock{std::any_cast<std::mutex>(var)};\r\nauto shared_var = std::make_shared<std::unique_any>(42); // 2 allocations\r\n```\r\n\r\nПлюсы:\r\n* удобный и привычный интерфейс\r\n* мы получаем безопасный аналог std::unique_ptr<void*>\r\n\r\nМинусы:\r\n* решение не масштабируется на остальные умные указатели (например std::shared_ptr<void*>). Но можно добавлять по новому типу на каждый умный указатель, например std::shared_any",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/441/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/441/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/440",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/440/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/440/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/440/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/440",
    "id": 857926101,
    "node_id": "MDU6SXNzdWU4NTc5MjYxMDE=",
    "number": 440,
    "title": "std::vector<bool> problem",
    "user": {
      "login": "kirillgrachoff",
      "id": 35011824,
      "node_id": "MDQ6VXNlcjM1MDExODI0",
      "avatar_url": "https://avatars.githubusercontent.com/u/35011824?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kirillgrachoff",
      "html_url": "https://github.com/kirillgrachoff",
      "followers_url": "https://api.github.com/users/kirillgrachoff/followers",
      "following_url": "https://api.github.com/users/kirillgrachoff/following{/other_user}",
      "gists_url": "https://api.github.com/users/kirillgrachoff/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kirillgrachoff/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kirillgrachoff/subscriptions",
      "organizations_url": "https://api.github.com/users/kirillgrachoff/orgs",
      "repos_url": "https://api.github.com/users/kirillgrachoff/repos",
      "events_url": "https://api.github.com/users/kirillgrachoff/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kirillgrachoff/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 4417430062,
        "node_id": "LA_kwDOFK7cns8AAAABB0yiLg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/breaking-change",
        "name": "breaking-change",
        "color": "b60205",
        "default": false,
        "description": "Идея, ломающая валидный имеющийся код или бинарную совместимость"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-14T13:56:47Z",
    "updated_at": "2022-08-11T18:54:42Z",
    "closed_at": "2022-08-11T18:54:42Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "It is rude to write\r\n```cpp\r\ntemplate <typename T>\r\nauto& get_at(std::vector<T>& container, size_t index) {\r\n    // write to log\r\n    return container[index];\r\n}\r\n```\r\nstd::vector<bool>::operator[] returns _Bit_Reference which cannot be cast to bool& or const bool&\r\n\r\nIt is also rude to write\r\n```cpp\r\nT& value = container[index]\r\n```\r\nbecause of _Bit_Reference.\r\n\r\nMy suggestion is:\r\nRename `std::vector<bool>` to `std::dynamic_bitset` (or similar) to prevent compile-errors because of `std::vector<bool>` specialization.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/440/reactions",
      "total_count": 5,
      "+1": 1,
      "-1": 4,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/440/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/439",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/439/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/439/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/439/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/439",
    "id": 856595559,
    "node_id": "MDU6SXNzdWU4NTY1OTU1NTk=",
    "number": 439,
    "title": "Constexper bitset",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-13T05:50:38Z",
    "updated_at": "2021-04-15T07:56:20Z",
    "closed_at": "2021-04-14T18:53:20Z",
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Необходимо пометить все методы std::bitset как constexpr",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/439/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/438",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/438/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/438/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/438/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/438",
    "id": 855114208,
    "node_id": "MDU6SXNzdWU4NTUxMTQyMDg=",
    "number": 438,
    "title": "Добавление недостающей функции для работы с кучей",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 8,
    "created_at": "2021-04-10T17:13:41Z",
    "updated_at": "2021-06-24T11:47:29Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В стандарте есть функции для работы с кучей. is_heap, make_heap, push_heap, pop_heap и другие. \r\nНе достает std::shift_down которая будет просеивать модифицированный максимальный/минимальный элемент. \r\nНапример библиотеки событий используют кучу для хранения таймеров. Те получаем таймер, отрабатываем callback и переводим. Делать перезавод удалением + добавлением не оптимально. (Та функция которую приходится заново писать на каждом месте работы)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/438/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/438/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/437",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/437/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/437/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/437/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/437",
    "id": 854341714,
    "node_id": "MDU6SXNzdWU4NTQzNDE3MTQ=",
    "number": 437,
    "title": "Добавление новых часов и исправление функций сна",
    "user": {
      "login": "Roman-Koshelev",
      "id": 34384083,
      "node_id": "MDQ6VXNlcjM0Mzg0MDgz",
      "avatar_url": "https://avatars.githubusercontent.com/u/34384083?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Roman-Koshelev",
      "html_url": "https://github.com/Roman-Koshelev",
      "followers_url": "https://api.github.com/users/Roman-Koshelev/followers",
      "following_url": "https://api.github.com/users/Roman-Koshelev/following{/other_user}",
      "gists_url": "https://api.github.com/users/Roman-Koshelev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Roman-Koshelev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Roman-Koshelev/subscriptions",
      "organizations_url": "https://api.github.com/users/Roman-Koshelev/orgs",
      "repos_url": "https://api.github.com/users/Roman-Koshelev/repos",
      "events_url": "https://api.github.com/users/Roman-Koshelev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Roman-Koshelev/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 9,
    "created_at": "2021-04-09T09:19:23Z",
    "updated_at": "2021-04-18T20:38:58Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "В С++20 сильно расширили зоопарк часов, но так и не сделали то чего хотелось бы.\r\n\r\nПроблемма 1.\r\n\r\nСейчас (до с++20 по крайней мере) есть трое часов (system_clock, steady_clock, high_resolution_clock).\r\nsystem_clock - часы реального времени с разрешением ??? В Windows это 100ns, на linux в libc++ 1us (наносекунды обрезаются) а в libstdc++ 1ns\r\nsteady_clock - монотонные часы с разрешением обычно 1ns\r\nhigh_resolution_clock - непонятные часы которые steady_clock в Microsoft STL и libc++, и system_clock в libstdc++. Как и для чего их можно использовать абсолютно не ясно.\r\n\r\nПроблемы:\r\n- В linux эти часы зачастую работают не через vDSO (что очень печально).\r\n- Непонятно как получить разрешение\r\n- Отсутствуют их быстрые но менее точные версии\r\n\r\nЧего хочется:\r\n- разрешение часов в constexpr\r\n- обязать их работать через vDSO\r\n- добавить быстрые версии этих часов (с меньшим разрешением). В linux это CLOCK_REALTIME_COARSE и CLOCK_MONOTONIC_COARSE которые сильно шустрее и имеют размешение 1ms чего достаточно для 99% кейсов\r\n- интерфейс  для получения типа нужных часов в compile time. Например: дай мне самые быстрые steady часы с разрешением не менее 10ms\r\n\r\n\r\nПроблемма 2.\r\n\r\nДля того чтобы заснуть с++ предоставляет 2 функции (sleep_for и sleep_until). Обе работают интересным образом.\r\nВ Microsoft STL функция sleep_for прибавляет к переданному времени clock::now() и делает sleep_until.\r\nlibc++ и libstdc++ делают наоборот. sleep_until отнимает от переданного времени clock::now() и вызывает sleep_for\r\n\r\nПроблемы Microsoft STL:\r\n- функция вызывает clock::now() что лишнее действие которое конечно нужно для точности, но не всем. Если пользователь захочет он должен сам вызывать clock::now() и вызывать sleep_until. Если вызывается sleep_for то она должна просто уйти в сон без лишних телодвижений\r\n\r\nПроблемы libc++ и libstdc++:\r\n- тут все сильно хуже. Пользователь дергает sleep_until, вызывается clock::now() (которая к тому же не через vDSO), теряется точность например после clock::now() и до sleep() мы можем получить вытеснение и проспим дольше положенного (разработчики многих либ и продуктов съели на этом сто собак). В итоге мы получаем лишний дорогой системный вызов, за счет уменьшения точности (Как тебе такое Илон Маск?).\r\n\r\n\r\nЧего хочется:\r\n- чтобы sleep_until гарантированно работала оптимально\r\n- чтобы sleep_for просто делала что говорят, и не пыталась чтото улучшить за счет лишних телодвижений",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/437/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/437/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/436",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/436/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/436/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/436/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/436",
    "id": 853540849,
    "node_id": "MDU6SXNzdWU4NTM1NDA4NDk=",
    "number": 436,
    "title": "Возврат из функции объекта, созданного из конструктора по умолчанию",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-08T14:35:25Z",
    "updated_at": "2021-04-08T14:37:11Z",
    "closed_at": "2021-04-08T14:36:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -19\r\n_Автор идеи:_ ??\r\n\r\nРазрешить использовать такую конструкцию return auto в функциях, где возможно создать объект\r\n```\r\nT foo() {\r\n     return auto; // return T();\r\n}\r\n```\r\n\r\n```\r\nExample:\r\n\r\nusing namespace std;\r\n\r\nvector<string> foo() {\r\n  return auto;  // Here will be: return vector<string>();\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/436/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/436/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/435",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/435/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/435/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/435/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/435",
    "id": 850244794,
    "node_id": "MDU6SXNzdWU4NTAyNDQ3OTQ=",
    "number": 435,
    "title": "Возможность достать std::stacktrace из исключения",
    "user": {
      "login": "axolm",
      "id": 36848714,
      "node_id": "MDQ6VXNlcjM2ODQ4NzE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/36848714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axolm",
      "html_url": "https://github.com/axolm",
      "followers_url": "https://api.github.com/users/axolm/followers",
      "following_url": "https://api.github.com/users/axolm/following{/other_user}",
      "gists_url": "https://api.github.com/users/axolm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axolm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axolm/subscriptions",
      "organizations_url": "https://api.github.com/users/axolm/orgs",
      "repos_url": "https://api.github.com/users/axolm/repos",
      "events_url": "https://api.github.com/users/axolm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axolm/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "axolm",
        "id": 36848714,
        "node_id": "MDQ6VXNlcjM2ODQ4NzE0",
        "avatar_url": "https://avatars.githubusercontent.com/u/36848714?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/axolm",
        "html_url": "https://github.com/axolm",
        "followers_url": "https://api.github.com/users/axolm/followers",
        "following_url": "https://api.github.com/users/axolm/following{/other_user}",
        "gists_url": "https://api.github.com/users/axolm/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/axolm/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/axolm/subscriptions",
        "organizations_url": "https://api.github.com/users/axolm/orgs",
        "repos_url": "https://api.github.com/users/axolm/repos",
        "events_url": "https://api.github.com/users/axolm/events{/privacy}",
        "received_events_url": "https://api.github.com/users/axolm/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-04-05T09:45:49Z",
    "updated_at": "2023-10-22T09:45:40Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Конкретно предлагается добавить статический метод `std::stacktrace::from_current_exception()`, который будет возвращать `std::stacktrace`(или возможно `const std::stacktrace&`).\r\nВ качестве пруфа, что к исключению можно добавить трейс без слома ABI делается прототип - https://github.com/axolm/libsfe.\r\nВсё обсуждение ведётся в контексте того, что в стандарт C++23 добавлен `std::stacktrace`",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/435/reactions",
      "total_count": 7,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/435/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/434",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/434/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/434/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/434/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/434",
    "id": 849690135,
    "node_id": "MDU6SXNzdWU4NDk2OTAxMzU=",
    "number": 434,
    "title": "Добавить std::left( container, number) , std::right(container, number)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-03T16:21:34Z",
    "updated_at": "2023-10-22T10:21:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -1\r\n_Автор идеи:_ ??\r\n\r\nу многих языках и SQL есть удобная функция   left  ,  right  .\r\n\r\n \r\n\r\nнапример, \r\n\r\n \r\n```cpp\r\nstd::string name = \"Hello, world\";\r\n\r\nstd::string hello = left(name, 5); // 'Hello'   , name.substr(0, 5)\r\n\r\nstd::string world = right(name, 5); // 'world'  ,  name.substr( name.length() - 5, 5);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/434/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/434/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/433",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/433/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/433/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/433/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/433",
    "id": 849689301,
    "node_id": "MDU6SXNzdWU4NDk2ODkzMDE=",
    "number": 433,
    "title": "enum class в switch case конструкций можно использовать если в switch стоит переменный с underlying type of enum",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-03T16:17:23Z",
    "updated_at": "2021-04-16T11:57:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -7\r\n_Автор идеи:_ ??\r\n\r\nПример, который не скомплируется в с++11 или слудующих версий, потому что enum color  не конвертируется на \"int\"  .  Но в switch case здесь никакое присваивание enum color  на каких либо int  не происходят. \r\n\r\n \r\n```cpp\r\nenum class color{ red, blue, white };\r\n\r\nint main()\r\n{\r\n     int value = read_value_from_anywhere_other_library();\r\n\r\n    switch( value ) \r\n    {\r\n         case color::red :  printf(\"This is a red color\\n\"); break;\r\n         case color::bllue : printf(\"This is a blue color\\n\"); break;\r\n         case color::white : printf(\"This is a white color\\n\"); break;\r\n         default: printf(\"This is not a color\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n \r\n\r\nПредлагаю, добавить  автогенерация оператор сравнение enum class  с его underlying type . Чтобы легко сравнивать и использовать их в if else , switch case  и других местах.\r\n\r\n \r\n\r\n \r\n\r\nТот пример , изменим и делаем работающий код для нынешного стандарт С++, будет UB:\r\n```cpp\r\nenum class color{ red, blue, white };\r\n\r\nint main()\r\n{\r\n    int value = read_value_from_anywhere_other_library();\r\n\r\n   switch( (enum color) value ) // converting has a UB.\r\n   {\r\n       case color:: red: printf(\"This is a red color\\n\"); break;\r\n       case color:: blue: printf(\"This is a blue color\\n\"); break;\r\n       case color:: white: printf(\"This is a white color\\n\"); break;\r\n       default: printf(\"This is a not color\\n\");break;\r\n   }\r\n}\r\n```\r\n \r\n\r\nЕсли не ошибаюсь, в с++17   конвертация целый число в enum class  будет UB,  если этот целый число значение имеет больше бит чем enum class элементы используется. В данном случий,  enum class color  -- элементам хватить 3 бит,  а  \"value\"  переменный может имет любой допустимый значений.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/433/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/433/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/432",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/432/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/432/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/432/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/432",
    "id": 849687366,
    "node_id": "MDU6SXNzdWU4NDk2ODczNjY=",
    "number": 432,
    "title": "Добавить атрибут [[strict]] в switch, и способ указать значение по-умолчанию в enum class",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-03T16:07:50Z",
    "updated_at": "2021-04-16T11:48:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -2\r\n_Автор идеи:_ ??\r\n\r\nПредставим что есть такой код:\r\n```cpp\r\nenum class TestEnum {\r\n    one,\r\n    two\r\n};\r\n\r\nvoid someFunc() {\r\n    TestEnum test = TestEnum::one;\r\n\r\n    switch (test) {\r\n    case TestEnum::one:\r\n        cout << \"One\";\r\n        break;\r\n    case TestEnum::two:\r\n        cout << \"Two\";\r\n        break;\r\n    default:\r\n        cout << \"Default\";\r\n        break;\r\n    }\r\n}\r\n```\r\nИ вот что с ним не так:\r\n\r\n1) Бесполезная ветка default. Если все работает как задумано, то эта ветка не должна выполняться вообще никогда.\r\n\r\n2) Непонятки с самой последней инструкцией break; С виду она как-будто не нужна, но если ее удалить, а потом кто-то, например, из эстетических соображений перенесет default-ветку вверх switch-а то сразу возникнет ошибка из за пропавшего break. Вот код после этих 2х модификаций:\r\n```cpp\r\nswitch (test) {\r\ndefault:\r\n    cout << \"Default\";  // Error: break missing!\r\ncase TestEnum::one:\r\n    cout << \"One\";\r\n    break;\r\ncase TestEnum::two:\r\n    cout << \"Two\";\r\n    break;\r\n}\r\n```\r\n3) Если удалить default ветку а затем добавить только в enum дополнительное значение \"three\", то программа без проблем скомпилируется, хотя в switch не перебраны все варианты enum-a и нет default ветки. Что тоже выглядит не так как задумано. Пример такой модификации:\r\n```cpp\r\nenum class TestEnum {\r\n    one,\r\n    two,\r\n    three\r\n};\r\n\r\nvoid someFunc() {\r\n    TestEnum test = TestEnum::one;\r\n\r\n    switch (test) {\r\n    case TestEnum::one:\r\n        cout << \"One\";\r\n        break;\r\n    case TestEnum::two:\r\n        cout << \"Two\";\r\n        break;\r\n    } // Where is three?\r\n}\r\n```\r\n4) Так же этот код возможно сломать, если убрать инициализацию переменной значением TestEnum::one . Тогда в switch будет выполняться default ветка, что тоже не выглядит как хорошее поведение для неинициализированной переменной.\r\n\r\nПредлагаю следующее:\r\n\r\n1) Добавить в enum class атрибут, который бы существенно ограничивал возможности создания такого enum-а без значения, например [[strict]]\r\n\r\n2) Добавить в switch атрибут, например [[strict]], который бы гарантировал перебор всех значений enum ов и убирал нерабочие ветки:\r\n\r\nЧтобы это сделать, нужно во-первых сделать break-поведение, поведением по-умолчанию. Т.е. мы убираем все break операторы и подразумеваем что в конце всех case будет автоматом происходить выходить из switch.\r\nВо-вторых нужно гарантировать представленность всех случаев enum-а\r\nЕсли параметром [[strict]] switch передали обычный enum то выдавать compilation error\r\n\r\nЕсли параметром в [[strict]] switch передали enum class (enum, который без атрибута [[strict]]) то проверять, что обязательно есть default ветка, и обязательно есть все возможые case для значений этого enum, иначе compilation error.\r\ndefault ветка как раз для случаев, когда этот enum class инициализирован мусором.\r\nЕсли же нужен [[strict]] switch не по всем значениям enum class, то можно например добавить атрибут [[notfull]], тогда все скомпилится. Важно! атрибут [[notfull]] нужен только в комбинации [[strict]] switch + enum class (не строгий)\r\n\r\nЕсли параметром в [[strict]] switch передали enum class [[strict]], то должно быть всего 2 возможных сценария, которые корректно скомпилируются: либо в этом switch укзааны все возможные значения enum и отсутствует default ветка, либо пропущен один или несколько вариантов enum и тогда default ветка гарантированно присутствует, иначе ошибка компиляции. Примеры кода:\r\n```cpp\r\nenum TestEnum {\r\n    one,\r\n    two\r\n};\r\n\r\nenum class TestEnumClass {\r\n    one,\r\n    two\r\n};\r\n\r\nenum class [[strict]] TestEnumStrict {\r\n    one,\r\n    two\r\n};\r\n\r\n\r\n// строгие switch + обычные enum\r\n    TestEnum test;\r\n    [[strict]] switch (test) { // В любом случае ошибка компиляции\r\n    }\r\n    \r\n    // строгие switch + обычные enum class\r\n    TestEnumClass testClass;\r\n    // Успешно скомпилируется\r\n    [[strict]] switch (testClass) {  \r\n        case TestEnumClass::one: cout << \"one\";\r\n        case TestEnumClass::two: cout << \"two\";\r\n        default: cout << \"not initialized!\";\r\n    }\r\n    \r\n    // Ошибка компиляции: нет default ветки для мусора при инициализации\r\n    [[strict]] switch (testClass) {  \r\n        case TestEnumClass::one: cout << \"one\";\r\n        case TestEnumClass::two: cout << \"two\";\r\n    }\r\n    \r\n    // Ошибка компиляции: не все случаи enum представлены\r\n    [[strict]] switch (testClass) {  \r\n        case TestEnumClass::one: cout << \"one\";\r\n        default: cout << \"not initialized!\";\r\n    }\r\n    \r\n    // Успешно скомпилируется\r\n    [[strict, notfull]] switch (testClass) {  \r\n        case TestEnumClass::one: cout << \"one\";\r\n        default: cout << \"default\";\r\n    }\r\n    \r\n    // Строгие switch + строгие enum class\r\n    TestEnumStrict testStrict;\r\n    // Успешно скомпилируется, все случаи enum есть, default ветка отсутствует, как и должна\r\n    [[strict]] switch (testStrict) {  \r\n        case TestEnumStrict::one: cout << \"one\";\r\n        case TestEnumStrict::two: cout << \"two\";\r\n    }\r\n    \r\n    // Успешная компиляция, тот случай, когда нужно поработать не со всеми enum-значениями\r\n    [[strict]] switch (testStrict) {  \r\n        case TestEnumStrict::one: cout << \"one\";\r\n        default: cout << \"default\";\r\n    }\r\n    \r\n    // Ошибка компиляции: default ветка должна отсутствовать! потому что все enum варианты перебраны\r\n    [[strict]] switch (testStrict) {  \r\n        case TestEnumStrict::one: cout << \"one\";\r\n        case TestEnumStrict::two: cout << \"two\";\r\n        default: cout << \"default\";\r\n    }\r\n    \r\n    // Ошибка компиляции: здесь представлены не все случаи enum!\r\n    [[strict]] switch (testStrict) {  \r\n        case TestEnumStrict::one: cout << \"one\";\r\n    }\r\n    \r\n    // Ошибка компиляции. не должно быть break инструкции в [[strict]] switch\r\n    [[strict]] switch (testStrict) {  \r\n        case TestEnumStrict::one: cout << \"one\"; break;\r\n        default: cout << \"default\";\r\n    }\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/432/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/432/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/431",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/431/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/431/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/431/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/431",
    "id": 849681118,
    "node_id": "MDU6SXNzdWU4NDk2ODExMTg=",
    "number": 431,
    "title": "std::any_of_variadic",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-03T15:35:22Z",
    "updated_at": "2021-04-03T15:48:41Z",
    "closed_at": "2021-04-03T15:48:41Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +??, -??\r\n_Автор идеи:_ ??\r\n\r\nЧасто приходится писать код, типа\r\n\r\nif ((a == 1) || (a == 2) || (a == 3)) { ... };\r\n\r\nМне кажется, что что-то типа if (std::any_of_variadic(a, 1, 2, 3)) { ... }; этот код бы достаточно сократило.\r\n\r\n+Для консистентности, можно было бы добавить all_of_variadic и none_of_variadic.\r\n\r\n \r\n\r\nСуществует еще вариант, который очень близок к стандартной библиотеке, такой как std::something_of_variadic(функтор, аргументы...), может есть смысл подумать над ним?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/431/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/431/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/430",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/430/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/430/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/430/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/430",
    "id": 849680649,
    "node_id": "MDU6SXNzdWU4NDk2ODA2NDk=",
    "number": 430,
    "title": "Json, XML, Ini format parser",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-04-03T15:32:54Z",
    "updated_at": "2021-07-09T11:33:12Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -2\r\n_Автор идеи:_ ??\r\n\r\nВ С++ добавляется столько много вещей,  это приятно. \r\n\r\nНо в другой сторону, это печально, что С++ нет стаднтрный инструмент для работы с JSON, XML, INI   форматом, который  используется  почти для все программы с сетевом содействием и других местах.  Да, здесь очень много сторонных библиотеках, но у всех есть свои плюси и минусы и главное не в духе современный язык С++.\r\n\r\n \r\n\r\nНедавно читал,  С++20 добавили std::format  -- очень круто!  Python стил форматирование, не-такой громоздкой, быстрый как printf,  легко расширяется с пользовательский тип данных,  возмнож  возвращает std::string,  или возможно  записывает результат на   char []  массив.\r\n\r\n \r\n\r\nВот таким образом, не ужелье нельзя добавить  JSON, XML  формат парсеры и контейнеры,  который и легковесный и быстрый и удобный в использование?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/430/reactions",
      "total_count": 4,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/430/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/429",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/429/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/429/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/429/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/429",
    "id": 849680106,
    "node_id": "MDU6SXNzdWU4NDk2ODAxMDY=",
    "number": 429,
    "title": "Длинная арифметика",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-03T15:29:40Z",
    "updated_at": "2021-04-03T15:31:27Z",
    "closed_at": "2021-04-03T15:31:19Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +??, -??\r\n_Автор идеи:_ ??\r\n\r\nДобавить в C++ библиотеку по работе с длинными числами .Насколько знаю сейчас такое есть только в GMP . Хотелось бы иметь такое а самом стандарте .",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/429/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/429/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/428",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/428/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/428/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/428/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/428",
    "id": 849679781,
    "node_id": "MDU6SXNzdWU4NDk2Nzk3ODE=",
    "number": 428,
    "title": "Стандартизировать вложенный включение стандартные библиотеки",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-03T15:27:46Z",
    "updated_at": "2021-04-03T15:28:18Z",
    "closed_at": "2021-04-03T15:28:18Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +??, -??\r\n_Автор идеи:_ ??\r\n\r\nМоя идея,   каждого стандартную библиотеку указать какие другие библиотеки они \"должны\" включить, как минимум.\r\n\r\n\r\nНапример, тот же  <utility> -- зависят по каким другим библиотекам,  надо точно указать .\r\n\r\nЛибо, C++17  -- <string_view>   -- Здесь мне интересно , что,  это библиотека включает  у себя <string> или нет?   \r\n\r\nУ std::string_view   нет прямую зависимости std::string.\r\n\r\nНапример, у boost/utility/string_view.hpp  (1.69 )  включает  <string>, <algorithm> , <iterator>   <stdexcept>,  <cstring> , <iosfwd>   и ряд других стандартные библиотеки.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/428/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/428/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/427",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/427/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/427/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/427/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/427",
    "id": 849679055,
    "node_id": "MDU6SXNzdWU4NDk2NzkwNTU=",
    "number": 427,
    "title": "Добавить string_view перегрузки для stoi и istringstream",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-03T15:23:34Z",
    "updated_at": "2021-04-03T15:26:07Z",
    "closed_at": "2021-04-03T15:25:59Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +??, -??\r\n_Автор идеи:_ ??\r\n\r\nПредложение улучшает философию C++ \"Не платить за то, что не используется\" для stoi и istringstream т.к. в стандартной библиотеке в приведенных ситуациях приходится платить созданием временной строки, которая в дальнейшем не используется.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/427/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/427/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/426",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/426/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/426/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/426/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/426",
    "id": 849304357,
    "node_id": "MDU6SXNzdWU4NDkzMDQzNTc=",
    "number": 426,
    "title": "Добавить operator [] на std::tuple, std::variant, std::pair",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T16:07:55Z",
    "updated_at": "2021-04-02T16:11:09Z",
    "closed_at": "2021-04-02T16:11:02Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +??, -??\r\n_Автор идеи:_ ??\r\n\r\n```cpp\r\n// example\r\n\r\nstd::tuple<int, double, float> my_tuple;\r\n\r\nint first = my_tuple[ _1  ]; \r\ndouble second = my_tuple[ _2 ];\r\nfloat third = my_tuple[ _3 ];\r\n\r\n\r\nstd::pair< std::string, bool > p;\r\n\r\nstd::string s = p[ _1 ] ;\r\nbool b = p[ _2 ];\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/426/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/426/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/425",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/425/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/425/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/425/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/425",
    "id": 849298059,
    "node_id": "MDU6SXNzdWU4NDkyOTgwNTk=",
    "number": 425,
    "title": "Запретить присвоение арифметические типы в std::string",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T15:58:57Z",
    "updated_at": "2021-04-02T16:02:33Z",
    "closed_at": "2021-04-02T16:02:02Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +??, -??\r\n_Автор идеи:_ ??\r\n\r\nбыло бы хорошо если  добавили эту:\r\n\r\n \r\n\r\n```cpp\r\n//Microsoft (R) C/C++ Optimizing Compiler Version 19.00.23506 for x64\r\n\r\n#include <type_traits>\r\n\r\ntemplate< typename char_type>\r\n   class basic_string\r\n{    \r\n  public:   \r\n    basic_string& operator = (char c);\r\n    \r\n    template< typename T , class = typename std::enable_if< std::is_integral<T>::value && ! std::is_same<T, char_type>::value >::type >\r\n    basic_string& operator = (T ) = delete;\r\n};\r\n\r\ntypedef basic_string<char> string;\r\nint main()\r\n{\r\n    string s;\r\n    s = 'a';\r\n    \r\n    s = 23; // error C2280: 'basic_string<char> &basic_string<char>::operator =<int,void>(T)': attempting to reference a deleted function\r\n        //with\r\n        //[\r\n        //    T=int\r\n        //]\r\n      //(15): note: see declaration of 'basic_string<char>::operator ='\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/425/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/424",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/424/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/424/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/424/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/424",
    "id": 849294220,
    "node_id": "MDU6SXNzdWU4NDkyOTQyMjA=",
    "number": 424,
    "title": "scope_guard и on_exception_guard для освобождения ресурсов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T15:51:20Z",
    "updated_at": "2021-04-07T08:45:58Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -1\r\n_Автор идеи:_ ??\r\n\r\nДля обеспечения нужного уровня безопасности исключений бывает необходимо при выходе из области видимости выполнить какой-то код (например, освободить ресурс) даже, если код прерван исключением. При этом не всегда удобно создавать отдельный объект, управляющий ресурсом, например, если идет работа с чисто C-шным кодом. Для этого я предлагаю стандартизировать scope_guard и on_exception_guard, со вспомогательными методами их создания make_scope_guard() make_on_exception_guard().\r\n```cpp\r\nint main()\r\n{\r\n    int fd = ::open( \"/etc/passwd\", O_RDWR );\r\n    if( fd == -1 )\r\n        exit( EXIT_FAILURE );\r\n    auto fd_guard = make_scope_guard( [=](){ ::close( fd ); } );\r\n    // make_scope_guard() создает объект scope_guard, в деструкторе которого выполнится переданный код\r\n    do_somth_with( fd );\r\n    close( fd );        // если закрывать fd до выхода из области видимости не нужно,\r\n    fd_guard.release(); // тогда эти две строки можно вообще не писать\r\n\r\n    do_some_more();\r\n    \r\n    return 0;\r\n}\r\n```\r\nПри использовании такого кода в реальности оптимизитор выбросит все ненужное, в т.ч. и создание объекта scope_guard, при этом сгенерирует код, в котором при любом выходе из области видимости будет вызван close().\r\n\r\nПри вызове make_scope_guard(), создается объект scope_guard и ему передается лямбда для выполнения в деструкторе ~scope_guard(). Также у scope_guard есть метод release() для отмены выполнения кода в деструкторе и для симметричности acquire(), хотя не уверен, что он нужен. Примерная реализация:\r\n```cpp\r\ntemplate <typename T>\r\nstruct scope_guard\r\n{\r\n    scope_guard( T code )\r\n        :code( code )\r\n        ,own( true )\r\n    {}\r\n    scope_guard( scope_guard&& other )\r\n        :code( other.code )\r\n        ,own( true )\r\n    { other.own = false; }\r\n    scope_guard& operator=( scope_guard&& other ) = delete;\r\n    ~scope_guard() { if( own ) code(); }\r\n\r\n    scope_guard( const scope_guard& ) = delete;\r\n    scope_guard& operator=( const scope_guard& ) = delete;\r\n\r\n    void release() { own = false; }\r\n    void acquire() { own = true; }\r\n    T code;\r\n    bool own;\r\n};\r\n\r\n/**\r\n * @code{.cpp}\r\n * auto fd_guard = make_scope_guard( [=](){ ::close( fd ); } );\r\n * @endcode\r\n */\r\ntemplate <typename T>\r\nscope_guard<T> make_scope_guard( T code )\r\n{\r\n    return scope_guard<T>( code );\r\n}\r\n```\r\n\r\nУ такого подхода есть один мелкий недочет - при создании scope_guard может вылететь исключение, однако, это возможно только при копировании захватываемых переменных по значению, однако в реальности все сколько-нибудь нетривиальные переменные scope_guard будет захватывать по ссылке.\r\n\r\non_exception_guard отличается от scope_guard лишь тем, что выполняет переданный код в деструкторе только при выходе из области видимости по исключению. В нужности методов release(), а тем более acquire() я сильно сомневаюсь. Реализация:\r\n```cpp\r\ntemplate <typename T>\r\nstruct on_exception_guard\r\n{\r\n    on_exception_guard( T code )\r\n        :code( code )\r\n    {}\r\n    ~on_exception_guard()\r\n    {\r\n#ifdef __cpp_lib_uncaught_exceptions\r\n        if ( std::uncaught_exceptions() > 0 )\r\n#else\r\n        if ( std::uncaught_exception() )\r\n#endif\r\n            code();\r\n    }\r\n    T code;\r\n};\r\n\r\ntemplate <typename T>\r\non_exception_guard<T> make_on_exception_guard( T code )\r\n{\r\n    return on_exception_guard<T>( code );\r\n}\r\n```\r\nP.S. Можно обсуждать имена методов и типов, их функциональность и реализацию, но, по-моему, бесспорно, что нечто с функциональностью scope_exit давно пора стандартизировать.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/424/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/424/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/423",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/423/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/423/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/423/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/423",
    "id": 849285448,
    "node_id": "MDU6SXNzdWU4NDkyODU0NDg=",
    "number": 423,
    "title": "Контракты не переименовывать expects/ensures на pre/post",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-02T15:33:36Z",
    "updated_at": "2021-04-05T12:11:21Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nКонтракты не переименовывать expects/ensures на pre/post\r\n\r\nEWG на последнем заседании по С++20 в Коне одобрила на переименовывание контрактов для предусловия и постусловия expects/ensures на pre/post.\r\nEvolution Working Group (EWG) \r\n\r\nAt the last meeting, EWG finalized the feature set for C++20. At Kona, we focused on finalizing those features:\r\n\r\n*   Contracts: We worked on refining the feature. The only change this meeting was renaming expects/ensures to pre/post.\r\n\r\nНазвание pre/post не говорят что это предусловия или постусловия. Может быть уже лучше precond/postcond.\r\n\r\nНазвание expects/ensures как названия для контрактов используются также в других языках.\r\n\r\nrequire/ensure используется в Eiffel. \r\n\r\nПредлагаю не переименовывать expects/ensures контракта. А добавить еще один контракт invariant для проверки полей класса.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/423/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/423/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/422",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/422/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/422/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/422/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/422",
    "id": 849283921,
    "node_id": "MDU6SXNzdWU4NDkyODM5MjE=",
    "number": 422,
    "title": "Добавить в switch атрибут [[autobreak]]",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T15:30:45Z",
    "updated_at": "2021-10-04T11:54:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Игорь Савенков**\r\n\r\nСобственно, предлагаю добавить в switch атрибут [[autobreak]]\r\nИз названия можно догадаться, что autobreak нужен чтобы меньше писать break;\r\n\r\nАргументы \"за\":\r\n\r\nИмхо, ситуации, когда break пропущен и это сделано намеренно возникают значительно реже, чем когда он просто забыт по недосмотру, (яркое подтверждение этого - существование [[fallthrough]]). Поэтому неплохо бы иметь способ поменять поведение по-умолчанию.\r\n\r\nС этим атрибутом код становится чуть лаконичнее. Вместо такого:\r\n```cpp\r\nswitch (direction) \r\n{\r\ncase Dir::left:\r\n    moveLeft();\r\n    break;\r\ncase Dir::right:\r\n    moveRight();\r\n    break;\r\ndefault:\r\n    notMove();\r\n    break;\r\n}\r\n```\r\nБудет немного более короткая версия. Ну и удастся избежать ошибок со случайно пропущенным break\r\n```cpp\r\n[[autobreak]] switch (direction) \r\n{\r\ncase Dir::left:\r\n    moveLeft();\r\ncase Dir::right:\r\n    moveRight();\r\ndefault:\r\n    notMove();\r\n}\r\n```\r\nМожно убрав переносы строк даже еще чутка сократить, почти не потеряв читаемость (но здесь уже вкусовщина)\r\n```cpp\r\n[[autobreak]] switch (direction) \r\n{\r\ncase Dir::left:  moveLeft();\r\ncase Dir::right: moveRight();\r\ndefault:         notMove();\r\n}\r\n```\r\n ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/422/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/422/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/421",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/421/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/421/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/421/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/421",
    "id": 849281289,
    "node_id": "MDU6SXNzdWU4NDkyODEyODk=",
    "number": 421,
    "title": "alias для базового класса",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T15:25:43Z",
    "updated_at": "2022-01-01T02:54:40Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -1\r\n_Автор идеи:_ **Даниил Милютин**\r\n\r\nПри наследовании (особенно с шаблонами) возникает следующая ситуация\r\n```cpp\r\ntemplate<typename T1, typename T2, typename T3>\r\nclass Derived: public Base<T1, T2>, protected Policy<T3>\r\n{\r\nprotected:\r\n  using help = Policy<T3>;\r\npublic:\r\n  using super = Base<T1, T2>;\r\n  void foo()\r\n  {\r\n    super::foo(help::someMethod());//\r\n  }\r\n};\r\n```\r\nПриходится два раза вбивать ( = копипастить) имя класса, чтобы получить alias.\r\n\r\nПредлагается сократить boilerplate следующим образом:\r\n```cpp\r\ntemplate<typename T1, typename T2, typename T3>\r\nclass Derived: public Base<T1, T2> => super, protected Policy<T3> => help\r\n{\r\npublic:\r\n  void foo()\r\n  {\r\n    super::foo(help::someMethod());//\r\n  }\r\n};\r\n```\r\nПредполагается, что alias находятся в той же области видимости и имеют те же модификаторы доступа.\r\n\r\nЕсли очень хочется управлять областью видимости и модификаторами доступа alias, то\r\nможно предложить следующий синтаксис:\r\n```cpp\r\ntemplate<typename T1, typename T2, typename T3>\r\nclass Derived\r\n    : public Base<T1, T2> => private super\r\n    , public Policy<T3> => private help\r\n{/*...*/};\r\n```\r\nХотя в этом случае мне видится разумным использовать старый синтаксис.\r\n\r\nСимвол \"=>\" мне пока что видится самым уместным.\r\nЕго можно бы заменить на \"=\" или на \"->\" или на \"typedef\" или даже на ключевое слово as.\r\n(Последнее маловероятно.)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/421/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/421/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/420",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/420/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/420/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/420/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/420",
    "id": 849280479,
    "node_id": "MDU6SXNzdWU4NDkyODA0Nzk=",
    "number": 420,
    "title": "Директива связывания extern \"N\" для стандартов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T15:24:10Z",
    "updated_at": "2021-04-02T15:24:41Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -2\r\n_Автор идеи:_ **Александр Коновалов**\r\n\r\nВ этой идеи и сам недоконца уверен, но всё же захотелось услышать мнение других.\r\n\r\nУ языка C++ есть старая \"болезнь\" (но для некоторых и приятная особенность): очень сильная обратная совместимость. Она ограничивает или усложняет введение нового функционала. Для хотя бы частичного решения данной проблемы есть идея указывать используемый стандарт в директиве extern (например: extern \"c++11\" { ... }). Таким образом, старый код можно будет обернуть данной директивой, не боясь проблем обратной совместимости. В рамках данной идеи также предлагается пропускать конструкции с невалидной строкой (а скорее даже выводить warning).\r\n\r\nЧем хороша для этого extern? Во-первых, такой подход используется для включения C кода в C++, а также аналогичный для использования C++ и C в D. Во-вторых, есть уже готовая и проверенная языковая конструкция. В-третьих, такую конструкцию также можно использовать для кастомных расширений C++ какими-либо компиляторами (а может даже библиотеками, которые ставятся как плагины к компиляторам).\r\n\r\nУ этого подхода есть и отрицательные стороны. Во-первых, необходимость оборачивать старый код. Во-вторых, без особых приёмов оборачивания (вроде тех, которые используются в заголовочных файлах C библиотеки в C++) такой код потеряет возможность быть скомпилированным на старых версиях компиляторов, т.к. текущая реализация предполагает генерацию ошибки при использовании строки с недопустимым содержимым. В-третьих, при использовании данного подхода при подключении кастомных расширений языка, не понятно, как разрулить случаи использования разных расширений или старого стандарта с расширением.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/420/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/420/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/419",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/419/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/419/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/419/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/419",
    "id": 849272992,
    "node_id": "MDU6SXNzdWU4NDkyNzI5OTI=",
    "number": 419,
    "title": "Разделить стандартную библиотеку на уровни",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-02T15:10:30Z",
    "updated_at": "2022-08-11T17:40:27Z",
    "closed_at": "2022-08-11T17:40:13Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -1\r\n_Автор идеи:_ **Александр Коновалов**\r\n\r\nИдея очень абстрактная, но всё же интересно мнение сообщества на её счёт.\r\n\r\nЗдесь и не только замечал проблему многоцелевого использования C++. Есть люди, которые используют C++ для крупных проектов, у которых нет недостатка в ресурсах, а есть люди, которые используют C++ в системах с ограниченными ресурсами. Они не редко сталкиваются лбами: в крупных проектах хочется видеть много разных функций и возможностей, но это приводит к разрастанию стандартной библиотеки. Стоит отметить, сейчас например для микроконтроллеров разработчики не редко прибегают к альтернативным её реализациям или вовсе отказу от неё.\r\n\r\nВидимо при создании Java его разработчики столкнулись с аналогичной проблемой, решением которой стало разделение платформы на 4 уровня: Java Card, Java ME, Java SE, Java EE. Более старшая платформа включает функции более младшей.\r\n\r\nМоё предложение состоит в том, чтобы применить такую схему и для стандартной библиотеки. Что бы это могло дать? Во-первых, runtime библиотеку можно было бы разделить в соответствие с этими уровнями. Таким образом, на платформах с ограниченными ресурсами не пришлось бы тащить весь runtime. Во-вторых, это дало бы возможность появлению компиляторов с \"урезанной\" реализацией, которые декларировали бы поддержку только конкретных уровней.\r\n\r\nЭто совсем сырая идея, так что какой либо конкретики, вроде количество уровней, распределение функционала по ним, необходимость реализации для самого языка и т.д., у меня нет.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/419/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/419/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/418",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/418/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/418/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/418/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/418",
    "id": 849270068,
    "node_id": "MDU6SXNzdWU4NDkyNzAwNjg=",
    "number": 418,
    "title": "constexpr std::strlen(const char*)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Neargye",
        "id": 7997966,
        "node_id": "MDQ6VXNlcjc5OTc5NjY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Neargye",
        "html_url": "https://github.com/Neargye",
        "followers_url": "https://api.github.com/users/Neargye/followers",
        "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
        "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
        "organizations_url": "https://api.github.com/users/Neargye/orgs",
        "repos_url": "https://api.github.com/users/Neargye/repos",
        "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Neargye/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-02T15:04:57Z",
    "updated_at": "2021-04-11T19:57:31Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +16, -0\r\n_Автор идеи:_ **Yuriy Chernyshov**\r\n\r\nПо факту многие современные компиляторы имеют функцию __builtin_strlen, которая является constexpr.\r\nНужно только закрепить эту возможность в стандарте.\r\n\r\nНа ::strlen такие требования наложить, понятно, не получится.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/418/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/418/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/417",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/417/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/417/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/417/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/417",
    "id": 849269131,
    "node_id": "MDU6SXNzdWU4NDkyNjkxMzE=",
    "number": 417,
    "title": "Нужны перегрузки для std::string_view для функций std::atoXX, std::stoXX",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T15:03:11Z",
    "updated_at": "2021-04-02T15:04:13Z",
    "closed_at": "2021-04-02T15:04:08Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -0\r\n_Автор идеи:_ **Ivan Kalinin**\r\n\r\nВ текущей реализации функций std::atoXX требуют, чтобы переданная строка завершалась 0, что часто не подходит для std::string_view. В то же время есть std::stoXX, но для их использования надо создавать целый объект std::string, что не очень эффективно.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/417/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/417/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/416",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/416/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/416/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/416/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/416",
    "id": 849267742,
    "node_id": "MDU6SXNzdWU4NDkyNjc3NDI=",
    "number": 416,
    "title": "C++ ML",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T15:00:31Z",
    "updated_at": "2021-04-02T15:00:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -7\r\n_Автор идеи:_ **artur1ivanov**\r\n\r\nДобавить machine learning в C++ . Например в виде добавления этой либы mlpack.org",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/416/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/416/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/415",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/415/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/415/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/415/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/415",
    "id": 849256316,
    "node_id": "MDU6SXNzdWU4NDkyNTYzMTY=",
    "number": 415,
    "title": "добавить constexpr как модификатор для аргументов функции",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T14:39:32Z",
    "updated_at": "2021-04-02T14:59:33Z",
    "closed_at": "2021-04-02T14:59:27Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +22, -0\r\n_Автор идеи:_ **Юра Левченко**\r\n\r\nОчень часто мы имеем легаси код, где аргументы функции известны на этапе компиляции, и мы можем компилятору подсказать об этом.\r\n\r\nРасмотрим небольшой пример: \r\n```cpp\r\ntest(a, 0);\r\ntest(a, 1);\r\ntest(a, 2);\r\n\r\nint test( int a, constexpr int flag )\r\n{\r\n switch( flag )\r\n {\r\n   case 0:\r\n     return a + 1;\r\n   case 1:\r\n     return a - 1;\r\n   case 2:\r\n     return -a;\r\n   default:\r\n     return 0;\r\n }\r\n}\r\n```\r\nесли второй параметр задать как constexpr, то можно на этапе компиляции создать 3 функции, по аналогии\r\n```cpp\r\ntest<0>(a);\r\ntest<1>(a);\r\ntest<2>(a);\r\n\r\ntemplate<int flag>\r\nint test( int a )\r\n{\r\n switch( flag )\r\n {\r\n   case 0:\r\n     return a + 1;\r\n   case 1:\r\n     return a - 1;\r\n   case 2:\r\n     return -a;\r\n   default:\r\n     return 0;\r\n }\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/415/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/414",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/414/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/414/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/414/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/414",
    "id": 849253736,
    "node_id": "MDU6SXNzdWU4NDkyNTM3MzY=",
    "number": 414,
    "title": "Поддержать P1427R0 (Concerns about module toolability)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T14:34:44Z",
    "updated_at": "2021-04-02T14:37:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Сергей Прейс**\r\n\r\nПринятые в C++20 модули в том виде, в котором они сейчас зафиксированы создадут кучу проблем системам сборки и могут вызвать фрагментирование на уровне систем сборки (проект сможет собираться одной системой сборки, но не сможет быть адаптирован под другую). В P1427R0 приведён целый ряд проблем и предложены разумные решения. Я предлагаю поддержать это выступление.\r\n\r\nВкратце смысл https://wg21.link/P1427R0 таков:\r\n\r\nДля следующих проблем должны быть так или иначе предложены решения в стандарте на C++ модули.\r\n\r\n1. Мапирование модулей на исходный код. Система сборки должна иметь возможность быстро и однозначно понять где расположен импортируемый модуль в файловой системе. Без этого будет очень сложно сделать эффективное перестроение по зависимостям. Как пример плохих модулей (как в C++ сейчас приводится FORTRAN 90 [1]). Хорошие модули, например, в Go.\r\n\r\n2. Производительность параллельной сборки. Хотя кажется, что модули улучшают время компиляции в больших проектах, где без параллельной компиляции не обойтись, модули могут замедлять сборку. Сборка С/С++ сейчас очень хорошо масштабируется, с модулями это свойство теряется. Небольшое исследование этой проблемы есть в [2]\r\n\r\n3. Импорт или иклуд: из-за нетривиальных требований к структуре модуляризированного кода и отличии этой структуры от обычного (legacy) кода системе сборки очень сложно понять есть ли у файла модульные (не текстовые) зависимости. Системе сборки придётся обрабатывать худший случай и прекомпилировать код, даже если это полностью обычный (legacy) код.\r\n\r\nПредлагается:\r\n\r\n- Ревью модулей в SG-15 (the Tooling Study group ))\r\n\r\n- Стандартизация связывания модулей с файлами\r\n\r\n- Упрощение синтаксиса импортов\r\n\r\n- Дать возможность производителям инструментов попробовать поддержать модули и прислушаться к их мнению",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/414/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/414/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/413",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/413/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/413/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/413/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/413",
    "id": 849251761,
    "node_id": "MDU6SXNzdWU4NDkyNTE3NjE=",
    "number": 413,
    "title": "Починить std::invoke_result_t",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      },
      {
        "id": 3771028573,
        "node_id": "LA_kwDOFK7cns7gxVRd",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23-ru-comment",
        "name": "C++23-ru-comment",
        "color": "21DB3A",
        "default": false,
        "description": "Идея, которую можно попробовать отправить коментарием от страны к C++23"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T14:30:57Z",
    "updated_at": "2022-01-27T06:34:36Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -0\r\n_Автор идеи:_ **Дмитрий**\r\n\r\nВ шаблоне-псевдониме std::invoke_result_t есть ошибка, из-за которой он не всегда работает там, где работает обычная std::invoke_result. Хотя, очевидно, они должны быть полностью взаимозаменяемы.\r\n\r\nСуть проблемы:\r\n```cpp\r\n#include <type_traits>\r\n\r\n// Мы знаем, что {Xs...} == {F, Args...}, но не хотим упоминать F явно.\r\ntemplate <typename... Xs>\r\nvoid f (Xs...)\r\n{\r\n    // Всё работает.\r\n    using good = typename std::invoke_result<Xs...>::type;\r\n    // Ошибка компиляции.\r\n    using bad = std::invoke_result_t<Xs...>; // !\r\n}\r\n\r\nstruct call\r\n{\r\n    int operator () () const\r\n    {\r\n        return 0;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    f(call{});\r\n}\r\n```\r\nПолучается, что псевдоним std::invoke_result_t нарушает \"сигнатуру\" оригинальной метафункции std::invoke_result, ломая тем самым вполне корректный код.\r\n\r\nДумаю, что правильная реализация будет выглядеть так:\r\n```cpp\r\n// Правильно.\r\ntemplate <typename... Xs>\r\nusing invoke_result_t = typename std::invoke_result<Xs...>::type;\r\n```\r\nА текущая реализация ошибочна:\r\n```cpp\r\n// Неправильно.\r\ntemplate <typename X, typename... Xs>\r\nusing invoke_result_t = typename std::invoke_result<X, Xs...>::type;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/413/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/413/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/412",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/412/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/412/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/412/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/412",
    "id": 849249095,
    "node_id": "MDU6SXNzdWU4NDkyNDkwOTU=",
    "number": 412,
    "title": "std::initializer_list должен быть применим к move-only объектам",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T14:25:59Z",
    "updated_at": "2021-04-02T14:29:26Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Евгений Гагауз**\r\n\r\nЛегко продемонстрировать ограничение применимости класса std::initializer_list на простом примере инициализации вектора move-only объектов:\r\n```cpp\r\n#include <vector>\r\n\r\nstruct MoveOnly {\r\n    MoveOnly() = default;\r\n    MoveOnly(MoveOnly&&) = default;\r\n};\r\n\r\nstd::vector<MoveOnly> vec = {MoveOnly()};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/412/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/412/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/411",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/411/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/411/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/411/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/411",
    "id": 849245865,
    "node_id": "MDU6SXNzdWU4NDkyNDU4NjU=",
    "number": 411,
    "title": "std::type_fn и std::value_fn для работы с std:type_identity в value-based контексте",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T14:19:56Z",
    "updated_at": "2021-04-02T14:21:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nПредлагается добавить std::type_fn и std::value_fn для оборачивания метафункций в constexpr функторы, которые в качестве аргументов используют std::type_identity\r\n\r\nЧтобы следовать тенденции комитита относительно метапрограммирования в сторону value-based подхода, предлагается как можно раньше добавить следующие сущности:\r\n```cpp\r\ntemplate <template <class...> class F>\r\nstruct type_fn {\r\n    template <class... Ts>\r\n    constexpr auto operator()(type_identity<Ts>...) {\r\n        return type_identity<typename F<Ts...>::type>{};\r\n    }\r\n};\r\ntemplate <template <class...> class F>\r\nconstexpr type_fn<F> type_fn_v;\r\n\r\ntemplate <template <class...> class F>\r\nstruct value_fn {\r\n    template <class... Ts>\r\n    constexpr auto operator()(type_identity<Ts>...) {\r\n        return F<Ts...>::value;\r\n    }\r\n};\r\ntemplate <template <class...> class F>\r\nconstexpr value_fn<F> value_fn_v;\r\n```\r\nЭто поможет использовать метафункции в value-based контексте:\r\n```cpp\r\nconstexpr std::type_identity<int> t1;\r\nconstexpr std::type_identity<double> t2;\r\n\r\nconstexpr auto common_type_v = std::type_fn_v<std::common_type>;\r\nconstexpr auto is_same_v = std::value_fn_v<std::is_same>\r\n\r\nconstexpr auto t3 = common_type_v(t1, t2);\r\nstatic_assert(is_same_v(t3, std::type_identity<double>{}));\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/411/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/411/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/410",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/410/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/410/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/410/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/410",
    "id": 849243687,
    "node_id": "MDU6SXNzdWU4NDkyNDM2ODc=",
    "number": 410,
    "title": "Вести ключевое слово self",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-02T14:15:59Z",
    "updated_at": "2021-10-17T19:06:17Z",
    "closed_at": "2021-10-17T19:06:07Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -12\r\n_Автор идеи:_ **Vyacheslav Meshkov**\r\n\r\nНаверное многие в коде встречали конструкции вроде (*ptr).func(), которые в отличие от ptr->func() выглядят достаточно странно. Примерно то же самое хочется сказать, когда в коде приходится применять конструкции вроде this-> или *this: return *this или (*this)[10] для вызова оператора []. В этом плане представляется интересным ввести ключевое слово self, которое будет являться ни чем иным, как синтаксическим сахаром. По сути аналогом:\r\n```cpp\r\n#define self (*this)\r\n```\r\nПолучаем на результате\r\n```cpp\r\nreturn *this; => return self;\r\n\r\n(*this)[10]; => self[10];\r\n\r\nthis->func(); => self.func(); // вот это требуется достаточно редко, но иногда необходимо\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/410/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/410/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/409",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/409/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/409/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/409/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/409",
    "id": 849241908,
    "node_id": "MDU6SXNzdWU4NDkyNDE5MDg=",
    "number": 409,
    "title": "Математическая библиотека для работы с векторами, матрицами и кватернионами с поддержкой simd",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-02T14:12:34Z",
    "updated_at": "2021-05-04T17:37:55Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -0\r\n_Автор идеи:_ **damir3**\r\n\r\nНужна стандартная математическая библиотека для работы с векторами, матрицами и кватернионами.\r\n\r\nОчень не хватает стандартной математической библиотеки для работы с векторами, матрицами и кватернионами с поддержкой simd. Если работаешь с компьютерной графикой или физикой, то при использовании сторонних библиотек всегда приходится иметь дело с несколькими разными реализациями математических библиотек. Стандарта до сих пор нет и поэтому у всех разная реализация.\r\n\r\n \r\n\r\nДля библиотеки желательна максимальная совместимость с OpenGL Shading Language в наименовании функций и типов. За основу можно взять библиотеку glm https://glm.g-truc.net или фрейворк simd из XCode https://developer.apple.com/documentation/simd.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/409/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/409/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/408",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/408/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/408/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/408/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/408",
    "id": 849237568,
    "node_id": "MDU6SXNzdWU4NDkyMzc1Njg=",
    "number": 408,
    "title": "Для static inline статических членов класса слово inline лишнее.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T14:04:01Z",
    "updated_at": "2021-04-02T14:04:49Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **Vyacheslav Meshkov**\r\n\r\n```cpp\r\nclass A {\r\n    static const int ivar = 0;\r\n    static const inline std::string = \"text\";\r\n...\r\n};\r\n```\r\nЗаменить на:\r\n```cpp\r\nclass A {\r\n    static const int ivar = 0;\r\n    static const std::string = \"text\";\r\n...\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/408/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/408/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/407",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/407/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/407/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/407/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/407",
    "id": 849234093,
    "node_id": "MDU6SXNzdWU4NDkyMzQwOTM=",
    "number": 407,
    "title": "Задепрекейтить basic_string::operator=(CharT)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      },
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:57:25Z",
    "updated_at": "2021-04-02T14:02:18Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -2\r\n_Автор идеи:_ **Айдар Фаттахов**\r\n\r\nОн неконсистентен с конструкторами, ставит новичков в тупик, имеет тысячи альтернатив.\r\n\r\n```cpp\r\nstring s;\r\ns=100500; //UB\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/407/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/407/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/406",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/406/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/406/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/406/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/406",
    "id": 849232935,
    "node_id": "MDU6SXNzdWU4NDkyMzI5MzU=",
    "number": 406,
    "title": "Добавить в стандартные контейнеры перегрузки begin(), end() с rvalue ref-qualifiers, возвращающие move_iterator<iterator>",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-04-02T13:55:24Z",
    "updated_at": "2021-04-02T13:56:26Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -1\r\n_Автор идеи:_ **Andrey Davydov**\r\n\r\nВ настоящее время нет удобного способа помувать данные из временного контейнера, для этого используются костыли std::make_move_iterator и алгоритм std::move вместо std::copy. Однако, если придерживаться идеи, что контейнер владеет своими элементами, что кажется очень естественным в идеологии STL, то получается, что элементы временного контейнера тоже временные, а значит, их можно мувать без лишних телодвижений.\r\n\r\nРассмотрим такой код:\r\n```cpp\r\nstruct OnlyMovable {\r\n    OnlyMovable(OnlyMovable&&) = default;\r\n    OnlyMovable(OnlyMovable const &) = delete;\r\n};\r\n\r\nOnlyMovable modify(OnlyMovable o)\r\n{\r\n    // do something with `o`\r\n    // ...\r\n\r\n    return o;\r\n}\r\n\r\nstd::vector<OnlyMovable> produce();\r\n\r\n// я предполагаю, что реализация std::transform от range в С++20\r\n// должна работать примерно так\r\ntemplate<typename Range, typename OutIt, typename Functor>\r\nvoid transform(Range && range, OutIt out, Functor f)\r\n{\r\n    using std::begin, std::end, std::forward;\r\n    std::transform(begin(forward<Range>(range)),\r\n                   end  (forward<Range>(range)),\r\n                   out, f);\r\n}\r\n\r\nvoid test()\r\n{\r\n    std::vector<OnlyMovable> out;\r\n    transform(produce(), std::back_inserter(out), modify);\r\n}\r\n```\r\nСейчас он не скомпилируется, так как у нас не получится передать элемент вектора в функцию modify по значению. Это можно поправить, если заменить return type функции produce() на что-то подобное:\r\n```cpp\r\ntemplate<typename T>\r\nstruct myvector {\r\n    using iterator = T*;\r\n    using const_iterator = T const *;\r\n\r\n    iterator                        begin()        & ;\r\n    iterator                        end()          & ;\r\n    const_iterator                  begin()  const & ;\r\n    const_iterator                  end()    const & ;\r\n    std::move_iterator<iterator>    begin()        &&;\r\n    std::move_iterator<iterator>    end()          &&;\r\n};\r\n```\r\nи, соответственно, добавить перегрузки функций std::begin, std::end от rvalue-ranges.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/406/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/406/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/405",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/405/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/405/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/405/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/405",
    "id": 849231482,
    "node_id": "MDU6SXNzdWU4NDkyMzE0ODI=",
    "number": 405,
    "title": "Добавить математического сахара в (multi)set",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:52:38Z",
    "updated_at": "2021-04-02T13:53:41Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -5\r\n_Автор идеи:_ **mrgordonfreman**\r\n\r\nКак минимум хотелось бы иметь перегрузки операторов +=, \\= для выражения объединения и разности множеств.\r\n\r\nОпределяем множество целых чисел p.\r\n```cpp\r\nstd::set<int> p;\r\n```\r\nПрисваиваем p множество {1, 3, 5}.\r\n```cpp\r\np = {1, 3, 5};\r\n```\r\nЗдесь все хорошо, есть перегрузка оператора = со списком инициализации. Оперируем символами, а не контейнером.\r\n\r\nДалее хотим добавить новые элементы в множество p, т.е. выполнить объединение.\r\n```cpp\r\np += {5, 7, 11};\r\n```\r\nНо так, к сожалению, не работает. Приходится опускаться на уровень контейнера и вызывать соответствующий метод.\r\n```cpp\r\np.insert({5, 7, 11});\r\n```\r\nДобавление через оператор += близко к описанию алгоритма на псевдокоде. Его можно выразить через уже имеющийся insert\r\n```cpp\r\nset& operator+=( std::initializer_list<value_type> il ) {\r\n    insert(il);\r\n    return *this;\r\n}\r\n\r\ntemplate<class Comp, class Alloc>\r\nset& operator+=( std::set<value_type, Comp, Alloc> const& oth ) {\r\n    insert(oth.begin(), oth.end());\r\n    return *this;\r\n}\r\n```\r\nПерегрузка для отдельного значения не нужна, т.к. запись через список инициализации {1} наглядно показывает, что работаем с множествами.\r\n\r\nТакая сокращенная запись будет полезна для спортивного программирования - снижает вероятность опечатки и количество набираемых символов, и как следствие позволяет быстрее отправить решение на проверку.\r\n\r\nАналогичным образом можно определить оператор /= для разности множеств.\r\n```cpp\r\nset& operator/=( std::initializer_list<value_type> il ) {\r\n    for (auto& x: il)\r\n        erase(x);\r\n    return *this;\r\n}\r\n\r\ntemplate<class Comp, class Alloc>\r\nset& operator/=( std::set<value_type, Comp, Alloc> const& oth ) {\r\n    for (auto& x: oth)\r\n        erase(x);\r\n    return *this;\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/405/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/405/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/404",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/404/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/404/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/404/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/404",
    "id": 849230279,
    "node_id": "MDU6SXNzdWU4NDkyMzAyNzk=",
    "number": 404,
    "title": "maximum/minimum",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:50:32Z",
    "updated_at": "2022-02-19T11:26:16Z",
    "closed_at": "2022-02-19T11:26:16Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Айдар Фаттахов**\r\n\r\nСейчас для этого совсем нет функторов, в scan/accumulate не засунуть без обертки лямбдой либо явного выбора перегрузки.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/404/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/404/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/403",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/403/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/403/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/403/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/403",
    "id": 849228772,
    "node_id": "MDU6SXNzdWU4NDkyMjg3NzI=",
    "number": 403,
    "title": "Legacy C++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:47:41Z",
    "updated_at": "2021-04-02T13:49:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -11\r\n_Автор идеи:_ **andrewandrew1andrew**\r\n\r\n\r\nРазделить C++ На две части. \r\n\r\nДо С++11 оставить один стандарт со всеми зависимостями. После выкинуть всё лишнее и С образное то есть можно будет писать на версии С++11 и выше без всего что было до. \r\n\r\nП.С  Ногами  не пинать иногда пишу на плюсах. Любитель",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/403/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/403/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/402",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/402/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/402/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/402/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/402",
    "id": 849228063,
    "node_id": "MDU6SXNzdWU4NDkyMjgwNjM=",
    "number": 402,
    "title": "Расширить атрибут deprecated",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:46:22Z",
    "updated_at": "2021-04-02T13:46:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -9\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ языке Java версии 9 анотация Deprecated была расширена на параметры. Параметр since указывает с какой версии стал устаревшим, а параметр forRemoval указывает надо удалять или нет в будущем.\r\n```java\r\n@Deprecated(since=\"9\", forRemoval=true)\r\npublic void test() {}\r\n```\r\nПредлагаю в С++ расширить атрибут deprecated на параметры since и for_removal. Полезно для помечания устаревших функций, классов и т.п. в стандарте.\r\n```cpp\r\n[[deprecated(cause=\"bad method\", since=\"C++17\", for_removal=true)]]\r\nvoid routine() {\r\n   // some code\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/402/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/402/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/401",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/401/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/401/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/401/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/401",
    "id": 849216994,
    "node_id": "MDU6SXNzdWU4NDkyMTY5OTQ=",
    "number": 401,
    "title": "Удалить бросания исключения примитивного типа",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:25:31Z",
    "updated_at": "2021-04-02T13:26:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -7\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С++17 удалили с стандарта [Dynamic exception specification](https://en.cppreference.com/w/cpp/language/except_spec). Для того чтобы использовать свои исключения, мы должны создать класс и унаследоваться от std::exception. Мы должны переопределить метод what(). Но в стандарте мы можем кидать исключения еще примитивного типа.\r\n```cpp\r\ntry {\r\n  throw 5;\r\n} catch (...) {\r\n   cout << \"what does it mean?\" << endl;\r\n}\r\n```\r\nНа практике исключения такого типа безполезны. Во-первых, если как в коде выше, то все понятно. Во-вторых, если это исключение брошеное в какой-то библиотеке, где мы имеем только заголовочные файлы. Это кошмар! Во-третих, каждый программист согласится, что это плохая техника написания кода. Предлагаю удалить с стандарта кидания исключения примитивного типа и оставить только кидания типа класса.\r\n```cpp\r\ntry {\r\n  routine();\r\n} catch (const understand_exception& e) {\r\n    cout << \"Catch understand exception: \" << e.what() << endl;\r\n}\r\n```\r\nНадеюсь что в стандарт добавят stacktrace. В Java stacktrace используется с исключениями с начала добавления исключения. Хотелось в С++ иметь также. В С++17 начали чистить языковые и библиотечные возможности. Надеюсь что это также попадет под чистку.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/401/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/401/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/400",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/400/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/400/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/400/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/400",
    "id": 849216321,
    "node_id": "MDU6SXNzdWU4NDkyMTYzMjE=",
    "number": 400,
    "title": "C++ стандартизировать роботу с базами данных",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T13:24:11Z",
    "updated_at": "2021-04-02T13:24:15Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -11\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nНа улице почти 2019 год, а в С++ нету библиотеки в стандарте для работы с БД. Хотелось чтобы было добавлено, как работа с файловою системою, сетями и другими. Язык развивается очень классно, но хотелось иметь с коробки также работу с базами данных. Введутся какие то работы в этом направлении в стандарте?\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/400/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/400/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/399",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/399/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/399/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/399/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/399",
    "id": 849215226,
    "node_id": "MDU6SXNzdWU4NDkyMTUyMjY=",
    "number": 399,
    "title": "Отделить функцию хеширования std::hash от собственно хешируемых данных",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 13,
    "created_at": "2021-04-02T13:22:11Z",
    "updated_at": "2021-11-05T08:21:17Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **Igor Baidiuk**\r\n\r\nРазделить процесс хеширования на \"провайдер данных\" и собственно \"хешер\", попутно позволив реализовывать \"провайдер данных\" для типов независимо от std::hash\r\n\r\nНебольшое введение. На данный момент, если пользователь желает реализовать функцию хеширования для своего типа данных, у него есть два пути\r\n\r\n1. Свой функтор.\r\nДостоинства:\r\n+ очевидно и \"прямолинейно\"\r\nНедостатки:\r\n- надо явно использовать во всех контейнерах\r\n- надо вручную реализовывать \"микширование\" хешей компонентов в единый хеш\r\n- хешер оказывается \"прибит гвоздями\" к конкретному алгоритму хеширования\r\n2. Специализация std::hash\r\nДостоинства:\r\n+ Будет использован автоматически\r\nНедостатки:\r\n- \"Влазить\" в namespace std не поощряется стандартом за исключением оговорённых случаев\r\n- надо вручную реализовывать \"микширование\" хешей компонентов в единый хеш\r\n- хешер оказывается \"прибит гвоздями\" к конкретному алгоритму хеширования\r\n\r\nИтак, собственно proposal sketch\r\n\r\nТипы, желающие быть хешированными, добавляют либо метод\r\n```cpp\r\ntemplate<typename Hasher>\r\nvoid hash(Hasher& hasher) const;\r\n```\r\nлибо свободную функцию\r\n```cpp\r\ntemplate<typename Hasher>\r\nvoid hash(MyType const& self, Hasher& hasher);\r\n```\r\nМетод при выборе имеет приоритет. Свободная функция позволяет реализовать хеш для типов, для которых автор забыл это сделать.\r\nНазначение - передать набор значимых для хеша конкретного экземпляра байт в экземпляр хешера, при этом не принимая никаких решений относительно того, как эти байты будут хешироваться и комбинироваться. Пример реализации:\r\n```cpp\r\nstruct MyVec {\r\n    double x, y, z;\r\n\r\n    template<typename Hasher>\r\n    void hash(Hasher& hasher) const {\r\n        hasher(x);\r\n        hasher(y);\r\n        hasher(z);\r\n    }\r\n};\r\n```\r\nВторым компонентом этой системы является непосредственно хешер (ниже пример примитивного хешера)\r\n```cpp\r\nstruct MyHasher {\r\n    void operator()(const void* bytes, size_t nBytes) {\r\n        accumulated = myFancyHashFunc(accumulated, bytes, nBytes);\r\n    }\r\n\r\n    template<typename T>\r\n    void operator()(T&& value) {\r\n        hasher_traits<MyHasher>{}(*this, std::forward<T>(value));\r\n    }\r\n\r\n    size_t hash() const noexcept { return accumulated; }\r\nprivate:\r\n    size_t accumulated = StarterHashConstant;\r\n};\r\n```\r\nГде hasher_traits являются аналогом allocator_traits и реализуют поддержку хеширования значений конкретных типов, приводя их к единственной реализации хеширования произвольного набора байт.\r\n\r\nПреимущества:\r\n+ Каждому конкретному типу не требуется ни знать про хеширование как таковое, ни даже про метод \"примешивания\" байт к имеющемуся хешу - к примеру, отпадает головная боль как правильно соединить хеши трёх чисел с плавающей точкой\r\n+ Тип может быть хеширован любым подходящим по месту способом, а не так, как решил автор типа\r\n+ В месте использования контейнера можно использовать нестандартный алгоритм хеширования без необходимости переопреелять его для всех типов по месту\r\n+ Наконец, результат хеширования не обязан быть всегда size_t, и конкретному типу совершенно не нужно об этом знать. Любой тип, поддерживающий хеширование, можно при необходимости пропустить через CRC32, MD5, SHA1, SHA512 и т.п. При этом стандартные контейнеры могут всё так же спокойно требовать size_t как тип результата хеширования.\r\n\r\nКак всё это встроить в текущую модель.\r\nСтандартом предполагается наличие \"включенных\" и \"выключенных\" реализаций std::hash. При этом большинство реализаций выключены по умолчанию с помощью бланкет-реализации для любого типа T. Эту бланкет-реализацию можно расширить поддержкой указанных систем хеширования. Таким образом, std::hash по умолчанию приобретает примерно следующий вид\r\n```cpp\r\nnamespace std {\r\n    template<Hashable T>\r\n    struct hash {\r\n        size_t operator()(T const& value) const {\r\n            std::hasher hasher;\r\n            hasher(value);\r\n            return hasher.hash();\r\n        }\r\n    };\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/399/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/399/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/398",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/398/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/398/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/398/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/398",
    "id": 849118235,
    "node_id": "MDU6SXNzdWU4NDkxMTgyMzU=",
    "number": 398,
    "title": "Добавить для std::string_view конструктор от итераторов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-02T09:50:23Z",
    "updated_at": "2022-02-19T10:46:32Z",
    "closed_at": "2022-02-19T10:46:26Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -5\r\n_Автор идеи:_ **Антон**\r\n\r\nДобавить для std::string_view конструктор от итераторов, аналогичный конструктору в std::string\r\n\r\nНапример, можно будет упростить использование std::string_view и std::regex\r\n```cpp\r\n    std::string_view x = \"123.123.123.123\";\r\n\r\n    std::match_results<std::string_view::const_iterator> match;\r\n    std::regex_search(x.begin(), x.end(), match, std::regex(R\"(([0-9]{3})\\.([0-9]{3})\\.([0-9]{3})\\.([0-9]{3}))\"));\r\n\r\n    // c++17\r\n    std::string_view token1(&(*match[1].first), match[1].length());\r\n    // or\r\n    std::string_view token2(&(*match[2].first), std::distance(match[2].first, match[2].second));\r\n\r\n    // motivation example\r\n    //std::string_view token3(match[3].first, match[3].second);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/398/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/397",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/397/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/397/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/397/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/397",
    "id": 849117240,
    "node_id": "MDU6SXNzdWU4NDkxMTcyNDA=",
    "number": 397,
    "title": "Создание одиночки языковыми средствами",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T09:48:12Z",
    "updated_at": "2022-08-11T18:45:56Z",
    "closed_at": "2022-08-11T18:45:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -15\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nПочти в каждой программе нужно создавать классы, которые имеют один единственный объект. Для этого используется паттерн Одиночка.\r\n```cpp\r\n/* definition */\r\nclass singleton {\r\npublic:\r\n        static singleton& get_instance() {\r\n                static singleton instance;\r\n                return instance;\r\n        }\r\n\r\n        void some_function() {\r\n             cout << \"I am singleton!\" << endl;\r\n        }\r\n\r\nprivate:        \r\n        singleton() = default;\r\n       ~singleton() = default;\r\n\r\n        singleton(const singleton&) = delete;\r\n        singleton& operator=(const singleton&) = delete;\r\n};\r\n\r\n/* use */\r\nsingleton::get_instance().some_function();\r\n```\r\nПри этом мы пишем много лишнего кода. В языках Kotlin, Scala можно создавать одиночку проще и легко. Мы описывает класс и создаем один класс.\r\n```cpp\r\n/* definition */\r\nobject singleton {    \r\n    void some_function() {\r\n        cout << \"I am singleton!\" << endl;\r\n    }\r\n};\r\n\r\n/* use */ \r\nsingleton.some_function();\r\n```\r\n \r\n\r\nБыло классно если можно было бы в С++ писать подобным образом.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/397/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/397/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/396",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/396/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/396/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/396/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/396",
    "id": 849116201,
    "node_id": "MDU6SXNzdWU4NDkxMTYyMDE=",
    "number": 396,
    "title": "Принять в стандарт С++ расширения gcc C и gcc C++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T09:46:03Z",
    "updated_at": "2021-04-02T09:47:14Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -3\r\n_Автор идеи:_ **NeoProgramming**\r\n\r\nВ компиляторе gcc реализовано множество полезных расширений. В отличие от множества новых проектируемых возможностей языка, нередко весьма сложных даже для понимания, данные расширения простые, они проверены и работают. Их давно следует стандартизировать.\r\n\r\nРасширения Си: https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html\r\n\r\nРасширения С++: https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html\r\n\r\nНе знаю, нужно ли их здесь все перечислять. Некоторые расширения Си уже реализованы в новейших версиях Си и С++. Но в целом там очень много полезного.\r\n\r\nМоя статья на Хабре https://habr.com/post/315676/ , там достаточно подробно все расписано. Впрочем, если модераторы посчитают нужным, можно просто вставить текст оттуда.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/396/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/395",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/395/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/395/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/395/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/395",
    "id": 849115159,
    "node_id": "MDU6SXNzdWU4NDkxMTUxNTk=",
    "number": 395,
    "title": "Неявная инициализация переменных значением по умолчанию",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T09:43:51Z",
    "updated_at": "2023-10-23T07:38:37Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -13\r\n_Автор идеи:_ **valera_ee**\r\n\r\nРаботая над большим проектом, который начал своё начало ещё до С++11, столкнулся с проблемами адаптации кода под новый стандарт. Все поля класса инициализируются в конструкторе или в списке инициализации, около 95% такой инициализации это присваивание переменным класса 0 или NULL. \r\n```cpp\r\nclass ClassName\r\n{\r\npublic:\r\n    ClassName(ClassParent *p);\r\n    ~ClassName();\r\n\r\n    void setValue(int value);\r\n    int value() const;\r\n\r\nprivate:\r\n    ClassParent *pParent;\r\n    bool m_enable;\r\n    int  m_value;\r\n};\r\n```\r\nСейчас можно прописать инициализацию в заголовочном файле:\r\n```cpp\r\nclass ClassName\r\n{\r\npublic:\r\n    ClassName(ClassParent *p);\r\n    ~ClassName();\r\n\r\n    void setValue(int value);\r\n    int value() const;\r\n\r\nprivate:\r\n    ClassParent *pParent {nullptr};\r\n    bool m_enable {false};\r\n    int  m_value  {0};\r\n};\r\n```\r\n Возникает логичный вопрос, почему изначально не инициализировать базовые типы нулём, а указатели значением nullptr ? А там где требуется указать значение, отличное от значения по умолчанию, там прописывать вручную. \r\n\r\nБыл случай когда указатель забыли проинициализировать и там по мусорному адресу происходило обращение и программа не падала при этом, если бы указатель был нулевым, то ошибку обнаружили бы сразу.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/395/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/395/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/394",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/394/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/394/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/394/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/394",
    "id": 849113552,
    "node_id": "MDU6SXNzdWU4NDkxMTM1NTI=",
    "number": 394,
    "title": "Переименовать ключевые слова co_await, co_yield",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T09:40:25Z",
    "updated_at": "2021-04-02T09:42:56Z",
    "closed_at": "2021-04-02T09:42:56Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -2\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВсе как и я надеюсь что на февральской встрече по стандартизации в С++20 добавлят корутины. Возможность программировать ассинхронно с коробки на уровне языка очень классно. Но ключевые слова которые предлагаются очень отвратительные. Хочется чтобы можно было использовать как в C# await, yield и все. C выступа Гора Нишанова было сказано что слова await и yield очень часто используемые, поэтому предлагаю сделать контексные слова await, yield, а вместо ключевого слова co_return использовался простой return. В модулях ведь хотят сделать module, import контексными, почему бы в корутинах этого не сделать.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/394/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/394/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/393",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/393/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/393/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/393/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/393",
    "id": 849113115,
    "node_id": "MDU6SXNzdWU4NDkxMTMxMTU=",
    "number": 393,
    "title": "Добавить sealed классы",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T09:39:28Z",
    "updated_at": "2021-04-16T11:34:14Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С++11 добавили контексные ключевые слова final, override. В языках C#, Kotlin (и в скором времени в Java) есть упакованные классы. Мы можем определить список ограниченных классов наследников от базового класса.\r\n\r\nПредлагаю добавить контекстное ключевое слово sealed так как final, override.\r\n```cpp\r\nclass figure sealed {\r\n   virtual int square() const;\r\n  \r\n   class triangle;\r\n   class rectangle;\r\n};\r\n\r\nclass triangle : figure {            // ok\r\n   int square() override { ... }\r\n}\r\n\r\nclass rectangle : figure {           // ok\r\n   int square() override { ... }\r\n}\r\n\r\nclass circle : figure {              // error\r\n   int square() override { ... }\r\n}\r\n```\r\n   ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/393/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/393/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/392",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/392/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/392/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/392/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/392",
    "id": 849112275,
    "node_id": "MDU6SXNzdWU4NDkxMTIyNzU=",
    "number": 392,
    "title": "Добавить тэг std::aggregate_t и использующие его фабричные функции",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T09:37:42Z",
    "updated_at": "2021-04-02T09:38:27Z",
    "closed_at": "2021-04-02T09:38:20Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nЧасто бывает нужно создать объект через aggregate initialization или list initialization.\r\nКогда речь идет о объектах в куче, мы используем std::make_unique или std::make_shared. Однако они не могут вызвать list или aggregate initialization (и правильно делают).\r\nПредлагаю добавить тэг std::aggregate, который будет говорить о том, что объект нужно создать с помощью aggregate или list initialization.\r\n\r\nБывает нужно, чтобы работал такой код:\r\n```cpp\r\nstruct some_aggregate_t {\r\n    int i;\r\n    std::string s;\r\n};\r\n\r\nauto value = std::make_unique<some_aggregate_t>(5, \"lol\"); // error: no matching constructor for initialization of 'some_aggregate_t'\r\n```\r\nstd::make_unique пытается вызвать конструктор у some_aggregate_t, вместо aggregate initialization. Поведение ожидаемое и понятное, но хочется уметь создавать такие объекты без необоходимости дописывать конструктор.\r\n\r\nЕще один пример:\r\n```cpp\r\nauto v = std::make_shared<std::vector<int>>(5, 2);\r\nassert(*v == std::vector<int>{2, 2, 2, 2, 2});\r\n```\r\nВ данном коде создается вектор с 5-ью 2-ками.\r\n\r\nПредлагается добавить tag type std::aggregate_t, позволяющий специализировать вызов std::make_unique и std::make_shared:\r\n```cpp\r\nauto valid = std::make_unique(std::aggregate, 5, \"lol\"); // ok\r\n\r\nauto v = std::make_shared<std::vector<int>>(std::aggregate, 5, 2);\r\nassert(*v == std::vector<int>{5, 2});\r\n```\r\nВозможная реализация std::make_unique:\r\n```cpp\r\ntemplate <class T, class... Args>\r\nstd::unique_ptr<T> make_unique(std::aggregate_t, Args&&... args) {\r\n    return std::unique_ptr<T>(new T{std::forward<Args>(args)...});\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/392/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/392/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/391",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/391/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/391/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/391/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/391",
    "id": 849110024,
    "node_id": "MDU6SXNzdWU4NDkxMTAwMjQ=",
    "number": 391,
    "title": "Метод take, позволяющий извлечь значение из std::optional",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T09:33:12Z",
    "updated_at": "2021-04-02T09:36:32Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -0\r\n_Автор идеи:_ **Mikhail Trishchenkov**\r\n\r\nНужен метод у std::optional, который возвращает по значению текущее содержимое, оставляя optional пустым.\r\n\r\nОчень часто требуется забрать значение из optional, оставив его пустым. Но подходящего метода нет. *std::move(opt) хотя и перемещает значение, не делает optional пустым, внутри остаётся «мёртвое» значение. Хотелось бы чего-то такого:\r\n```cpp\r\ntemplate <T> T std::optional::take() { .. }\r\n\r\nstd::optional<int> opt_value(2);\r\n\r\nint value = opt_value.take();\r\n\r\nassert(value == 2);\r\n\r\nassert(opt_value.empty());\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/391/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/391/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/390",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/390/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/390/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/390/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/390",
    "id": 849109158,
    "node_id": "MDU6SXNzdWU4NDkxMDkxNTg=",
    "number": 390,
    "title": "Добавить больше специализаций hash для контейнеров",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      },
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T09:31:29Z",
    "updated_at": "2021-04-02T09:32:03Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Alexander** @ZaMaZaN4iK\r\n\r\n\r\nПредлагаю добавить специализации struct hash для большинства контейнеров из Стандартной библиотеки таких как array, vector, tuple, valarray, deque, list, forward_list, map, set, multimap, multiset; адаптеров  queue и stack; basic_string со пользовательским типом charT и аллокатором; для pair. \r\n\r\nПодробно с предложением можно ознакомиться по этой ссылке\r\n\r\nБуду рад обсудить здесь.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/390/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/390/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/389",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/389/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/389/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/389/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/389",
    "id": 849108252,
    "node_id": "MDU6SXNzdWU4NDkxMDgyNTI=",
    "number": 389,
    "title": "std::visit для std::tuple",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-02T09:29:32Z",
    "updated_at": "2021-04-02T09:30:28Z",
    "closed_at": "2021-04-02T09:30:23Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -1\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nПредлагается добавить следующую функцию:\r\n```cpp\r\ntemplate <class Visitor, class Tuple>\r\nconstexpr /*see below*/ visit(Visitor&& v, Tuple&& t);\r\n```\r\nГде тип возвращаемого значения - это std::tuple со следующими подтипами:\r\n```cpp\r\nstd::invoke_result_t<Visitor&&, std::tuple_element<i, std::remove_cvref<Tuple>>>\r\n```\r\nДля i от 0 до std::tuple_size_v<std::remove_cvref<Tuple>> - 1.\r\n\r\nПример:\r\n```cpp\r\nstruct visiter {\r\n    int operator()(int a) { return a * 2; }\r\n    std::string operator(std::string b) { return b + b; }\r\n};\r\n\r\nstd::tuple t{5, 6, 8, \"abc\"s, \"def\"s};\r\n\r\nauto res = std::visit(visiter{}, t);\r\n\r\nassert(res == std::tuple{10, 12, 16, \"abcabc\"s, \"defdef\"s};\r\n```\r\nТакое visit также удобно использовать с предлагаемым overloaded.\r\n\r\nВозможная реализация:\r\n```cpp\r\ntemplate <class Visiter, class Tuple, std::size_t... Is>\r\nconstexpr auto visit(Visiter&& v, Tuple&& t, std::index_sequence<Ts...>) {\r\n    return std::tuple{\r\n        std::forward<Visiter>(v)(std::get<Is>(std::forward<Tuple>(t)))...\r\n    };\r\n}\r\n\r\ntemplate <class Visiter, class Tuple>\r\nconstexpr auto visit(Visiter&& v, Tuple&& t) {\r\n    return visit_impl(std::forward<Visiter>(v), std::forward<Tuple>(t),\r\n                      std::make_index_sequence<std::tuple_size_v<Tuple>>{});\r\n}\r\n```\r\nИз-за сложности работы с функцие в случае, если visiter имеет void в качестве возвращаемого значения для какого-то из типов, возможно, будет лучше добавить следующую функцию:\r\n```cpp\r\ntemplate <class Visitor, class Tuple>\r\nconstexpr void visit(Visitor&& v, Tuple&& t);\r\n```\r\nВозможная реализация:\r\n```cpp\r\ntemplate <class Visiter, class Tuple, std::size_t... Is>\r\nconstexpr auto visit(Visiter&& v, Tuple&& t, std::index_sequence<Ts...>) {\r\n    (..., std::forward<Visiter>(v)(std::get<Is>(std::forward<Tuple>(t))));\r\n}\r\n\r\ntemplate <class Visiter, class Tuple>\r\nconstexpr void visit(Visiter&& v, Tuple&& t) {\r\n    visit_impl(std::forward<Visiter>(v), std::forward<Tuple>(t),\r\n               std::make_index_sequence<std::tuple_size_v<Tuple>>{});\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/389/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/389/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/388",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/388/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/388/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/388/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/388",
    "id": 849107383,
    "node_id": "MDU6SXNzdWU4NDkxMDczODM=",
    "number": 388,
    "title": "Добавить std::variant_index по аналогии с std::variant_alternative",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T09:27:52Z",
    "updated_at": "2021-04-02T09:28:22Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nСейчас для std::variant можно узнать тип из его вариадичного списка по его индексу в нём, но нельзя сделать обратную операцию: узнать индекс типа.\r\n\r\nПредлагается добавить функцию std::variant_index/std::variant_index_v\r\n\r\nОна могла бы выглядеть как-то так:\r\n```cpp\r\ntemplate <class T, class V>\r\nstruct variant_index;\r\n\r\ntemplate <class T, class... Ts>\r\nstruct variant_index<T, std::variant<Ts...>>\r\n    : integral_contant<size_t, index_of<T, Ts..>::value>;\r\n\r\ntemplate <class T, class V>\r\nconstexpr size_t variant_index_v = variant_index<T, V>::value;\r\n```\r\nГде index_of - некая метафункция, возвращающая индекс типа T в списке типов std::variant.\r\n\r\nНужно также определить поведение этой функции:\r\n\r\nЕсли T не содержится в Ts... (или T содержится в Ts... больше 1 раза), то поведение не определено.\r\n\r\nВключать ли пункт про наличие T в Ts... больше одного раза - непонятно, это нужно обсудить.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/388/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/388/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/387",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/387/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/387/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/387/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/387",
    "id": 849105197,
    "node_id": "MDU6SXNzdWU4NDkxMDUxOTc=",
    "number": 387,
    "title": "type alias для Variadic Arguments или возврат Templates от класса",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-02T09:23:35Z",
    "updated_at": "2021-04-02T09:23:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Андрей Марцинкевич**\r\n\r\n\r\nРазрешить возможность создавать алиасы для Variadic Arguments или как-то по другому с ними работать. Подробнее в примере:\r\n\r\nДопустим есть функция\r\n```cpp\r\ntemplate <typename Tuple>\r\nvoid foo(Tuple::Args&&... args)\r\n{\r\n //DO WITH ARGS.\r\n}\r\n```\r\n\r\nИ для нее описан класс SomeTuple:\r\n```cpp\r\ntemplate<typename Args...>\r\nstruct SomeTuple\r\n{\r\n  using... Args = Args;\r\n}\r\n```\r\nЛибо как-то по другому.\r\n\r\nДля чего это надо.\r\n\r\nА нужно это для возможности агрегатной инициализации и что бы компилятор понимал сразу какие типы мы ожидаем.\r\n```cpp\r\nfoo<SomeTuple<SomeType1, SomeType2>>(/*SomeType 1*/{Param1, Param2}, /*SomeType 2*/{Param3, Param4})\r\n``` \r\n\r\n Через make_integer_sequence такое вроде не сделаешь;",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/387/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/387/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/386",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/386/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/386/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/386/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/386",
    "id": 848837284,
    "node_id": "MDU6SXNzdWU4NDg4MzcyODQ=",
    "number": 386,
    "title": "Починить семантический смысл auto для structured binding",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T22:49:01Z",
    "updated_at": "2021-04-02T06:12:42Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -5\r\n_Автор идеи:_ **Даниил Милютин**\r\n\r\nТекущая реализация structured binding (SB) не соответствует семантике auto.\r\nХочется чтобы для SB работали обычные правила auto для переменных.\r\n\r\nВ общем случае хочется следующее\r\n```cpp\r\n//I want\r\nauto cv ref [x1, /*...,*/ xN] = s;\r\n//to be equivalent to\r\nauto cv ref x1 = std::get<0>(s);\r\n//...\r\nauto cv ref xN = std::get<N>(s);\r\n```\r\nСейчас это не так. Рассмотрим примеры в коде. (Код примеров см. также [здесь](http://coliru.stacked-crooked.com/a/d7f0d36a300cef3a).)\r\n```cpp\r\nvoid do_smth_with(int& i) { ++i; }\r\nvoid do_smth_with(double& x) { x = x+1; }\r\n\r\nvoid do_auto_with(std::tuple<int&, double&> t)\r\n{\r\n    auto [x, y] = t;\r\n    do_smth_with(x);// referenced by \"t[0]\" changed. Do we want this?\r\n    do_smth_with(y);// referenced by \"t[1]\" changed. Do we want this?\r\n}\r\n\r\nvoid do_auto_cref_with(std::tuple<int const&, double const&> t)\r\n{\r\n    auto [x, y] = t; // error: binding reference of type 'int&' to 'const int' discards qualifiers\r\n    do_smth_with(x);\r\n    do_smth_with(y);\r\n}\r\n\r\nvoid do_fixed_behavior_with(std::tuple<int&, double&> t)\r\n{\r\n    // I want auto [x,y] = t be this;\r\n    auto x = std::get<0>(t); \r\n    auto y = std::get<1>(t);\r\n    do_smth_with(x); //fine. changed temporary variable\r\n    do_smth_with(y); //fine. changed temporary variable\r\n    //referenced by tuple t did NOT change\r\n}\r\n\r\nvoid do_fixed_behavior_with(std::tuple<int const&, double const&> t)\r\n{\r\n    // I want auto [x,y] = t be this;\r\n    auto x = std::get<0>(t); \r\n    auto y = std::get<1>(t);\r\n    do_smth_with(x); //fine. changed temporary variable\r\n    do_smth_with(y); //fine. changed temporary variable\r\n    //referenced by tuple t did NOT change\r\n}\r\n```\r\nХочется, чтобы при использовании auto без ref-modifiers выводились не ссылочные типы, а значения.\r\n__________________________\r\n\r\nРасскажу, как я на это наткнулся.\r\n\r\nРешил я написать свой zip для коллекций. В итоге успешно взял код [отсюда](https://gist.github.com/mortehu/373069390c75b02f98b655e3f7dbef9a)\r\n\r\nПроблема была в том, что я использовал zip с постоянными коллекциями примерно так :\r\n```cpp\r\nfor(auto [x,y]: zip(vec_x, vec_y))\r\n   do_smth_by_nonconst_ref(x); // error\r\n// А ожидалось схожее с...\r\nfor(auto x: vec_x)\r\n   do_smth_by_nonconst_ref(x); // ok\r\n```\r\nzip_helper::iterator по постоянным коллекциям при разименовании возващает tuple состоящий из const ссылок. \r\nТип x,y выведен как постоянная ссылки.  И причина как раз в том как работает SB.\r\nДля получения желаемой временной переменной  писал следующий костыль (потом по-другому починил, но это другая история)\r\n```cpp\r\nfor(auto [x,y]: zip(vec_x, vec_y))\r\n{\r\n   auto X = x; // what a mess!!!\r\n   do_smth_by_nonconst_ref(X); \r\n}\r\n```\r\nПолучается, что в этом случае SB портят жизнь и увеличивают объём кода. И, как я уже объяснил выше, не соответствует семантике auto.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/386/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/386/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/385",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/385/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/385/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/385/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/385",
    "id": 848836162,
    "node_id": "MDU6SXNzdWU4NDg4MzYxNjI=",
    "number": 385,
    "title": "В С++20 добавить for constexpr вместо for...",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T22:45:56Z",
    "updated_at": "2021-04-06T19:17:25Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +23, -1\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С++20 хотят добавить предложение expansion statements, которая подраздумевает добавление цикла foreach для работы во времени компиляции. Последняя редакция имеется p1306r1.\r\n```cpp\r\nauto tup = std::make_tuple(0, ‘a’, 3.14);\r\nfor... (auto elem : tup) {\r\n   std::cout << elem << std::endl;\r\n}\r\n```\r\nКонструкция for... взята на подобии sizeof... . Но лучше сделать for constexpr на подобии к if constexpr.\r\n\r\nВ первой редакции p1306r0 предлагали два варианта: for... и for constexpr. В текущей редакции предлагается второй вариант писать следующим образом.\r\n```cpp\r\nfor... (constexpr meta::info member : members) {\r\n   hash_append(h, t.idexpr(member));\r\n}\r\n```\r\nЭто не красиво и так и проситься написать вот так:\r\n```cpp\r\nfor constexpr (meta::info member : members) {\r\n    hash_append(h, t.idexpr(member));\r\n}\r\n```\r\nВ предложении к статической рефлексии p0953r2 предлагается именно for constexpr.\r\n\r\nПредлагаю добавить for constexpr как друга для if constexpr.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/385/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/385/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/384",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/384/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/384/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/384/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/384",
    "id": 848835372,
    "node_id": "MDU6SXNzdWU4NDg4MzUzNzI=",
    "number": 384,
    "title": "Вложенные structured bindings",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T22:43:49Z",
    "updated_at": "2021-04-06T19:16:41Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +23, -2\r\n_Автор идеи:_ **Александр**\r\n\r\nНа текущий момент нет вложенности в structured binding declarations \r\n```cpp\r\nauto [a, b] = pair<int, pair<int, int>>;\r\n```\r\nb имеет тип `pair<int, int>`, но хотелось бы иметь возможность изначально создать идентификаторы для `std::get<0>(b)` и `std::get<1>(b)`:\r\n```cpp\r\nauto [a, [b, c]] = pair<int, pair<int, int>>;\r\n```\r\nт.е. внести в синтаксис\r\n```\r\nattribute-specifier-seq_opt decl-specifier-seq ref-qualifier_opt [ identifier-list ] initializer ;\r\n```\r\nподобные изменения:\r\n```\r\nattribute-specifier-seq_opt decl-specifier-seq ref-qualifier_opt [ bindings-list ] initializer ;\r\nbindings-list:\r\n   identifier-list\r\n   identifier-list_opt [ bindings-list ] identifier-list_opt\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/384/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/384/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/383",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/383/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/383/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/383/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/383",
    "id": 848835061,
    "node_id": "MDU6SXNzdWU4NDg4MzUwNjE=",
    "number": 383,
    "title": "optional_io",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T22:42:57Z",
    "updated_at": "2021-04-01T22:43:07Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -1\r\n_Автор идеи:_ **EVGVir**\r\n\r\nХочется аналог boost/optional/optional_io.hpp.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/383/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/383/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/382",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/382/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/382/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/382/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/382",
    "id": 848834812,
    "node_id": "MDU6SXNzdWU4NDg4MzQ4MTI=",
    "number": 382,
    "title": "Новый \"Специальный метод класса\"",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T22:42:16Z",
    "updated_at": "2021-04-01T22:42:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -8\r\n_Автор идеи:_ **James**\r\n\r\nПредлагаю рассмотреть специальный метод класса например @имя_класса.\r\n\r\nВ этом методе нужно писать try {/**/}catch(...){},  и если в классе он объявлен и определен все функции у которых нет спецификатор времени компиляции noexcept, обернуть этим блоком try,catch.\r\nТ.е. задать некий шаблон, и по нему обернуть все.\r\n\r\nПо семантике будет похож на  деструктор: т.е. его как можно объявлять явно так и не объявлять вовсе.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/382/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/382/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/381",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/381/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/381/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/381/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/381",
    "id": 848834100,
    "node_id": "MDU6SXNzdWU4NDg4MzQxMDA=",
    "number": 381,
    "title": "Потокобезопасный умный указатель",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T22:40:12Z",
    "updated_at": "2021-04-01T22:41:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -2\r\n_Автор идеи:_ **valera_ee**\r\n\r\nЧасто возникает идея в доступе к методам класса из разных потоков и каждый раз вручную приходится прописывать защиту мьютексом или спин локером, почему бы не автоматизировать этот процесс, сделав аналог shared_ptr , который делает доступ к любым методам класса потокобезопасным.\r\n\r\nНа просторах интернета встречаются решения, которые предоставляют вариант умного указателя, в котором доступ к ресурсу защищён либо мьютексом, либо спинлокером.  \r\n\r\nК примеру статья на хабре  https://habr.com/ru/post/328348/\r\n\r\nИмеено за простоту и удобство использование мне это решение очень нравится, хотя оно не лишено недостатков.\r\nДовольно элегантно выглядит решение:\r\n```cpp\r\nthread_safe_ptr<Object> p = make_thread_safe_ptr<Object>();\r\n\r\nvoid func_thread1(thread_safe_ptr<Object> p) \r\n{\r\n    // выполнение в потоке 1\r\n    p->process();\r\n}\r\n\r\nvoid func_thread2(thread_safe_ptr<Object> p) \r\n{\r\n    // выполнение в потоке 2\r\n    p->process();\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/381/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/381/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/380",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/380/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/380/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/380/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/380",
    "id": 848804262,
    "node_id": "MDU6SXNzdWU4NDg4MDQyNjI=",
    "number": 380,
    "title": "Добавить к библиотеке std::filesystem алиас fs",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T21:34:47Z",
    "updated_at": "2021-04-01T21:35:15Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -5\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С++17 была добавлена библиотека `std::filesystem`. При использовании к каждой функции нужно добавлять namespace std::filesystem. На практике в основном пишут алиас `fs`.\r\n\r\n```cpp\r\nnamespace fs = std::filesystem;\r\n}\r\n```\r\nПредлагаю добавить алиас к стандартной библиотеке и писать код проще.\r\n\r\n \r\n```cpp\r\nif(std::fs::is_regular_file(s)) {\r\n    std::cout << \" is a regular file\\n\";\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/380/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/380/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/379",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/379/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/379/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/379/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/379",
    "id": 848567108,
    "node_id": "MDU6SXNzdWU4NDg1NjcxMDg=",
    "number": 379,
    "title": "Библиотека флагов компиляции",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T15:25:39Z",
    "updated_at": "2021-04-06T19:17:02Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +21, -0\r\n_Автор идеи:_ **Андрей Руссков**\r\n\r\nДобавить модуль с набором constexpr-переменных, зависящих от флагов компиляции\r\n\r\nНи для кого не секрет, что как только поведение программы начинает зависеть от компилятора и системы сборки, начинается макросный ад. По сути, каждый пишет свои костыли для одного и того же.\r\n\r\n \r\n\r\nПредлагаю решение: простой модуль, в котором будет собран набор constexpr переменных/consteval функций, зависящих от всего этого внешнего безобразия и не транслирующий никакие из этих макросов наружу. По сути, упростит написание переносимых библиотек, в т.ч. и стандартной\r\n```cpp\r\nenum class build_type_t {\r\n    release,\r\n    debug,\r\n    profile,\r\n    // ...\r\n};\r\n\r\nconstexpr auto build_type = build_type_t::release/**/;\r\n\r\nconstexpr string_view toolchain_name = \"gcc\"/**/;\r\n\r\nstruct toolchain_version_t {\r\n    size_t major;\r\n    size_t minor;\r\n    size_t bugfix;\r\n    // ...\r\n};\r\n\r\nconstexpr toolchain_version_t toolchain_version { 9, 3, 1 /**/ };\r\n\r\nconsteval bool supports_standard(string_view revision) {\r\n    constexpr unordered_set<string_view> revisions = {\r\n        \"c++98\",\r\n        \"c++03\",\r\n        \"c++0x\",\r\n        \"c++11\",\r\n        \"c++0y\",\r\n        \"c++14\",\r\n        \"c++20\",\r\n        // ...\r\n    };\r\n\r\n    // Рано или поздно constexpr контейнеры всё равно заедут,\r\n    // как и contains, но можно написать через if constexpr\r\n    return revisions.contains(revision);\r\n}\r\n\r\nconsteval bool supports_feature(string_view feature) {\r\n    constexpr unordered_set<string_view> features = {\r\n        \"concepts\",\r\n        \"contracts\",\r\n        // ...\r\n    };\r\n    return features.contains(feature);\r\n}\r\n\r\nconsteval bool supports_architecture(/*...*/) { ...\r\n```\r\nну и так далее по аналогии.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/379/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/379/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/378",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/378/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/378/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/378/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/378",
    "id": 848565125,
    "node_id": "MDU6SXNzdWU4NDg1NjUxMjU=",
    "number": 378,
    "title": "закрыть дыру в механизме исключений",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T15:23:12Z",
    "updated_at": "2021-04-01T15:24:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -0\r\n_Автор идеи:_ **crusader**\r\n\r\nПо стандарту \"throw XYZ\" выделяет память под объект исключения \"in unspecified way\". Как следствие если это попытка аллокации проваливается -- поведение программы тоже \"unspecified\" и попытки обрабатывать нехватку памяти используя std:bad_alloc бессмысленны, ибо нет гарантии что само \"throw std::bad_alloc()\" в состоянии произойти.\r\n\r\nДетали тут https://stackoverflow.com/questions/45497684/what-happens-if-throw-fails-to-allocate-memory-for-exception-object/45552806. Соответствующее предложение см. https://wg21.link/P0770R0.\r\n\r\nИдея состоит в том чтобы ввести новое (эфемеральное) исключение, готорое гарантировано бросается независимо от состояния кучи. В контексте C++ Itanium ABI (используемого CLang/GCC/etc) это значит что если __cxa_allocate_exception() вернет NULL, то (вместо вызова std::terminate()) он будет передан в функции которые раскручивают стек и будет третироваться как специальный объект.\r\n\r\nКак вариант (и для упрощения кода) эфемеральным исключением может быть std::bad_alloc -- чтобы он ловился через catch(std::bad_alloc). Понадобится способ отличения эфемерального std::bad_alloc от обычного (\"bool std::is_ephemeral(std::bad_alloc&)\" ?).\r\n\r\nВ контексте программы это значит что (в случае Itanium ABI) при нехватке памяти \"throw MyException()\" вместо аварийного завершения бросит эфемеральный std::bad_alloc, который может быть обработан и т.п. К сожалению, это также означает, что \"throw 42\" может также бросить эфемеральное исключение  -- что может быть сюрпризом для пользователя (хотя это конечно лучше чем крэш или зависание, которое может случиться сейчас).\r\n\r\nЯ осознал, что у меня нет желания бороться с бюрократией комитета чтобы протолкнуть эту идею и закрыть эту дыру. Может у вас оно есть :-)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/378/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/377",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/377/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/377/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/377/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/377",
    "id": 848562366,
    "node_id": "MDU6SXNzdWU4NDg1NjIzNjY=",
    "number": 377,
    "title": "Make '=delete' greate again!",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T15:19:41Z",
    "updated_at": "2021-04-01T15:20:09Z",
    "closed_at": "2021-04-01T15:20:03Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -2\r\n_Автор идеи:_ **Сергей Аксенов**\r\n\r\nСейчас (Си++11) компилятор сначала выбирает перегрузку, а уже после смотрит какие методы удалены. В итоге иногда не может выбрать из 2 методов - удаленного и и нет.\r\n\r\nНапример, такой код работать не будет\r\n```cpp\r\n    class Class\r\n    {\r\n    public:\r\n        Class(uint64_t value);\r\n\r\n        operator uint64_t&();\r\n        operator const uint64_t&() const;\r\n\r\n        operator uint32_t&() = delete;\r\n        operator const uint32_t&() const = delete;\r\n\r\n    private:\r\n        uint64_t m_value;\r\n    };\r\ndouble val = Class(0); // ambiguous call (GCC)\r\n```\r\n\r\nВообще, конечно, эта идея вообще не сработает =( Просто это реальная попытка уменьшить боль от неявного приведения uint64_t к uint32_t. Особенно актуально для size_t, который отличается на x86 и x64.\r\n\r\nПодробнее здесь:\r\nhttps://stackoverflow.com/questions/38565358/call-ambigious-due-to-a-deleted-function\r\nhttps://stackoverflow.com/questions/13703186/ambiguous-overload-with-deleted-move-constructor",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/377/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/376",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/376/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/376/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/376/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/376",
    "id": 848559018,
    "node_id": "MDU6SXNzdWU4NDg1NTkwMTg=",
    "number": 376,
    "title": "vector::truncate",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T15:15:39Z",
    "updated_at": "2021-04-01T18:50:55Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Андрей Руссков**\r\n\r\nМетоды erase/resize могут не подходить для некоторых типов\r\n\r\n`vector::resize` требует чтобы тип значения был MoveInsertable и DefaultInsertable или CopyInsertable для разных перегрузок. vector::erase требует MoveAssignable. Таким образом, возможны типы, для которых ни один из вариантов не подходит. Минимальный пример:\r\n```cpp\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct S {\r\n    S(string s) : s(s) {}\r\n    S(S&&) = delete;\r\n    \r\n    string s;\r\n};\r\n\r\nint main() {\r\n    vector<S> v;\r\n    v.emplace_back(\"abc\");\r\n    v.emplace_back(\"def\");\r\n    v.emplace_back(\"ghi\");\r\n\r\n    v.erase(prev(v.end())); // error: S is not MoveAssignable\r\n    v.resize(v.size() - 1); // error: S is not DefaultInsertable and MoveInsertable\r\n}\r\n```\r\n \r\n\r\nПредлагаю ввести метод vector::truncate(size_t n), который удаляет лишние элементы с конца вектора если n < size(), и ничего не делает в противном случае. Такой метод будет требовать от типа только Eraseable. Помимо прочего, метод truncate нагляднее передает намерения программиста.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/376/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/376/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/375",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/375/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/375/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/375/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/375",
    "id": 848557575,
    "node_id": "MDU6SXNzdWU4NDg1NTc1NzU=",
    "number": 375,
    "title": "Сделать offsetof оператором",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T15:13:57Z",
    "updated_at": "2021-04-01T15:14:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **WPMGPRoSToTeMa**\r\n\r\nМотивация: уменьшить количество импортируемых макросов в связи с модулями. Также этот макрос нереализуем стандартными средствами (такая себе причина).\r\n\r\nСинтаксис естественно остаётся таким же.\r\n\r\nВозможные недостатки:\r\n\r\n- сломается код использующий defined(offsetof)\r\n\r\n- сломается код, который не инклюдит cstddef и использует offsetof как идентификатор для своих символов\r\n\r\n- меньше консистентности с C (?)\r\n\r\n- в C++ нет операторов, которые принимают имя члена класса в качестве параметра (?)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/375/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/375/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/374",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/374/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/374/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/374/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/374",
    "id": 848514651,
    "node_id": "MDU6SXNzdWU4NDg1MTQ2NTE=",
    "number": 374,
    "title": "Замечания к C++20",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T14:22:44Z",
    "updated_at": "2021-04-01T15:13:18Z",
    "closed_at": "2021-04-01T15:12:43Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nСобираем в коментариях замечания, баги и нодочёты готовящегося C++20.\r\n\r\nПожалуйста, делитесь мыслями и примерами.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/374/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/373",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/373/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/373/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/373/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/373",
    "id": 848513607,
    "node_id": "MDU6SXNzdWU4NDg1MTM2MDc=",
    "number": 373,
    "title": "constexpr virtual",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T14:21:37Z",
    "updated_at": "2021-04-01T14:22:01Z",
    "closed_at": "2021-04-01T14:21:56Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **skryv-softserveinc**\r\n\r\nЭта возможность уже была реализована в GCC4:\r\nПредлагаю добавить поддержку полиморфных виртуальных вызовов этапа компиляции с модификатором constexpr.\r\nhttps://stackoverflow.com/questions/34828161/can-virtual-functions-be-constexpr\r\nhttps://pastebin.com/gBRT31VG\r\n\r\n```cpp\r\n    struct X \r\n    {\r\n        constexpr virtual int f() const\r\n        {\r\n            return 0;\r\n        }\r\n    };\r\n    struct A : public X\r\n    {\r\n        constexpr virtual int f() const\r\n        {\r\n            return 1;\r\n        }\r\n    };\r\n    int main()\r\n    {\r\n        A x;\r\n        static_assert(x.f() == 1, \"match\");\r\n        return 0;\r\n    }\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/373/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/373/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/372",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/372/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/372/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/372/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/372",
    "id": 848511430,
    "node_id": "MDU6SXNzdWU4NDg1MTE0MzA=",
    "number": 372,
    "title": "Расширить возможности шаблонов до параметризированных синтаксических деревьев",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T14:19:03Z",
    "updated_at": "2021-04-01T14:20:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -3\r\n_Автор идеи:_ **NeoProgramming**\r\n\r\nШаблон - это объект времени компиляции; при передаче в шаблон какого-то параметра (типа или целочисленной константы), на самом деле передается не тип и не константа, а фрагмент синтаксического дерева.\r\n \r\nПоэтому я предлагаю расширить возможности шаблонов, приблизив их к возможностям синтаксических макросов:\r\n1. разрешить передавать в качестве аргументов любые корректные фрагменты синтаксического дерева, а не только типы и целочисленые константы. В частности, параметрами шаблонов могут быть константные строки; числа с плавающей точкой; корректные идентификаторы (не значения переменных, а именно имена!); выражения; и самый общий случай - корректные блоки кода.\r\n \r\n2. ввести шаблонную параметризацию не только для классов и функций, но и для других языковых конструкций - в самом общем случае для произвольных синтаксически корректных блоков кода. \r\n \r\nРассмотрим предложение подробнее.\r\n \r\nПервое, достаточно очевидное расширение - возможость передавать в качестве аргументов шаблонов константные литералы, отличные от целочисленных. Применение очевидно - значения по умолчанию, параметры алгоритмов, которые эффективнее не передавать через аргументы функций; различная метаинформация, которую можно ассоциировать с объектами.\r\n \r\n```cpp\r\ntemplate<typename T, const char *S>\r\nstruct NamedField\r\n{\r\n     T value;\r\n     const char *name = S;\r\n};\r\n// использование\r\nstruct Foo\r\n{\r\n  NamedField<std::string, \"User name\"> username_;\r\n  NamedField<int, \"User ID\"> id_;\r\n}\r\n```\r\n \r\nСтроковые литералы и числовые литералы с плавающей точкой ничем не хуже целочисленных; и нет никакой причины запрещать их передачу в шаблоны.\r\n \r\nВторое расширение - возможность передачи в шаблоны произвольных корректных фрагментов синтаксического дерева. Фактически, это более общий случай. Передавая в шаблон число или тип, мы передаем на самом деле именно фрагмент синтаксического дерева.\r\n \r\nФрагменты синтаксического дерева просто подставляются в код, в точности как это происходит в лексических макросах препроцессора. Для обозначения фрагментов синтаксических деревьев предлагается использовать отдельное ключевое слово. Можно воспользоваться существующим словом inline. Например, можно передать выражения:\r\n \r\n```\r\ntemplate<inline Condition, inline Expr>\r\nvoid Foo()\r\n{\r\n   while(Condition)\r\n     Expr;\r\n}\r\n// использование\r\nFoo< (x<0), { x++; } >();\r\n```\r\n \r\nВозможно, имеет смысл предусмотреть несколько ключевых слов для того, чтобы можно было ограничить вид фрагмента синтаксического дерева (т.е. концепты для этого). Отдельными видами могут быть\r\n- имена (пригодные для объявления переменных и констант)\r\n- блоки кода\r\n- выражения\r\n- декларативные объявления\r\n \r\nИнтересное следствие - возможность передавать в шаблоны типы, сформированные \"на лету\":\r\n```cpp\r\nstd::vector< struct { int x, y, z; } > myVec;\r\n```\r\nЭто может быть полезно для различной кодогенерации.\r\n \r\nТретье расширение - сами шаблоны могут быть не только классами и функциями.\r\nНаибольший интерес представляют шаблоны - блоки кода, которые можно вставить напрямую в существующий код. Для их обозначения также предлагается использовать слово inline. \r\n \r\n```cpp\r\ntemplate<unsigned int N, inline Expr>\r\ninline FixedLoop\r\n{\r\n   for(unsigned int i=0; i<N; i++)\r\n    Expr;\r\n}\r\n\r\n// применение\r\n//...\r\nFixedLoop<10, { foo(); }>;\r\n//...\r\n```\r\n \r\nКак частный случай, именованные блоки кода могут быть и не шаблонными. Т.е. шаблонные блоки кода это аналог параметризированных макросов (#define) то не шаблонные - аналог макросов без параметров. Просто заготовки кода, которые непосредственно вставляются туда, где вставлены их имена.\r\n \r\nЭто простые примеры, показывающие синтаксис предлагаемых расширений; я не сомневаюсь, что можно придумать немало практических применений данной возможности. Например в программировании для микроконтроллеров иногда требуется иметь полный контроль над кодом - в частности, в некоторых случаях недопустимы вызовы функций, и требуется явно вставлять код в обработчики прерываний. Приходится делать на лексических макросах, что само по себе не очень красиво и безопасно.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/372/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/372/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/371",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/371/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/371/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/371/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/371",
    "id": 848501436,
    "node_id": "MDU6SXNzdWU4NDg1MDE0MzY=",
    "number": 371,
    "title": "c++ template deduction by requested returned type",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T14:06:54Z",
    "updated_at": "2021-04-01T14:08:03Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -6\r\n_Автор идеи:_ **Fihtangolz**\r\n\r\n\r\n```\r\nPixel **image = matrix_allocate(height, width) -> Pixel **image = matrix_allocate(height, width)\r\n```\r\n\r\nВывод типа от запрашиваемого возврашаемого типа. \r\n```cpp\r\ntemplate<typename T>\r\nT matrix_allocate(int height, int width){\r\n    // some\r\n}",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/371/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/371/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/370",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/370/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/370/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/370/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/370",
    "id": 848412286,
    "node_id": "MDU6SXNzdWU4NDg0MTIyODY=",
    "number": 370,
    "title": "Разрешить использование концептов через requires в лямбда выражениях",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T12:15:27Z",
    "updated_at": "2021-04-01T12:16:14Z",
    "closed_at": "2021-04-01T12:16:14Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **Wellarium**\r\n\r\n\r\nВ С++20 будет добавлена возможность указать список параметров шаблона для generic лямбда выражений, что позволяет использовать конструкции std::enable_if, std::void_t и т.п. для наложения ограничений на типы аргументов. Концепты же вводятся с целью поддержки такой функциональности на уровне языка: они работают для шаблонов классов, функций, но с лямбдами есть ограничения. Предлагаю разрешить использование всех способов объявления концептов в лямбдах, пока еще не поздно, чтобы концепты можно было полноценно применять ко всем шаблонным конструкциям языка.\r\n\r\n```cpp\r\n#include <iostream>\r\n\r\ntemplate<typename T>\r\nconcept Addable = requires (T x) { x + x; }; \r\n\r\n\r\nint main() {\r\n\t\r\n\t[]<Addable T>(T a1, T a2) {\t\t//работает корректно\r\n\t\tstd::cout << a1 + a2;\r\n\t}(1, 2); \r\n\t\r\n\t/*[]<typename T> requires Addable<T> //уже не скомпилируется\r\n\t(T a1, T a2){ \r\n\t\tstd::cout << a1 + a2; \r\n\t}(3, 4); */\r\n\r\n\t/*[]<typename T> requires requires (T x) { x + x; } //не скомпилируется\r\n\t(T a1, T a2){ \r\n\t\tstd::cout << a1 + a2; \r\n\t}(5, 6); */\r\n\t\r\n\treturn 0;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/370/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/370/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/369",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/369/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/369/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/369/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/369",
    "id": 848409717,
    "node_id": "MDU6SXNzdWU4NDg0MDk3MTc=",
    "number": 369,
    "title": "хочу перегрузку оператора [] что бы как в питоне ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-04-01T12:11:51Z",
    "updated_at": "2022-01-03T08:34:05Z",
    "closed_at": "2022-01-03T08:34:05Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -11\r\n_Автор идеи:_ **dreverser**\r\n\r\nдать возможность перегружать оператор доступа к массиву []\r\nчто бы можно было использовать как в питоне [:-1] или [3:4] итд\r\n\r\nвроде бы от асма ушли в высокоуровневые языки\r\n\r\nа что то набирать букв приходиться еще больше для простых действий\r\n\r\nкак там смотрят в комиттете что бы определить перегрузку оператора []\r\n\r\nв нестандартной перегрузке внутри двоеточие :\r\n\r\nчто бы можно было под него загнать много всяких алгоритмов и операций над массивами, строками, и куда вздумается\r\n\r\n \r\n\r\nнадеюсь все поняли о чем я, и питон цитировать сюда не буду",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/369/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/369/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/368",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/368/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/368/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/368/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/368",
    "id": 848403518,
    "node_id": "MDU6SXNzdWU4NDg0MDM1MTg=",
    "number": 368,
    "title": "инициализация массивов для std::unique_ptr<... []>",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T12:03:04Z",
    "updated_at": "2021-04-01T12:10:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -1\r\n_Автор идеи:_ **Boris Vinogradov**\r\n\r\nВ C++ сущетвует конструкция для инициализации динамических массивов:\r\n```cpp\r\nint *y = new int[3]{1, 2, 3};\r\n```\r\nВ тоже время для создания массива объектов подобной конструкции нет.\r\n\r\nПредлагаю добавить инициалзиацию для массивов которые управляются std::unique_ptr:\r\n```cpp\r\nstd::unique_ptr x = make_unique<int []>({1, 2, 3});\r\n```\r\nТакже сделать дополнение конструктора unique_ptr для инциализации элементов подобным образом с помощью deduction guides.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/368/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/368/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/367",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/367/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/367/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/367/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/367",
    "id": 848401701,
    "node_id": "MDU6SXNzdWU4NDg0MDE3MDE=",
    "number": 367,
    "title": "Расслабить требования к передаче по ссылке временных объектов (как в MSVC)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T12:00:34Z",
    "updated_at": "2021-04-01T12:01:28Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -4\r\n_Автор идеи:_ **Даниил Милютин**\r\n\r\nПример.\r\n```cpp\r\nstruct ReferenceType\r\n{\r\n    ReferenceType(int* p, int s): ptr(p), size(s) {}\r\n    ~ReferenceType() {}\r\n    // contract:\r\n    //   some non-allocating functionality\r\n    //   data can be accessed and modified\r\n    //     but not allocated/deallocated\r\n    int at(int i) const { return ptr[i]; }\r\n    int& at(int i) { return ptr[i]; }\r\nprotected:\r\n    int* ptr = nullptr;\r\n    int  size = 0;\r\n};\r\n\r\nstruct ValueType: ReferenceType\r\n{   \r\n    // just memory management\r\n\r\n    ValueType(int N): ReferenceType(new int[N], N) {}\r\n    ~ValueType() { delete[] ptr; }\r\n};\r\n\r\nvoid do_smth(ReferenceType& w) { w.at(0) = 10; }\r\nvoid do_smth_rvr(ReferenceType&& w) { w.at(0) = 10; }\r\n\r\nvoid do_other(int& i) {}\r\n\r\nvoid do_other_rvr(int&& i) { do_other(i); }\r\n\r\nint main() {\r\n    ValueType s(3);\r\n    do_smth(s); // ok // converted to ReferenceType&\r\n\r\n    int data[3];\r\n    //do_smth(ReferenceType(+data, 3));// error // ok - only MSVC\r\n    //do_smth(ValueType(3));     // error // ok - only MSVC\r\n\r\n    \r\n\r\n    do_other(data[0]); // ok\r\n    //do_other(10); // error. And that's fine for me!\r\n                     // MSVC said: 'void do_other(int &)': \r\n                     //             cannot convert argument 1 from 'int' to 'int &')\r\n\r\n    do_smth_rvr(ReferenceType(+data, 3)); // that's eaten by MSVC and gcc\r\n    do_other_rvr(10);// that's eaten by MSVC and gcc\r\n                     // so temporary is implicitly created there\r\n\r\n    return data[0];\r\n}\r\n```\r\n\r\nСм. также:\r\nПример (by Jason Turner):\r\nhttps://www.youtube.com/watch?v=SnTV5BU9x6k\r\n\r\nПример горького опыта близкий к моему:\r\nhttps://forum.kde.org/viewtopic.php?f=74&t=88577\r\n\r\nПредлагается позволить указанному расширению MSVC войти в новый стандарт.\r\n\r\nЗ.Ы.\r\nКакие обходы для текущей стуации?\r\n1) Перегружать функцию принающую rv-reference. Не хочется по причине разрастания boilerplate.\r\nК тому же если, аргументов больше одного (N), то придётся писать 2^N вариантов. Совсем не хочется.\r\n\r\n2) Также можно было бы передавать ReferenceType по значению. Но это увеличит число копирований.\r\nА ReferenceType всё таки может весить побольше.\r\n\r\n3) Самый неправильный (и быстрый по написанию, и возможно по работе) workaround - это нагло врать компилятору.\r\nПрописывать аргумент как постоянную ссылку, а внутри приводить с const_cast к мутабельному состоянию.\r\nВ примере выше можно и без оного - в лоб, ибо const int* позволит мутировать данные, на которые указывает.\r\nОднако если ReferenceType устроен сложнее (например, содержит данные защищённо и к данным имеет доступ только через non-const методы), то придётся делать const_cast.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/367/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/367/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/366",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/366/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/366/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/366/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/366",
    "id": 848359882,
    "node_id": "MDU6SXNzdWU4NDgzNTk4ODI=",
    "number": 366,
    "title": "std::type_pack_element",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T10:56:44Z",
    "updated_at": "2021-04-01T11:00:55Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Andrey Davydov**\r\n\r\n\r\nПри работе с variadic templates часто бывает полезно получить i-й элемент из pack'а (к примеру, в реалзизации std::get<size_t> для tuple и variant). Соответственно, предлагается добавить в стандартную библиотеку template type alias `type_pack_element` с сигнатурой `<std::size_t I, typename ...Ts> using type_pack_element = ...`, который может быть реализован, как уже имеющимися языковыми средствами, что однако требует определенного числа инстанциаций шаблонов, так и, аналогично `std::make_integer_sequence`, через compiler intrinsic. В Clang'е уже есть __type_pack_element, поддержать в остальных компиляторах должно быть не сложно, и главное, практически бесплатно с точки зрения времени компиляции: variadic pack хранится в массиво-подобной структуре, и обратиться к элементу под индексу операция очень дешевая (в сравнении с инстанциацией шаблонов, overload resolution, ...).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/366/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/366/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/365",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/365/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/365/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/365/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/365",
    "id": 848358915,
    "node_id": "MDU6SXNzdWU4NDgzNTg5MTU=",
    "number": 365,
    "title": "Проверка, что один concept специализированнее другого",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T10:55:17Z",
    "updated_at": "2021-04-01T10:55:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Andrey Davydov**\r\n\r\nНад концептами определен частичный порядок, который влияет на выбор лучшего кандидата в overload resolution, специализации класса и т.д.\r\nПравила сравнения концептов нетривиальны, так что читая код убедиться в уме, что P subsume Q довольны сложно, куда надежнее будет написать `static_assert(__subsume(P, Q))`.\r\n\r\nДобавить в язык \"concept trait\" __subsume(...) ожидающий 2 (альтернативный вариант: >= 2) концепта. Аналогично уже имеющимся во всех популярных компиляторах (но не стандартизированным) type traits __is_final, __is_base_of, __is_constructible, __is_convertible, и т.д.\r\n\r\nПример использования:\r\n```cpp\r\ntemplate<typename It> concept InputIterator = ...;\r\ntemplate<typename It> concept ForwardIterator = ...;\r\ntemplate<typename It> concept BidirectionalIterator = ...;\r\ntemplate<typename It> concept RandomAccessIterator = ...;\r\n\r\nstatic_assert(__subsume(ForwardIterator, InputIterator));\r\nstatic_assert(__subsume(BidirectionalIterator, ForwardIterator));\r\nstatic_assert(__subsume(RandomAccessIterator, BidirectionalIterator));\r\n\r\n// альтернативный подход:\r\nstatic_assert(__subsume(RandomAccessIterator,\r\n                        BidirectionalIterator,\r\n                        ForwardIterator,\r\n                        InputIterator));\r\n```\r\nПоддержать __subsume на стороне компилятора очень просто -- упорядочивание концептов это операция которая компилятору в любом случае нужна.\r\n\r\nСинтаксис \"__subsume(...)\", возможно, не самый удачный, так как в данный момент нет прецендентов в стандарте C++, но de facto в популярных компиляторах уже есть builtin type traits, которые парсятся как выражения, так что добавить concept trait должно быть не сложно.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/365/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/365/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/364",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/364/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/364/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/364/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/364",
    "id": 848357949,
    "node_id": "MDU6SXNzdWU4NDgzNTc5NDk=",
    "number": 364,
    "title": "Включить TM TS в С++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T10:53:52Z",
    "updated_at": "2021-04-01T10:54:17Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -0\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nTransaction Memory TS была опублицирована в 2015. Подход который предлагает транзакционная память упрощает написание многопоточного кода.\r\nХотелось, чтобы можно было использовать не как расширение языка, а в стандарте.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/364/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/364/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/363",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/363/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/363/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/363/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/363",
    "id": 848357214,
    "node_id": "MDU6SXNzdWU4NDgzNTcyMTQ=",
    "number": 363,
    "title": "Дизайн предложения метаклассы",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T10:52:44Z",
    "updated_at": "2021-04-01T10:53:14Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -1\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nСделать более красивее синтаксис метаклассов\r\n\r\nВ текущем предложении по метаклассам одобрен синтаксис\r\n```cpp\r\nconstexpr void interface(meta::type target, meta::type source) {\r\n   ...\r\n}\r\n```\r\n\r\nСдесь не понятно. Это функция или метакласс? Подобная ситуация с terse syntax для концептов: это тип или концепт? Поскольку метакласс - это сущность времени компиляции, то следующий синтаксис более выразителен\r\n```cpp\r\nconstexpr class interface {\r\n   ...\r\n}\r\n```\r\nНе нужно добавлять новые слова. Насчет source и target, то лучше ввести два ключевые слова in, out на подобие this. Или сделать встроенные объекты: target, source, compiler.\r\n```cpp\r\nfor (auto f : in.functions()) {\r\n   if (f.is_copy() || f.is_move()) {\r\n        compiler.error(\"this type may not have a copy or move function\" , f);\r\n   }\r\n} \r\n```\r\nИ определение сделать проще и естествение. Вместо\r\n```cpp\r\nclass(interface) Shape { ... };\r\n```\r\nСделать вот так\r\n```cpp\r\ninterface Shape { ... };\r\n```\r\nЭтот синтаксис на много лучше. Но пока, рефлексия и кодогенерация не будет принята, окончательный синтаксис метаклассов будет менятся.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/363/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/363/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/362",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/362/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/362/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/362/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/362",
    "id": 848351182,
    "node_id": "MDU6SXNzdWU4NDgzNTExODI=",
    "number": 362,
    "title": "Является ли тип T строковым типом.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T10:43:42Z",
    "updated_at": "2021-04-01T10:44:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -5\r\n_Автор идеи:_ **Алексей Мячин**\r\n\r\nБывают задачи, когда нужно написать шаблонный код и реализация тела функции зависит от типа T.\r\nНапример, подсчитать количество передаваемых байт в зависимости от типа передаваемых данных.\r\n\r\n \r\n\r\nЗа основу взял реализацию std::is_integral<T>, получился код ниже:\r\n\r\n \r\n```cpp\r\ntemplate <typename >\r\nstruct _is_string_type_helper : public std::false_type { };\r\n\r\ntemplate <typename _CharT, typename _Traits, typename _Alloc>\r\nstruct _is_string_type_helper<std::basic_string<_CharT, _Traits, _Alloc>> : public std::true_type { };\r\n\r\ntemplate <class T>\r\nstruct is_string_type : public _is_string_type_helper<T>::type { };\r\n```\r\n \r\n\r\nДанный код проверяет тип T на причастность к std::basic_string.\r\n\r\nВ отдельной задачи приходилось добавлять проверку на const char *, то есть\r\n```cpp\r\ntemplate <>\r\nstruct _is_string_type_helper<const char *> : public std::true_type { };\r\n```\r\n\r\nВозможно проверку на const char * придется сделать отдельной.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/362/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/362/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/361",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/361/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/361/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/361/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/361",
    "id": 848349365,
    "node_id": "MDU6SXNzdWU4NDgzNDkzNjU=",
    "number": 361,
    "title": "basic_pstream, basic_ipstream, basic_opstream",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T10:40:54Z",
    "updated_at": "2021-04-01T10:42:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -0\r\n_Автор идеи:_ **Александр Коновалов**\r\n\r\nКлассы ввода-вывода для работы с процессами.\r\n\r\nВ C++ сейчас есть довольно ограниченный функционал по запуску процессов и работе с ними. Предлагаю для этого добавить классы basic_pstream, basic_ipstream и basic_opstream. Предполагается, что они должны работать в рамках существующей системы потоков. Видится, что они будут во многом похожи на аналогичные для файлов. Также выглядит разумным добавить в них дополнительные методы для работы с процессами:\r\n\r\n**wait** - ожидать окончания работы процесса, а после вернуть код возврата.\r\n\r\n**terminate** - завершить процесс.\r\n\r\n**kill** - убить процесс.\r\n\r\n**is_runned** - запущен ли процесс.\r\n\r\n**exit_code** - код возврата завершённого процесса (не знаю, что возвращать, если процесс ещё не завершён).\r\n\r\nАналогичный функционал есть в Qt (представлен классом QProcess), python  (модуль subprocess, в частности класс subprocess.Popen). В принципе, идея появилась на основе их. Не исключаю, что м.б. ещё что полезное у них найти или в других языках, имеющих схожий функционал.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/361/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/361/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/360",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/360/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/360/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/360/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/360",
    "id": 848348450,
    "node_id": "MDU6SXNzdWU4NDgzNDg0NTA=",
    "number": 360,
    "title": "Главный (primary) конструктор для класса",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T10:39:34Z",
    "updated_at": "2021-04-01T10:40:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Роман Попов**\r\n\r\nПредлагаю добавить в C++ primary constructor по аналогии с Kotlin и Scala. \r\n\r\nПопытка решить две проблемы:\r\n\r\n1) В C++ 11 добавили инициализацию полей класса, но нет удобного способа передать параметры из конструктора\r\n\r\n2) Часто бывает так что объекты требуют дополнительной инициализации после создания. Удобно если эта инициализация расположена в коде рядом с объявлением поля.\r\n\r\nПример синтаксиса для C++ (взят из Kotlin):\r\n```cpp\r\nclass ClassWithPrimaryCtor (int xInit, int yInit, const string& sInit)  {\r\n    int x = xInit;\r\n    int y = yInit;\r\n\r\n    Widget w;\r\n    init {\r\n        w.setName(sInit);\r\n        w.setDims(x,y);\r\n    }\r\n};\r\n```\r\n \r\n\r\nПрототип для пояснения семантики :\r\n```cpp\r\ntemplate <unsigned UNIQUE>\r\nstruct InitInvoker {\r\n    template <typename T>\r\n    InitInvoker(T && f) { f(); }\r\n};\r\n\r\n#define init InitInvoker<__LINE__> __init_##__LINE__ = [this]\r\n\r\nclass PrimaryCtor {\r\npublic:\r\n    int xInit;\r\n    int yInit;\r\n    const std::string &sInit;\r\n\r\n    PrimaryCtor(int xInit, int yInit, const std::string &sInit)\r\n    : xInit(xInit), yInit(yInit), sInit(sInit) {}\r\n};\r\n\r\n\r\nclass ClassWithPrimaryCtor : protected PrimaryCtor {\r\npublic:\r\n    ClassWithPrimaryCtor(int xInit, int yInit, const std::string &sInit)\r\n    : PrimaryCtor(xInit, yInit, sInit) {}\r\n\r\nprivate:\r\n    int x = xInit;\r\n    int y = yInit;\r\n\r\n    Widget w;\r\n    init {\r\n        w.setName(sInit);\r\n        w.setDims(x,y);\r\n    };\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/360/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/360/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/359",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/359/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/359/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/359/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/359",
    "id": 848345613,
    "node_id": "MDU6SXNzdWU4NDgzNDU2MTM=",
    "number": 359,
    "title": "Добавить операторы сравнения std::variant с его элементами",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      },
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T10:35:23Z",
    "updated_at": "2021-04-01T10:38:27Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nПредлагаю добавить следующие операторы:\r\n```cpp\r\ntemplate <class... Ts, class T>\r\nconstexpr std::enable_if_t<(... || std::is_same_v<Ts, T>),\r\nbool> operator==(const std::variant<Ts...>& lhs, const T& rhs) {\r\n    return std::visit([&rhs](const auto& v) {\r\n        using V = std::decay_t<decltype(v)>;\r\n        if constexpr (std::is_same_v<V, T>) {\r\n            return v == rhs;\r\n        } else {\r\n            return false;\r\n        }\r\n    }, lhs);\r\n}\r\n\r\ntemplate <class T, class... Ts>\r\nconstexpr std::enable_if_t<(... || std::is_same_v<Ts, T>),\r\nbool> operator==(const T& lhs, const std::variant<Ts...>& rhs) {\r\n    return rhs == lhs;\r\n}\r\n\r\ntemplate <class... Ts, class T>\r\nconstexpr std::enable_if_t<(... || std::is_same_v<Ts, T>),\r\nbool> operator!=(const std::variant<Ts...>& lhs, const T& rhs) {\r\n    return !(lhs == rhs);\r\n}\r\n\r\ntemplate <class T, class... Ts>\r\nconstexpr std::enable_if_t<(... || std::is_same_v<Ts, T>),\r\nbool> operator!=(const T& lhs, const std::variant<Ts...>& rhs) {\r\n    return !(rhs == lhs);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/359/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/359/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/358",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/358/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/358/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/358/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/358",
    "id": 848344651,
    "node_id": "MDU6SXNzdWU4NDgzNDQ2NTE=",
    "number": 358,
    "title": "Добавить std::rethrow_and_release для std::exception_ptr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-04-01T10:33:56Z",
    "updated_at": "2021-04-01T10:34:23Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nСейчас std::rethrow_exception не обнуляет std::exception_ptr, хотя такое поведение часто необходимо. Из-за чего в коде можно увидеть swap-ы со временными std::exception_ptr. Предлагаю добавить функцию std::rethrow_and_release.\r\n\r\nВместо того, чтобы писать как-то так:\r\n```cpp\r\nstd::exception_ptr tmp;\r\nstd::swap(tmp, exc_);\r\nstd::rethrow_exception(tmp);\r\n```\r\nМожно будет писать вот так:\r\n```cpp\r\nstd::rethrow_and_release(exc_);\r\n```\r\nКод самой функции:\r\n```cpp\r\nvoid rethrow_and_release(std::exception_ptr p) {\r\n    std::rethrow_exception(std::exchange(p, std::exception_ptr{}));\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/358/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/358/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/357",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/357/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/357/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/357/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/357",
    "id": 848342934,
    "node_id": "MDU6SXNzdWU4NDgzNDI5MzQ=",
    "number": 357,
    "title": "Базовые классы для корутин",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-04-01T10:31:27Z",
    "updated_at": "2021-04-01T10:32:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nНаступает к нам С++20. Я как и все надеемся, что на встрече в ноябре будут приняты в стандарт корутины.\r\nКогда мы пишим следующее\r\n\r\nco_await some_function();\r\nco_await some_structure();\r\n\r\nМы должны научить компилятор, что с этим делать. Компилятор сам нам подказывает, какие методы мы должны реализовать.\r\n```cpp\r\nstruct some_struct {\r\n    bool await_ready() const;\r\n    bool await_suspend(std::coroutine_handle<> h);\r\n    void await_resume();\r\n}\r\n```\r\nМне кажется на много лучше использовать абстрактный класс\r\n```cpp\r\nstruct base_awaitable {\r\n    virtual bool await_ready() const = 0;\r\n    virtual bool await_suspend(std::coroutine_handle<> h) = 0;\r\n    virtual void await_resume() = 0;\r\n};\r\n\r\nstruct some_struct : public base_awaitable {\r\n    bool await_ready() override {};\r\n    bool await_suspend(std::coroutine_handle<> h) override {};\r\n    void await_resume() override {};\r\n};\r\n```\r\nТакже можно сделать к концепту Coroutine Promise абстрактный класс, только не использовать чистые виртуальные функции.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/357/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/357/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/356",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/356/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/356/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/356/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/356",
    "id": 846229093,
    "node_id": "MDU6SXNzdWU4NDYyMjkwOTM=",
    "number": 356,
    "title": "Type-safe measurement units in fashion of std::chrono",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T08:58:23Z",
    "updated_at": "2021-03-31T09:00:23Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **post-increment**\r\n\r\nПомимо типо-безопасных единиц времени, представленных в std::chrono, хочется иметь также типо-безопасные единицы измерения (длины, массы и др.)\r\n\r\nХочется, чтобы всё это было реализовано в концепции аналогичной и дружественной std::chrono.\r\nПредставляется разумным, чтобы можно было единицы с собой спаривать в операциях умножения и деления.\r\nНапример, длина/время -> скорость.\r\nСейчас время/время (при допустимых типах представителя rep) - безразмерная величина - уже логичный задел.\r\nАналогично и для других единиц измерения.\r\nСразу видится, что, если за единицу длины возьмём метр - std::ratio<1,1>,\r\nто единицей скорости будет метр в секунду - std::ratio<1,1>.\r\nКилометры в час соответственно представлены std::ratio<1000,3600>=std::ratio<5,18>.\r\nИ т.д.\r\n\r\nЯ припоминаю были также другие доклады и статьи на эту тему.\r\nНавскидку например нашёл:\r\nhttps://github.com/nholthaus/units\r\nhttps://www.boost.org/doc/libs/1_65_0/doc/html/boost_units/Examples.html#boost_units.Examples.DimensionExample\r\nhttps://github.com/martinmoene/PhysUnits-CT\r\n\r\nДизайны уж очень местами отличаются от std::chrono.\r\nИМХО, если брать в стандарт, то только что-то концептуально схожее и совместимное с std::chrono. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/356/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/356/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/355",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/355/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/355/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/355/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/355",
    "id": 846222661,
    "node_id": "MDU6SXNzdWU4NDYyMjI2NjE=",
    "number": 355,
    "title": "std mappinf file to memory",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:54:35Z",
    "updated_at": "2021-03-31T08:55:39Z",
    "closed_at": "2021-03-31T08:55:35Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -0\r\n_Автор идеи:_ **post-increment**\r\n\r\nХочется иметь в стадартной библиотеке способ отобразить файл в память и обратно.\r\n\r\nПримеры.\r\n\r\nhttps://stackoverflow.com/questions/10839747/istream-vs-memory-mapping-a-file\r\n\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2044.html\r\n\r\nhttps://github.com/mandreyel/mio\r\n\r\n\r\nУ меня собственно возникла задача быстро считать и распарсить файл и стандартных средств не нашлось.\r\n(Чистый лобовой fscanf - выглядит пока что не самым быстрым вариантом.)\r\nПоэтому выношу идею на рассмотрение.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/355/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/355/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/354",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/354/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/354/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/354/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/354",
    "id": 846212600,
    "node_id": "MDU6SXNzdWU4NDYyMTI2MDA=",
    "number": 354,
    "title": "Добавить не копирующий вариант функции realloc и/или функцию проверки возможности изменения размера блока памяти",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T08:48:34Z",
    "updated_at": "2021-03-31T08:51:47Z",
    "closed_at": "2021-03-31T08:51:41Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -2\r\n_Автор идеи:_ **Сергей Мищенко**\r\n\r\nСуть - в С прекрасно работал realloc который позволял снизить количество копирований при ресайзе буфера. В С++  оно работь будет не с любым типом объектов по причине невозможности копирования некоторых типов объектов через memcpy.  Так же автоматическое копирование буфера, в случае  необходимости выделения блока в другом месте, не является оптимальной стратегией  расширения буфера для вставки в середину.  В результате возможность использования realloc сведена практически к нулю.  Для нормального использования функционала изменения размера блока, необходимо сделать аналог realloc,  позволяющий в случае невозможности расширения буфера, производить копирование и очистку старого буфера вручную, что позволит снизить количество копирований и фрагментацию кучи при ресайзе буферов.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/354/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/354/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/353",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/353/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/353/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/353/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/353",
    "id": 846193984,
    "node_id": "MDU6SXNzdWU4NDYxOTM5ODQ=",
    "number": 353,
    "title": "Изменить поведение constexpr ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-31T08:37:39Z",
    "updated_at": "2022-01-27T06:40:46Z",
    "closed_at": "2022-01-27T06:40:28Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -1\r\n_Автор идеи:_ **Fihtangolz**\r\n\r\nИзменить declaretion constexpr на constexpr call\r\n\r\nВообщем на данный момент constexpr видится мне чем то не совсем внятным. Он \"попытается\" выполнить функцию во время compile time, следом подтянется pure_constexpr или constexpr!  боже прости. Но это обсолютно не то чего мы все хотим - а мы хотим generic execution. Соотвественно constexpr должен быть модификатором \"вызова/исполнения\".\r\n```cpp\r\nconstexpr someFuncCall(1,2,3);\r\n```\r\nИ должен всегда выполнять callable во время компиляции. Дальше больше, если бы заходим добавить модификатор к блоку\r\n```cpp\r\nconstexpr {\r\n\r\n},\r\n```\r\nто в текушем виде получится снова что то невнятное, тоесть func могут или так или так а блок всегда компаил тайм??? \r\n\r\nВообщем надо убивать. + мне лично видится что compile time должен быть настоящим, тоесть без попыток ввести compile time allocation. Бог простит, можно вынести все использования в грал к примеру и тогда у нас будет возможен и std cout, map и тд \r\n\r\nP.S. возможно я не прав, прокоментируйте почем. И добавте на сайте после опубликовать не плашку внизу а поп ап для авторизации ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/353/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/353/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/352",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/352/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/352/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/352/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/352",
    "id": 846187978,
    "node_id": "MDU6SXNzdWU4NDYxODc5Nzg=",
    "number": 352,
    "title": "emplace_back и push_back должны возвращать итератор.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:34:03Z",
    "updated_at": "2021-03-31T08:36:24Z",
    "closed_at": "2021-03-31T08:36:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -1\r\n_Автор идеи:_ **riad**\r\n\r\nemplace_back и push_back должны возвращать iterator т.к это строго больше информации, чем reference\r\n\r\nСегодня столкнулся с кейсом, где было бы удобно получить итератор на только что emplae_back'нутый элемент, но эта функция, начиная с c++17 возвращает reference.\r\n\r\nКажется, что итератор возвращать логичнее: во-первых, это консистентно с emplace()/insert(), во вторых из него можно получить reference, но не наоброт.\r\n\r\nСобственно, тут есть два вопроса:\r\n\r\n1) А есть ли понимание почему сделано так как сделано (никто не предложил возвращать итератор или это поему-то плохо)?\r\n\r\n2) Есть ли какой-нибудь шанс изменить возвращаемый тип, не ломая совместимость хотя бы в простых кейсах?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/352/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/352/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/351",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/351/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/351/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/351/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/351",
    "id": 846180894,
    "node_id": "MDU6SXNzdWU4NDYxODA4OTQ=",
    "number": 351,
    "title": "Перегрузка оператора ?:",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T08:29:47Z",
    "updated_at": "2021-03-31T08:33:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -6\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nРазрешить перегрузку оператора ?:\r\n\r\nВ языке С++ можно перегружать операторы, кроме операторов ?: , :: , . Операторы :: , . понятно почему нельзя перегружать. А вот почему оператор ?: нельзя перегружать не понятно. Предлагаю добавить в стандарт перегрузку оператора ?:\r\n```cpp\r\nstruct dot {\r\n   int x, y;\r\n};\r\n\r\ndot select(int value) {\r\n   dot result;\r\n\r\n   if (value == 0) {\r\n      result = dot(1, 1);\r\n    \r\n      cout << \"use dot: \" << dot.x << \" \" << dot.y << endl;\r\n   } else {\r\n      result = dot(2, 2);\r\n    \r\n      cout << \"use dot: \" << dot.x << \" \" << dot.y << endl;\r\n   }\r\n\r\n   return result;\r\n}\r\n```\r\nМожно было вот так:\r\n```cpp\r\nstruct dot {\r\nprivate:\r\n   int x, y;\r\npublic:\r\n   friend dot operator?:(bool condition, const dot& left, const dot& right);\r\n};\r\n\r\ndot dot::operator?:(bool condition, const dot& left, const dot& right) {\r\n   dot result;\r\n\r\n   if (condition) {\r\n      cout << \"use left: \" << left.x << \" \" << left.y << endl;\r\n    \r\n      result = left;\r\n   } else {\r\n      cout << \"use right: \" << right.x << \" \" << right.y << endl;\r\n    \r\n      result = right;\r\n   }\r\n\r\n   return result;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/351/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/351/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/350",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/350/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/350/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/350/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/350",
    "id": 846177416,
    "node_id": "MDU6SXNzdWU4NDYxNzc0MTY=",
    "number": 350,
    "title": "Добавить атрибут [[internal]] для internal linkage (подумать над названием)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:27:40Z",
    "updated_at": "2021-03-31T08:27:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -3\r\n_Автор идеи:_ **Yuriy Chernyshov**\r\n\r\nКак адекватную и универсальную замену static / anonymous namespace\r\n\r\nСейчас для этого применяется либо ключевое слово static (не работает для классов) и констант, либо анонимные неймспейсы (вообще неочевидно, что использование анонимного неймспейса ведёт в internal linkage.\r\n\r\nКроме этого анонимный неймспейс - это лишний уровень вложенности, за которым надо следить (и из-за которого нельзя свободно перемещать методы внутри файла).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/350/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/349",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/349/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/349/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/349/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/349",
    "id": 846175045,
    "node_id": "MDU6SXNzdWU4NDYxNzUwNDU=",
    "number": 349,
    "title": "operator[]=",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:26:14Z",
    "updated_at": "2021-03-31T08:26:36Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -5\r\n_Автор идеи:_ **Konstantin Stupnik**\r\n\r\nВыделенный оператор для присвоения элемента контейнеру по индексу/ключу.\r\n\r\nВ данный момент невозможно (простым образом и без серьёзного overhead) разделить:\r\n```cpp\r\nauto val = cnt[key];\r\n```\r\nи\r\n```cpp\r\ncnt[key] = val;\r\n```\r\n \r\n\r\nБыло бы во многих случаях очень полезно иметь выделенный оператор а-ля:\r\n\r\n \r\n```cpp\r\nV& operator[]=(const K& key, V&& val);\r\n```\r\n \r\n\r\nКоторый бы вызывался только в случае:\r\n```cpp\r\ncnt[key] = val;\r\n```\r\n \r\n\r\nМожно было бы создавать контейнеры защищенные от создания элемента на чтении.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/349/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/349/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/348",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/348/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/348/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/348/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/348",
    "id": 846170501,
    "node_id": "MDU6SXNzdWU4NDYxNzA1MDE=",
    "number": 348,
    "title": "Тривиальные inline геттеры должны быть автоматически noexcept",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:23:27Z",
    "updated_at": "2021-03-31T08:23:50Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -1\r\n_Автор идеи:_ **Konstantin Stupnik**\r\n\r\nСобственно для кода типа:\r\n \r\n```cpp\r\nclass Foo{\r\npublic:\r\n  int bar()const\r\n  {\r\n    return m_bar;\r\n  }\r\n\r\nprivate:\r\n  int m_bar;\r\n};\r\n```\r\n\r\nоператор noexcept вернёт для bar() false, когда у компилятора есть всё, что бы понять, что этот метод никогда не может кинуть исключение.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/348/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/348/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/347",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/347/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/347/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/347/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/347",
    "id": 846163389,
    "node_id": "MDU6SXNzdWU4NDYxNjMzODk=",
    "number": 347,
    "title": "Строгий noexcept!",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:19:04Z",
    "updated_at": "2021-03-31T08:19:31Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -0\r\n_Автор идеи:_ **Konstantin Stupnik**\r\n\r\nПопросить компилятор проверить, что всё, что написано в noexcept! функции/методе является noexcept (уже не обязательно строгим).\r\n\r\nНу и соответственно все вызовы в noexcept! функции/методе, которые не noexcept должны быть в try/catch блоках с обязательным присутствием catch(...).\r\n\r\nНе обложенные try/catch вызовы должны генерировать ошибку компиляции.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/347/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/347/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/346",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/346/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/346/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/346/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/346",
    "id": 846155262,
    "node_id": "MDU6SXNzdWU4NDYxNTUyNjI=",
    "number": 346,
    "title": "Математическая библиотека",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T08:13:56Z",
    "updated_at": "2021-03-31T08:16:08Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Osmironov**\r\n\r\nПочему бы не добавить в стандарт blas?\r\n\r\nВ 17 стандарте комитет подарил нам библиотеку специальных математических функций:\r\nhttps://en.cppreference.com/w/cpp/numeric/special_math\r\nПочему бы не добавить что-нибудь попроще? Например, blas или его аналог с поддержкой std::array, std::vector и пр.\r\nДа, есть куча реализаций: https://ru.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\r\nМожет уже пора ввести одну из них (или их комбинацию) в стандарт?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/346/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/346/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/345",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/345/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/345/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/345/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/345",
    "id": 846151797,
    "node_id": "MDU6SXNzdWU4NDYxNTE3OTc=",
    "number": 345,
    "title": "pattern matching or partial specialization for using type definitions and for inline variables",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:11:45Z",
    "updated_at": "2021-03-31T08:13:32Z",
    "closed_at": "2021-03-31T08:12:15Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -4\r\n_Автор идеи:_ **post-increment**\r\n\r\nПри написании трейтов часто приходится писать специализации используя технику частичной специализации шаблона.\r\nПо сути - это паттерн-матчинг использующий средства языка, но требующий дополнительного кода.\r\nА что, если позволить нечто схожее определению функций в Haskell? Примеры ниже.\r\n\r\nДопустим, мы хотим написать банальный \"трейт\" для своих типов.\r\nНапример, best_floating_point_t<T>.\r\nПервый вариант это писать класс best_floating_point<T> и специализировать его для каждого особого случая.\r\nА далее уже использовать using для определения best_floating_point_t<T>.\r\nДолжно выглядеть примерно так\r\n```cpp\r\ntemplate<typename T>\r\nbest_floating_point_t = typename best_floating_point<T>::type;\r\n```\r\nПредлагается сделать возможным такой синтаксис:\r\n```cpp\r\ntemplate<typename T> \r\nusing best_floating_point_t = some_default_case;\r\n//specializations\r\ntemplate<> using best_floating_point_t<int> = float;\r\ntemplate<> using best_floating_point_t<long> = double;\r\ntemplate<> using best_floating_point_t<some_user_type> = double;\r\n```\r\nАналоично можно сделать для inline variables:\r\n```cpp\r\ntemplate<typename T>\r\ninline const std::string type_name = \"unknown\";\r\n\r\ntemplate<> inline const std::string type_name<int> = \"int\";\r\ntemplate<> inline const std::string type_name<double> = \"double\";\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/345/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/345/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/344",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/344/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/344/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/344/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/344",
    "id": 846142326,
    "node_id": "MDU6SXNzdWU4NDYxNDIzMjY=",
    "number": 344,
    "title": "метод clear() в std::queue, std::stack и std::priority_queue",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T08:05:51Z",
    "updated_at": "2021-03-31T08:08:23Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +20, -1\r\n_Автор идеи:_ **Osmironov**\r\n\r\nНа сегодняшний день для полной очистки, например std::queue необходимо писать что-то вроде:\r\n```cpp\r\nstd::queue<int> q;\r\n\r\n// заполнение queue\r\n\r\nwhile ( !q.emty() ) {\r\n    q.pop();\r\n}\r\n\r\n// дальнейший код\r\n```\r\nВ то же время, в нижележащем std::deque присутствует метод clear(), но к нему нет доступа.\r\n\r\nПредлагаю сделать метод clear() который будет вызывать clear() нижележащего контейнера.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/344/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/344/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/343",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/343/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/343/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/343/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/343",
    "id": 846139773,
    "node_id": "MDU6SXNzdWU4NDYxMzk3NzM=",
    "number": 343,
    "title": "{namespace}::{user_literal}",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-31T08:04:17Z",
    "updated_at": "2021-03-31T08:04:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -1\r\n_Автор идеи:_ **Yuri Pechatnov**\r\n\r\nПользовательские литералы лаконичны, но для удобного пользования требуют using namespace, что делать не очень хорошо, особенно в хедерах\r\n\r\nКажется, возможность писать std::3_sec могла бы немного улучшить ситуацию\r\n\r\nNTime::2018_y, NTime::\"2018.09.01\"_date, NTime::\"18:05:59\"_hhmmss, NTime::17_min, NTime::\"10:30\"_mmss,  NData::0xA12BD023_bytes... да что угодно, так как явно указан неймспейс",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/343/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/343/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/342",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/342/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/342/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/342/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/342",
    "id": 846135128,
    "node_id": "MDU6SXNzdWU4NDYxMzUxMjg=",
    "number": 342,
    "title": "switch с диапазоном значений",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T08:01:22Z",
    "updated_at": "2021-03-31T08:03:35Z",
    "closed_at": "2021-03-31T08:03:29Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +22, -2\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nРаботая с switch мы иногда хотим, чтобы ветка выполнилась, если условия лежит\r\n\r\nв диапазоне значений. Для этого мы должны писать следующее\r\n```cpp\r\nswitch (value) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\n   cout << \"in range 0...2\" << endl;\r\n   break;\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\n   cout << \"in range 3...5\" << endl;\r\n   break;   \r\ndefault:\r\n   cout << \"out the range\" << endl;\r\n}\r\n```\r\nВ GCC есть расширение, которое позволяет указывать в case диапазон значений\r\n```cpp\r\nswitch (value) {\r\ncase 0 ... 2:\r\n   cout << \"range in 0...2\" << endl;\r\n   break;\r\ncase 3 ... 5:\r\n   cout << \"range in 3...5\" << endl;\r\n   break;\r\ndefault:\r\n   cout << \"out the range\" << endl;\r\n}\r\n```\r\nБыло бы классно добавить в стандарт С++. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/342/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/342/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/341",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/341/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/341/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/341/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/341",
    "id": 846130940,
    "node_id": "MDU6SXNzdWU4NDYxMzA5NDA=",
    "number": 341,
    "title": "Пометить устаревшим макрос std::assert",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-31T07:58:47Z",
    "updated_at": "2021-03-31T08:00:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -6\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nНа последнем заседании комитета по стандартизации С++ были внедрены в язык\r\nконтракты. Контракт [[assert]] полностью повторяет макрос assert. Предлагаю в\r\nС++20 сделать макрос assert - deprecated. А в С++23 удалить с языка С++.  При\r\nэтом разработчики, которые будут писать на С++23 дефакто будут использовать\r\nконтракты.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/341/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/341/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/340",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/340/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/340/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/340/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/340",
    "id": 846112368,
    "node_id": "MDU6SXNzdWU4NDYxMTIzNjg=",
    "number": 340,
    "title": "Добавить в переменную __func__ имя класса",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-31T07:47:18Z",
    "updated_at": "2023-10-22T10:07:27Z",
    "closed_at": "2023-10-22T10:05:54Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +15, -0\r\n_Автор идеи:_ **max**\r\n\r\nЛибо добавить новую переменную __class__, содержащую имя класса в текущем scope. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/340/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/339",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/339/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/339/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/339/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/339",
    "id": 844949715,
    "node_id": "MDU6SXNzdWU4NDQ5NDk3MTU=",
    "number": 339,
    "title": "Добавить в С++ switch constexpr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T17:39:24Z",
    "updated_at": "2021-04-06T19:12:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +24, -1\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С++17 была добавлена конструкция if constexpr. Проверка условия во времени компиляции во многих                                      случаях делает код более четабельным. Было бы не плохо добавить подобную конструкцию - switch constexpr.                            Например, мы имеем класс для конфига\r\n```cpp\r\nclass config {\r\nprivate:\r\n\tint id, age;\r\n\tstring name;\r\npublic:\r\n\tconfig(int id, int age, const string& name) :\r\n\t\tid(id), age(age), name(name) {}\r\n};\r\n```\r\nМы хотим применить structured binding к классу. Мы должны для своего класса переопределить get(), std::tuple_size, std::tuple_element. Метод get() мы можем реализовать вот так\r\n```cpp\r\ntemplate <std::size_t N>\r\ndecltype(auto) get() const {\r\n\tif constexpr (N == 0) {\r\n\t\treturn id;\r\n\t} else if constexpr (N == 1) {\r\n\t\treturn age;\r\n\t} else if constexpr (N == 2) {\r\n\t\treturn (name);\r\n\t}\r\n}\r\n```\r\nС switch constexpr можно было бы написать вот так\r\n```cpp\r\ntemplate <std::size_t N>\r\ndecltype(auto) get() const {\r\n\tint result;\r\n\r\n\tswitch constexpr (N) {\r\n\tcase 0:\r\n\t\tresult = id;\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tresult = age;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tresult = (name);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tresult = -1;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/339/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/339/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/338",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/338/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/338/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/338/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/338",
    "id": 844934642,
    "node_id": "MDU6SXNzdWU4NDQ5MzQ2NDI=",
    "number": 338,
    "title": "Вести синтаксический сахар для override",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T17:29:45Z",
    "updated_at": "2021-03-30T17:30:43Z",
    "closed_at": "2021-03-30T17:30:43Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -13\r\n_Автор идеи:_ **Fihtangolz**\r\n\r\nИногда напрягает писать полностью сигнатуру функции, так как override говорит что мы хотим перегрузить функцию и если нет нескольких функций с одним имянем, почему бы просто не сохратить записть до override funcName { /* some code */}, тоже можно сделать для final ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/338/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/338/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/337",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/337/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/337/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/337/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/337",
    "id": 844928188,
    "node_id": "MDU6SXNzdWU4NDQ5MjgxODg=",
    "number": 337,
    "title": "В С++17 не работает std::function<R(...) noexcept>",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T17:25:36Z",
    "updated_at": "2023-10-22T09:48:54Z",
    "closed_at": "2023-10-22T09:48:45Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **Yuriy Chernyshov**\r\n\r\nПричина в том, что noexcept стал учитываться в сигнатуре функции, а определение std::function исправить забыли.\r\n\r\nПодробнее — здесь:\r\nhttps://stackoverflow.com/questions/41293025/stdfunction-with-noexcept-in-c17\r\n\r\nЭто баг в стандарте.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/337/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/337/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/336",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/336/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/336/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/336/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/336",
    "id": 844924410,
    "node_id": "MDU6SXNzdWU4NDQ5MjQ0MTA=",
    "number": 336,
    "title": "Добавить ключевое слово restrict в С++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T17:23:09Z",
    "updated_at": "2021-04-10T11:09:41Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -0\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С99 было добавлено ключевое слово restrict. Оно применимо только к указателям.\r\n\r\nrestrict позволяет указать, что объявляемый указатель указывает на блок памяти, на который не указывает никакой другой указатель.\r\n\r\nВ разных компиляторах уже добавили аналогичные ключевые слова для С++:\r\n\r\nGCC: __restrict, __restrict__\r\n\r\nClang: __restrict__\r\n\r\nКак пример можно посмотреть стандартную функцию std::memcpy\r\n```cpp\r\nextern void *memcpy (void *__restrict __dest, const void *__restrict __src,\r\n\t\t     size_t __n) __THROW __nonnull ((1, 2));\r\n```\r\nБыло бы не плохо иметь в С++ стандартную поддержку.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/336/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/336/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/335",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/335/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/335/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/335/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/335",
    "id": 844921863,
    "node_id": "MDU6SXNzdWU4NDQ5MjE4NjM=",
    "number": 335,
    "title": "Введение типа \"машинное слово\". Со знаком и без знака.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T17:21:32Z",
    "updated_at": "2021-03-30T17:21:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -6\r\n_Автор идеи:_ **Vyacheslav Meshkov**\r\n\r\nВвод типов: машинное слово - mword_t (знаковое) и беззнаковое машинное слово umword_t, имеющее максимальную производительность и максимально возможной разрядности для данный архитектуры. Например пишем цикл, и впоследствии не задумываемся о производительности и корректности при переносе кода x32 -> x64 или вообще на другую архитектуру.\r\n\r\nДавно были введены типы указывающие разрядность: int32_t и подобные. Под это возникла потребность. Потому что невозможно считывать бинарные данные из файла, не имея чётких гарантий на размер типа.\r\n\r\nТакже есть не менее важная задача. Переменные цикла и просто любая переменная, обеспечивающая максимальную производительность на конкретной архитектуре. Например mword=int16_t на 16 разрядной машине, mword=int32_t на 32 разрядной, и так далее.\r\n\r\nК сожалению, в своё время word был занят под 16 бит, когда машинное слово было 16 бит. И именно для 16 битной архитектуры были разумны и понятны dword, qword. Но на современных машинах это технически некорректные типы. Корректнее говорить word=int32_t для x86 и word=int64_t для x64. SIMD это отдельный набор типов. Их разрядность нам не важна.\r\n\r\nОчевидно, что int8_t или int16_t на современной x86 архитектуре будут медленными. Также я не хочу переписывать код при переносе с архитектуры на архитектуру, если я не меняю функциональности. Если мы пишем цикл с int64_t, то он будет быстрый на x64, но не на x86, а если int32_t, то наоборот. А так просто пишем mword_t, и мигрируем с платформы на платформу.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/335/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/335/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/334",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/334/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/334/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/334/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/334",
    "id": 844916959,
    "node_id": "MDU6SXNzdWU4NDQ5MTY5NTk=",
    "number": 334,
    "title": "Добавить Tail Call Optimization в стандарт",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T17:18:25Z",
    "updated_at": "2021-03-30T17:19:47Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -4\r\n_Автор идеи:_ **Nate Reinar Windwood**\r\n\r\nВсе основные компиляторы и так делают TCO, так почему бы не гарантировать это стандартом?\r\n\r\n```cpp\r\n// Все основные компиляторы и так делают TCO,\r\n// так почему бы не гарантировать это стандартом?\r\n\r\n// Это позволит писать, например, вот так и точно знать,\r\n// что это будет работать не медленнее императивного варианта:\r\n\r\nconstexpr int fibonacci(int n, int a = 0, int b = 1)\r\n{\r\n\tif (n == 0) return a;\r\n\tif (n == 1) return b;\r\n\r\n\treturn (n < 0)\r\n\t\t? fibonacci(n + 1, b - a, a)\r\n\t\t: fibonacci(n - 1, b, a + b);\r\n}\r\n``",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/334/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/334/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/333",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/333/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/333/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/333/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/333",
    "id": 844912464,
    "node_id": "MDU6SXNzdWU4NDQ5MTI0NjQ=",
    "number": 333,
    "title": "[[nodiscard]] для std::unique_ptr::release , новый метод std::unique_ptr::forget_ownership",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T17:15:33Z",
    "updated_at": "2021-03-30T17:17:20Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -1\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nrelease и reset очень похожи, часто их начаянно путают получая утечки\r\n\r\nпредлагается поставить параметр [[nodiscard]] для release чтобы было сложнее не заметить потерю владения\r\n\r\nдля того чтобы использовать release для специаольной отмены владиния предлагается добавить метод void std::unique_ptr::forget_ownership() { auto tmp = this->release(); (void)(tmp);}\r\n\r\nМожно сделать это же ещё и для других типов указателей.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/333/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/333/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/332",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/332/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/332/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/332/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/332",
    "id": 844910241,
    "node_id": "MDU6SXNzdWU4NDQ5MTAyNDE=",
    "number": 332,
    "title": "Дать возможность безопасно и с нулевым оверхедом использовать runtime-cpu-detection",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T17:14:09Z",
    "updated_at": "2021-03-30T17:14:33Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -1\r\n_Автор идеи:_ **ilnurkh**\r\n\r\n\r\n1. добавить std::cpu_info_t содержащий информацию о доступных инструкциях (avx sse и т.п.)\r\n2. дать возможность без накалдных расходов на virtaul-call писать что-то вида\r\n```cpp\r\nusing func_ptr_t = float(float*, float*);\r\nstatic const func_ptr_t fastest_host_dot_product_impl = get_fastest_host_dot_product_impl(std::get_host_cpu_info());\r\n\r\nfunc_ptr_t constexpr get_host_cpu_info(std::cpu_info_t cpu_info) {\r\n    if (cpu_info.have_avx()) {\r\n        return &avx_dot_product_impl;\r\n    }\r\n    if (cpu_info.have_sse4()) {\r\n        return &sse4_dot_product_impl;\r\n    }\r\n    return &trivial_dot_product_impl;\r\n}\r\n```\r\n\r\nЕсть важная проблема: невозможность максимальной оптимизации в compile-time так как не извеснтно под какую архитектуру компилируется приложение (парк машин не гомогенен, либо список пользователей широк).\r\n\r\nЭто можно решать через jit (не выглядит как вариант для плюсов) или через cpu-detection непосредственно на хосте.\r\n\r\nВо втором случае не избежать накладных расходов:\r\n\r\n  нужно либо внутри точки входа делать проверку (мб. закешированную, но тем не менее не нулевую по стоимости) на поддержку необходимых инстукций\r\n\r\n  либо делать интерфейс и фабрику, выдающую нужную реализацию. Во втором случае у нас virtual-call.\r\n\r\n \r\n\r\nАльтернативой могло бы быть определение всех реализаций  на старте (как показано в примере). Проблема сейчас в том, что нельзя гарантировать выполнение этого определения до вызова других конструкторов стат-объектов, что ведёт к сложностям (эти объекты могут пытаться их использовать). Поэтому нужен спец механизм.\r\n\r\nВ качестве ограничения предлагаю разрешить для такого механизма только constexpr функции с единственным аргументом std::cpu_info_t и возвращаемым значением - указатель на функцию.\r\n\r\nПотенциально, правильное аннотирование бинарников позволило бы даже писать тулы, которые бы заменяли вызов fastest_host_dot_product_impl на конкретную реализацию прямо на хосте (чтобы убрать разименование указателя).\r\n\r\n \r\n\r\n \r\n\r\nОтдельно хочется добавить, что std::cpu_info_t cpu_info важна сама по себе, оно позволило бы даже без спец механизма помогать компилятору выкидывать ненужные ветки, сопоставляя условия с параметрами компиляции.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/332/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/332/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/331",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/331/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/331/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/331/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/331",
    "id": 844871716,
    "node_id": "MDU6SXNzdWU4NDQ4NzE3MTY=",
    "number": 331,
    "title": "Написание пользовательских атрибутов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T16:49:35Z",
    "updated_at": "2021-03-30T16:50:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -2\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nКаждый компилятор имеет набор специфичных для него набор атрибутов. В С++11 ввели синтаксис для атрибутов в стандарт и начали добавлять стандартные атрибуты.\r\n\r\nАтрибуты в С++ подобны по механизма анотаций в языке Java. Следующие строки в языках одинаковые\r\n```cpp\r\n@Deprecated\r\nvoid test() {}\r\n\r\n[[deprecated]]\r\nvoid test() {}\r\n```\r\nНо в отличие от Java, нельзя реализовывать пользовательские атрибуты. Например, было бы не плохо добавить атрибуты setter/getter\r\n```java\r\nclass student{\r\nprivate:\r\n   [[using usr: setter, getter]]\r\n   int id;\r\n\r\n   [[using usr: setter, getter]]\r\n   string name;\r\n\r\n   [[using usr: setter, getter]]\r\n   int age;\r\n};\r\n```\r\n\r\nДля реализации пользовательских атрибутов, как вариант, добавить ключевое слово attribute \r\n```cpp\r\n[[target(target_type::field)]]\r\nattribute usr::setter(/*params*/) {\r\n   /* logic */\r\n}\r\n```\r\nПользовательские атрибуты лучше объявлять в пользовательском namespace. И добавить мета-атрибут, который будет определять для кого этот атрибут\r\n```cpp\r\nenum class target_type{\r\n   local_variable,\r\n   function,\r\n   field,\r\n   method,\r\n   ...\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/331/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/330",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/330/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/330/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/330/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/330",
    "id": 844862391,
    "node_id": "MDU6SXNzdWU4NDQ4NjIzOTE=",
    "number": 330,
    "title": "Добавить квалификатор constexpr к аргументам функций и лямбд",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      },
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T16:43:47Z",
    "updated_at": "2021-04-06T19:15:26Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **Николай**\r\n\r\n\r\nКоллеги, предлагаю для чистых-constexpr функций, вместо constexpr! просто пометить аргументы функции спецификатором constexpr. Кроме этого, если пометить лишь несколько аргументов, то это будет означать, что компилятору стоит ожидать вызова этой функции с уже готовой constexpr-переменной.\r\n\r\n```cpp\r\ntemplate <typename Integral>\r\nconstexpr auto fn (constexpr Integral v)\r\n{\r\n    static_assert(v > 0);\r\n    return v;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/330/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/330/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/329",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/329/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/329/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/329/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/329",
    "id": 844860046,
    "node_id": "MDU6SXNzdWU4NDQ4NjAwNDY=",
    "number": 329,
    "title": "Добавить операторы ||= и &&=",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T16:42:19Z",
    "updated_at": "2022-08-11T18:12:21Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +20, -2\r\n_Автор идеи:_ **Evgeny Basargin**\r\n\r\nИногда приходится писать подобный код:\r\n```cpp\r\nauto systemIsOk = false;\r\nfor(auto& element : systemElements) {\r\n    systemIsOk = systemIsOk && element.isOk();\r\n}\r\n```\r\nХотелось бы добавить немного синтаксического сахара в этот код:\r\n```cpp\r\nauto systemIsOk = false;\r\nfor(auto& element : systemElements) {\r\n    systemIsOk &&= element.isOk();\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/329/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/329/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/328",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/328/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/328/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/328/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/328",
    "id": 844854895,
    "node_id": "MDU6SXNzdWU4NDQ4NTQ4OTU=",
    "number": 328,
    "title": "Добавить в chrono ntp_clock.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T16:39:05Z",
    "updated_at": "2021-03-30T16:41:16Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -0\r\n_Автор идеи:_ **Михаил Павлов**\r\n\r\nВ C++20 появятся gps_clock, tai_clock и utc_clock. Предлагаю добавить ntp_clock. \r\n\r\nhttps://tools.ietf.org/html/rfc5905",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/328/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/327",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/327/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/327/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/327/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/327",
    "id": 844852865,
    "node_id": "MDU6SXNzdWU4NDQ4NTI4NjU=",
    "number": 327,
    "title": "Добавить неймспесы для макросов ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T16:37:49Z",
    "updated_at": "2021-03-30T16:38:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -2\r\n_Автор идеи:_ **Fihtangolz**\r\n\r\nПредлагаю ввести ключевое слово для препроцнссора.\r\n\r\n#usingonly some.hpp, some.cpp ... \r\n\r\nОграничивает макросы которые будут действовать в данной единице компиляции. \r\n\r\nВообщем идея сырая, вдруг кто придумает как сделать лучше.\r\n\r\nПричины: \r\n\r\nМожно не опасаться перекрытия макросами и писать чистый код, к примеру думаю для stl актуально как и для других библиотек\r\n\r\nДумаю будет актуально для модулей(а может не будет) \r\n\r\nВозможность для отладки собрать все в одной точке зависимости",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/327/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/327/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/326",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/326/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/326/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/326/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/326",
    "id": 844849767,
    "node_id": "MDU6SXNzdWU4NDQ4NDk3Njc=",
    "number": 326,
    "title": "Range-based if (по анаглогии с range-based for)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T16:35:50Z",
    "updated_at": "2022-08-11T18:59:01Z",
    "closed_at": "2022-08-11T18:59:01Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -10\r\n_Автор идеи:_ **Nate Reinar Windwood**\r\n\r\nPython-style итерацию уже сделали, почему бы теперь не сделать и проверку наличия элемента в контейнере?\r\nЭто упрощает код и просто логично.\r\n\r\n```cpp\r\nif (token_expression : range_expression)\r\n\tconditional_statement\r\n\r\n// Translates into:\r\n\r\n{\r\n\tauto && __range = range_expression;\r\n\tauto && __token = token_expression;\r\n\tauto __begin = std::begin(__range);\r\n\tauto __end = std::end(__range);\r\n\r\n\tif (std::find(__begin, __end, __token) != __end)\r\n\t\tconditional_statement\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/326/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/326/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/325",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/325/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/325/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/325/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/325",
    "id": 844836349,
    "node_id": "MDU6SXNzdWU4NDQ4MzYzNDk=",
    "number": 325,
    "title": "Использовать трюк определения std::function для conept с предикатами.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T16:27:35Z",
    "updated_at": "2021-03-30T16:34:11Z",
    "closed_at": "2021-03-30T16:32:54Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **d-yaroshev**\r\n\r\nРеализация для Predicate: https://godbolt.org/g/bSuuDb\r\n\r\nЯ бы таким образом записывал и StrictWeakOrder, Invocable итд - везде где речь идет про что-то, чему в качестве параметров передаются другие аргументы.\r\n\r\n\r\nМне кажется, так получается чище и понятнее, при этом пара скобок не увеличивает длину выражения.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/325/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/325/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/324",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/324/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/324/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/324/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/324",
    "id": 844833617,
    "node_id": "MDU6SXNzdWU4NDQ4MzM2MTc=",
    "number": 324,
    "title": "Добавить оператор сложения последовательности символов и std::string",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T16:25:58Z",
    "updated_at": "2021-03-30T16:26:24Z",
    "closed_at": "2021-03-30T16:26:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Evgeny Basargin**\r\n\r\nЗачастую хочется осуществить конкатенацию строковой константы и строки. В данный момент это делать не очень неудобно. Нужно использовать либо std::stringstream:\r\n\r\n \r\n```cpp\r\nstd::string world(\" world\");\r\n\r\nstd::stringstream ss;\r\n\r\nss << \"hello\" << world;\r\n```\r\n \r\n\r\nлибо конструировать строку от строковой константы:\r\n```cpp\r\nstd::string world(\" world\");\r\n\r\nstd::string(\"hello\") + world;\r\n ```\r\n\r\nХочу предложить добавить в стандарт следующий оператор сложения, который может упростить жизнь:\r\n\r\n \r\n```cpp\r\ntemplate<typename Char_T>\r\nstd::basic_string<Char_T> operator+(const Char_T* c_str, const std::basic_string<Char_T>& str) {\r\n    return std::basic_string<Char_T>(c_str) + str;\r\n}\r\n```\r\n \r\n\r\nпри введении данного оператора следующая операция станет совершенно легальной:\r\n\r\n \r\n```cpp\r\nstd::string world(\" world\");\r\n\r\n\"hello\" + world;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/324/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/324/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/323",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/323/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/323/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/323/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/323",
    "id": 844793030,
    "node_id": "MDU6SXNzdWU4NDQ3OTMwMzA=",
    "number": 323,
    "title": "пускай std::string кидает исключение std::invalid_argument, когда ему на вход дают nullptr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T16:01:40Z",
    "updated_at": "2021-03-30T16:04:00Z",
    "closed_at": "2021-03-30T16:03:52Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -4\r\n_Автор идеи:_ **Evgeny Basargin**\r\n\r\nМногим знакома неприятная ситуация, когда в конструктор, методы или операторы std::string попадает нулевой указатель (особенно часто бывает при взаимодействии с С-библиотеками). В таких случаях неизменно случается segmentation fault, я бы хотел предложить заменить крэш на более гуманное исключение типа std::invalid_argument. Думаю, преимущества исключения перед крэшом для всех очевидны.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/323/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/323/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/322",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/322/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/322/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/322/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/322",
    "id": 844784264,
    "node_id": "MDU6SXNzdWU4NDQ3ODQyNjQ=",
    "number": 322,
    "title": "Разрешить полную специализацию шаблонов внутри классов (explicit specialization in non-namespace scope)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T15:56:32Z",
    "updated_at": "2021-03-30T15:57:01Z",
    "closed_at": "2021-03-30T15:56:55Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -0\r\n_Автор идеи:_ **Amomum**\r\n\r\nСейчас этого делать нельзя, хотя в некоторых компиляторах можно (и никто не умирает). Причем частичная специализация почему-то разрешена.\r\nСчитаю, что никакого смысла в этом нет, обходные пути более многословны и уродливы.\r\n\r\nСейчас подобный код не компилируется с не очень внятной ошибкой:\r\n```cpp\r\nclass A\r\n{\r\n    private:\r\n\r\n    template< typename T>\r\n    class Inner\r\n    {\r\n        T value;\r\n    };\r\n\r\n    template<>\r\n    class Inner<int>\r\n    {\r\n        int value;\r\n    };\r\n};\r\n```\r\n\r\n```\r\nerror: \"explicit specialization in non-namespace scope 'class A'\"\r\n```\r\n\r\nПростое решение - сделать специализацию частичной, добавив фейковый параметр Dummy:\r\n```cpp\r\nclass A\r\n{\r\n    private:\r\n\r\n    template< typename T, typename Dummy = void>\r\n    class Inner\r\n    {\r\n        T value;\r\n    };\r\n\r\n    template< typename Dummy>\r\n    class Inner< int, Dummy >\r\n    {\r\n        int value;\r\n    };\r\n};\r\n```\r\n\r\nОднако такой код длиннее и менее понятен. К тому же, частичная специализация невозможна для шаблонных методов, которые страдают от той же проблемы.\r\nСледует так же отметить, что некоторые компиляторы (в частности, MSVC) компилируют первый сниппет вопреки стандарту - и вроде как полет нормальный.\r\n\r\nПричины, по которым стандарт это запрещает, неясны.\r\n\r\nПредлагаю разрешить.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/322/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/322/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/321",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/321/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/321/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/321/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/321",
    "id": 844773512,
    "node_id": "MDU6SXNzdWU4NDQ3NzM1MTI=",
    "number": 321,
    "title": "constexpr(expr) - альтернативный синтаксис \"constexpr!\" для функции и const(auto)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T15:50:14Z",
    "updated_at": "2021-03-30T15:54:49Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -3\r\n_Автор идеи:_ **Данил Луценко**\r\n\r\nРазрешить условное выражение этапа компиляции после ключевого слова constexpr. Если выражение вычисляется как true, то функция вычисляется только на этапе компиляции, если false - только (!) этапе исполнения\r\n\r\nПозволяет явно указывать возможность исполнения функции на этапе компиляции добавляя гибкость для мета-программирования, и имеет более привычный синтаксис (подобный уже используется для noexcept(expr) и decltype(expr)) нежели \"constexpr!\".\r\n\r\nНапример,\r\n```cpp\r\ntemplate<typename T>\r\nconstexpr T ConstValue = static_cast<T>(0x1'000'000);\r\n\r\nconstexpr(false == false) int A() { return 5; }\r\nconstexpr(true == false) int B() { return 5; }\r\n\r\nstatic_assert(A() == 5); //ОК, функция помечена как constexpr(true)\r\nstatic_assert(B() == 5); //ошибка, функция не может использоваться на этапе компиляции\r\n\r\nint main()\r\n{\r\n    assert(A() == 5); //ошибка, функция A не может вызываться на этапе исполнения\r\n    assert(B() == 5); //ОК\r\n}\r\n```\r\n \r\n\r\nПредлагаю так же разрешить constexpr(auto), который ведет себя как и текущий constexpr\r\n```cpp\r\nconstexpr(auto) int A() { return 5; }\r\n```\r\nВ будущем предлагаю помечать неявно как constexpr(auto) любую inline функцию или метод, которому может примениться constexpr, что позволит  частично использовать уже написанный код на этапе исполнения без потери совместимости с существуещим кодом использующим constexpr.\r\n\r\nПочему для constexpr(false) не задействовать старый синтаксис вместо constexpr(auto)?! Предлагаю в будущем добавить в объявление функции const(expr)/const(auto), где const(auto) генерирует 2 функции, одна с const модификатором, вторая без. Ровно как и constexpr(auto), который генерирует 2 функции, одну для этапа компиляции, вторую для исполнения.\r\n\r\nconst(auto) может использоваться в следующем случае\r\n```cpp\r\nclass A {\r\n    std::string m;\r\npublic:\r\n    auto& get_m() const(auto) { return m; }\r\n};\r\n```\r\nчто аналогично следующему коду\r\n```cpp\r\nclass A {\r\n    std::string m;\r\npublic:\r\n    auto& get_m() { return m; }\r\n    auto& get_m() const { return m; }\r\n};\r\n```\r\nКак и в случае с constexpr(auto), предлагаю помечать неявно const(auto) все inline методы, которые могут быть помечены как const, что избавит от забытых const в библиотечном коде без потери совместимости со старым кодом.\r\nВозможность явно указывать константность в const с помощью условного выражения этапа компиляции позволит управлять константностью метода исходя из параметров шаблона и для явного описания константности в интерфейсе.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/321/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/321/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/320",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/320/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/320/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/320/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/320",
    "id": 844768668,
    "node_id": "MDU6SXNzdWU4NDQ3Njg2Njg=",
    "number": 320,
    "title": "Добавление спецификатора noexcept для методов contains(p0458)/count/find",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T15:47:25Z",
    "updated_at": "2021-03-30T15:48:01Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **michail.vms**\r\n\r\nПредлагаю добавить спецификатор noexcept к функции contains из p0458 (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0458r0.html), а также к функции count стандартных контейнеров. А для метода find в качестве спецификации noexcept, если соответствующий конструктор итератора тоже noexcept.\r\n\r\nПолагаю, что спецификатор noexcept хорошо согласуется с неявным контрактом, который подразумевается для функций contains/count/find, применяемых для контейнеров как минимум с базовой гарантией исключений.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/320/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/320/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/319",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/319/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/319/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/319/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/319",
    "id": 844764515,
    "node_id": "MDU6SXNzdWU4NDQ3NjQ1MTU=",
    "number": 319,
    "title": "Добавление в std системы для работы с флагами и оператора flag",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T15:45:00Z",
    "updated_at": "2021-03-30T15:46:22Z",
    "closed_at": "2021-03-30T15:46:17Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **Сергей Щербаков**\r\n\r\nДобавляются std::flag8_t, flag16_t, flag32_t, flag64_t.\r\n\r\nТак же следующие функции:\r\n```cpp\r\nstd::clear_flag\r\nstd::add_flag\r\nstd::del_flag\r\nstd::check_flag\r\n```\r\nДалее пользователь языка создаёт перечесление:\r\n```cpp\r\nenum class camera_flag_t : std::flag8_t {\r\n  MoveLeft    = 1 << 0,\r\n  MoveRight   = 1 << 1,\r\n  MoveForward = 1 << 2,\r\n  MoveBack    = 1 << 3,\r\n  MoveSpeedUP = 1 << 4\r\n};\r\n```\r\nИспользовать можно так:\r\n```cpp\r\nfloat move = std::check_flag(camera_flag, camera_flag_t::MoveSpeedUP) ? movespeed * 10 : movespeed;\r\n\r\nif (key == GLFW_KEY_A) std::add_flag(ra->camera.camera_flag, camera_flag_t::MoveLeft);\r\n```\r\nКлючевой оператор flag является альтернативой enum, то есть создаёт перечесление флагов, но без описания побитового сдвига, то есть выглядить это будет так:\r\n```cpp\r\nflag class camera_flag_t : std::flag8_t {\r\n  MoveLeft,\r\n  MoveRight,\r\n  MoveForward,\r\n  MoveBack,\r\n  MoveSpeedUP\r\n};\r\n```\r\nК сожалению в добавление нового оператора flag верится мало :)\r\n![image](https://user-images.githubusercontent.com/1700098/113017342-062b1a80-9188-11eb-8ecb-c958d2474d33.png)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/319/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/319/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/318",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/318/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/318/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/318/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/318",
    "id": 844759476,
    "node_id": "MDU6SXNzdWU4NDQ3NTk0NzY=",
    "number": 318,
    "title": "std::bit_cast<T*> должен проверять выравнивание",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T15:42:02Z",
    "updated_at": "2021-03-30T15:42:47Z",
    "closed_at": "2021-03-30T15:42:47Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -1\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nв текущем предложение к C++20 std::bit_cast<T*> не отличается от reintrepret_cast<T*>\r\n\r\nпредлагается этот случай обработать и сделать дополнительные проверки, например проверять выравнивание указателей.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/318/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/318/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/317",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/317/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/317/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/317/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/317",
    "id": 844753918,
    "node_id": "MDU6SXNzdWU4NDQ3NTM5MTg=",
    "number": 317,
    "title": "Не принимать P1073R1 в текущем виде (constexpr! выражения, которые вычисляются _только_ на этапе компиляции)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T15:38:48Z",
    "updated_at": "2021-03-30T15:41:07Z",
    "closed_at": "2021-03-30T15:40:18Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +24, -1\r\n_Автор идеи:_ **Amomum**\r\n\r\nПредложение хорошее, но в нем предлагается использовать ключевое слово \"constexpr!\" для обозначения таких выражений. Считаю, что нужно новое ключевое слово.\r\n\r\nВ существующем виде в С++ нет ни одной пары ключевых слов, которые бы отличались всего одним символом. И нет ключевых слов, которые включают в себя спецсимволы (в том числе !).\r\n\r\nОтличие между constexpr и constexpr! не бросается в глаза, что может привести к путанице. К тому же constexpr! будет еще тяжелее произносить вслух или проговаривать про себя.\r\nКак это вообще проговорить - \"констэкспр восклицательный знак\"? \"Констэкспр банг\"? \"Констэкспр экскламейшн марк\"?\r\n\r\nГуглить \"constexpr!\" тоже будет очень тяжело, большинство поисковых систем фильтрует спецсимволы.\r\n\r\nСчитаю, что необходимо новое ключевое слово (compilet? compiletime?) или более значительная модификация слова \"constexpr\" (strict_constexpr? constexpr_only?), чтобы устранить вышеописанные проблемы.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/317/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/317/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/316",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/316/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/316/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/316/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/316",
    "id": 844749509,
    "node_id": "MDU6SXNzdWU4NDQ3NDk1MDk=",
    "number": 316,
    "title": "Убедить комитет не вводить новое ключевое слово constexpr!",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T15:36:15Z",
    "updated_at": "2021-04-06T19:13:25Z",
    "closed_at": "2021-03-30T15:37:35Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -2\r\n_Автор идеи:_ **neondev9**\r\n\r\nВ C++20 планируют вести так называемые constexpr!-выражения. Это как-бы тот же constexpr, но вот только работающий только compile-time.\r\n\r\nПредлагаю выбрать какое-либо альтернативное ключевое слово для подобных выражений, будь-то staticexpr или что-либо более точное. Но слово constexpr! однозначно не стоит вводить, поскольку оно: \r\n\r\n- сбивает с толку;\r\n\r\n- максимально идентично другому ключевому слову;\r\n\r\n- содержит в себе восклицательный знак, что абсолютно противоречит стилю именования ключевых слов в С++.\r\n\r\nСтоит заметить, что новое ключевое слово должно содержать -expr суффикс, и таким образом у нас будет семейство: constexpr, reflexpr, staticexpr (как вариант, но нужно что-то получше)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/316/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/316/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/315",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/315/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/315/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/315/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/315",
    "id": 844743629,
    "node_id": "MDU6SXNzdWU4NDQ3NDM2Mjk=",
    "number": 315,
    "title": "Стандартизировать #pragma once",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T15:33:01Z",
    "updated_at": "2021-03-30T15:35:00Z",
    "closed_at": "2021-03-30T15:35:00Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +24, -2\r\n_Автор идеи:_ **Evgeny Basargin**\r\n\r\nВ данный момент есть стандартный путь реализации защиты от двойного включения заголовка через конструкцию, реализуемую в 3 строчки:\r\n```cpp\r\n#ifndef MY_MACRO\r\n\r\n#define MY_MACRO\r\n\r\n// declarations here\r\n\r\n#endif\r\n```\r\nТакже есть нестандартный путь, реализуемый в одну строку:\r\n```cpp\r\n#pragma once\r\n\r\n// declarations here\r\n```\r\n\r\nХотелось бы чтобы механизм #pragma once, или что-то аналогичное ему, стало частью стандарта, т.к. такой путь менее многословный и исключает коллизии по именам макросов.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/315/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/315/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/314",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/314/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/314/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/314/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/314",
    "id": 844739616,
    "node_id": "MDU6SXNzdWU4NDQ3Mzk2MTY=",
    "number": 314,
    "title": "Шаблонные определения для строковых литералов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T15:30:14Z",
    "updated_at": "2021-03-30T15:31:55Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Gleb Lukianets**\r\n\r\nС++11 разрешает определять пользовательские литералы в следующем виде: \r\n```cpp\r\ntemplate<char ...> auto operator\"\"_op() { /* ... */ }\r\n```\r\nОднако это разрешено только для чисельных литералов. Не вижу причин не распространять действие подобных определений на строковые и символьные литералы тоже.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/314/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/314/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/313",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/313/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/313/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/313/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/313",
    "id": 844737390,
    "node_id": "MDU6SXNzdWU4NDQ3MzczOTA=",
    "number": 313,
    "title": "Не добавлять std::shift_left и std::shift_right, а добавить std::move_n и std::move_backward_n",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T15:28:44Z",
    "updated_at": "2021-03-30T15:29:31Z",
    "closed_at": "2021-03-30T15:29:31Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -1\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nВ 20 стандарт собираются добавить функции std::shift_left и std::shift_right, которые делают практически то же самое, что и std::move и std::move_backward за исключением того, что в качестве параметра для сдвига они принимают количество позиций, на которые нужно сделать сдвиг, а не итератор. Выглядит схоже с функциями вроде std::generate_n, и тд., которые также принимают количество, а не итератор.\r\n\r\nКак известно, у многих алгоритмов в c++ есть версии с суфиксом \"_n\", которые означают, что в качестве индикации прекращения выполнения нужно руководствоваться количеством действий, а не итератором, до которого эти действия выполнять. В с++20 собираются ввести функции std::shift_left и std::shift_right. Само их наличие обосновано и, если бы эти функции существовали уже давно, не было бы никаких претенция. Но, как уже было сказано, есть функции с префиксом \"_n\". Предлагаю переименовать функции std::shift_left и std::shift_right в std::move_n и std::move_backward_n, которые бы имели такую же сигнатуру",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/313/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/313/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/312",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/312/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/312/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/312/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/312",
    "id": 844304412,
    "node_id": "MDU6SXNzdWU4NDQzMDQ0MTI=",
    "number": 312,
    "title": "constexpr std::regex",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T09:51:59Z",
    "updated_at": "2021-04-06T18:55:27Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +46, -1\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nМножество языков программирования в данный момент компилируют/транслируют регулярные выражения ещё перед запуском программы. Таким образом, когда программа стартует, все регулярные выражения уже преобразованы в соптимизированный конечный автомат.\r\n\r\nПредлагаю добавить подобную возможность и для C++.\r\n```cpp\r\nbool is_valid_mail(std::string_view mail) {\r\n    static const std::regex mail_regex(R\"((?:(?:[^<>()\\[\\].,;:\\s@\\\"]+(?:\\.[^<>()\\[\\].,;:\\s@\\\"]+)*)|\\\".+\\\")@(?:(?:[^<>()\\[\\].,;:\\s@\\\"]+\\.)+[^<>()\\[\\].,;:\\s@\\\"]{2,}))\");\r\n\r\n    return std::regex_match(\r\n        std::cbegin(mail),\r\n        std::cend(mail),\r\n        mail_regex\r\n    );\r\n}\r\n```\r\nВ коде выше конечный автомат из регулярного выражения будет строится при первом заходе в функцию is_valid_mail(). Это долгая операция, которая в добавок будет выполняться в критической секции.\r\n\r\nС готовящимися новинками для constexpr вычислений (constexpr new, is_constexpr_evaluated() и др.) можно будет в C++20 делать множество вещей на этапе компиляции, в том числе можно будет сделать constexpr std::regex.\r\n\r\nС constexpr std::regex конечный автомат для функции is_valid_mail() построится ещё на этапе компиляции. Более того, GCC сможет генерировать оптимизированные регулярки на этапе компиляции без static const, т.к. начиная с GCC-6 если у constexpr функции все параметры на вход — константы, GCC форсирует вычисление на этапе компиляции. Багрепорт на добавление аналогично функционала в Clang уже есть",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/312/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/312/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/311",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/311/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/311/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/311/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/311",
    "id": 844299629,
    "node_id": "MDU6SXNzdWU4NDQyOTk2Mjk=",
    "number": 311,
    "title": "Переименовать все новые *_ref функции и классы в *_view",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T09:47:15Z",
    "updated_at": "2021-04-06T19:09:56Z",
    "closed_at": "2021-03-30T09:50:41Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +35, -9\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nНедавно в C++20 добавили класс atomic_ref. На подходе класс function_ref.\r\n\r\nРазные наименования для не владеющих классов (string_view, atomic_ref, function_ref, span...) смущают, хочется иметь консистентные имена.\r\n\r\nПредлагаю привести все имена к единому виду, с постфиксом _view:\r\n\r\n* string_view\r\n* atomic_view\r\n* function_view\r\n* span_view\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/311/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/311/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/310",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/310/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/310/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/310/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/310",
    "id": 844294280,
    "node_id": "MDU6SXNzdWU4NDQyOTQyODA=",
    "number": 310,
    "title": "Функции упаковки и распаковки битовых структур",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-30T09:41:53Z",
    "updated_at": "2021-08-28T16:41:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nХочется иметь функции, позволяющие конвертировать контейнеры, содержащие интегральные типы, в последовательность нулей и единиц. И наоборот.\r\n\r\nЧасто бывает нужно работать с последовательностью бит, а не байт. Для работы с битами удобно использовать std::vector<bool> или std::bitset, однако возникает необходимость сжать такую структуру в последовательность, например, uint64_t или же в строку. В битсет есть похожая функциональность в методах std::bitset::to_ulong и std::bitset::to_ullong, однако они возвращают не последовательность чисел, а лишь одно число, что ограничивает их применение.\r\n```cpp\r\ntemplate <class T, class InputIt, class OutputIt>\r\nvoid pack_bits_to(InputIt first, InputIt last, OutputIt d_first)\r\n{\r\n    static_assert(std::is_integral<T>::value);\r\n\r\n    while (first != last) {\r\n        DataType buf = 0;\r\n\r\n        for (std::size_t i = 0; i < 8 * sizeof(T); ++i) {\r\n            bool bit = (first != last) ? (*(first++)) : 0;\r\n            buf = buf | static_cast<DataType>(bit << i);\r\n        }\r\n\r\n        *(d_first++) = buf;\r\n    }\r\n}\r\n\r\ntemplate <class T, class InputIt, class OutputIt>\r\nvoid unpack_bits_from(InputIt first, InputIt last, OutputIt d_first)\r\n{\r\n    static_assert(std::is_integral<T>::value);\r\n\r\n    while (first != last) {\r\n        for (std::size_t i = 0; i < 8 * sizeof(T); ++i) {\r\n            *(d_first++) = (1 & (*first >> i));\r\n        }\r\n        ++first;\r\n    }\r\n}​\r\n```\r\nПример использования:\r\n```cpp\r\n// packing example\r\nstd::vector<bool> input = { 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0 };\r\nstd::string output;\r\npack_bits_to<char>(input.begin(), input.end(), std::back_inserter(output));\r\n// output == {0b10100000, 0b00110001}\r\n\r\n// unpacking example\r\nstd::string input = {0b10100000, 0b00110001};\r\nstd::vector<bool> output;\r\nunpack_bits_from<char>(input.begin(), input.end(), std::back_inserter(output));\r\n// output == { 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0 }\r\n```\r\nЗамечу, что в качестве последовательности бит совершенно не обязательно должен использоваться std::vector<bool>.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/310/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/310/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/309",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/309/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/309/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/309/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/309",
    "id": 844291125,
    "node_id": "MDU6SXNzdWU4NDQyOTExMjU=",
    "number": 309,
    "title": "Ключевое слово implementation(definition)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:38:49Z",
    "updated_at": "2021-03-30T09:40:07Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -1\r\n_Автор идеи:_ **Mikhail Shostak**\r\n\r\nДобавить ключевое слово implementation (или definition) позволяющее определять блок в котором производится реализация структуры или класса для сокращения избыточности кода\r\n\r\nСейчас мы имеем следующий синтаксис для раздельного объявления и определения функций-членов и статических переменных. Выглядит это так:\r\n```cpp\r\n//object.h\r\nnamespace scope\r\n{\r\n\r\nstruct object\r\n{\r\n    void xxx();\r\n    void yyy();\r\n    void zzz();\r\n\r\n    struct nested_object\r\n    {\r\n        using internal_type = size_t;\r\n        static internal_type static_variable;\r\n        internal_type member_variable;\r\n        internal_type xxx();\r\n        internal_type yyy();\r\n        internal_type zzz();\r\n    }\r\n}\r\n\r\n}\r\n\r\n//object.cpp\r\nnamespace scope\r\n{\r\n\r\nvoid object::xxx() { /*code*/ }\r\nvoid object::yyy() { /*code*/ }\r\nvoid object::zzz() { /*code*/ }\r\n\r\nobject::nested_object::internal_type object::nested_object::static_variable = 0;\r\nobject::nested_object::internal_type object::nested_object::xxx() { /*code*/ }\r\nobject::nested_object::internal_type object::nested_object::yyy() { /*code*/ }\r\nobject::nested_object::internal_type object::nested_object::zzz() { /*code*/ }\r\n\r\n}\r\n```\r\nВ .cpp файле получается довольно много повторяющегося кода. С шаблонами лишнего кода становится еще больше. Возможно что-то подобное предлагали, но было бы неплохо иметь механизм в языке, который позволял бы не писать каждый раз 'object::nested_object::'. Использовать его можно примерно так (далее .cpp файл к предыдущему .h файлу):\r\n```cpp\r\n//object.cpp\r\nnamespace scope\r\n{\r\n\r\nimplementation object\r\n{\r\n    void xxx() { /*code*/ } //scope::object::xxx\r\n    void yyy() { /*code*/ }\r\n    void zzz() { /*code*/ }\r\n\r\n    implementation nested_object\r\n    {\r\n        internal_type static_variable = 0; //scope::object::nested_object::internal_type scope::object::nested_object::static_variable\r\n        internal_type xxx() { /*code*/ }\r\n        internal_type yyy() { /*code*/ }\r\n\r\n        internal_type member_variable = 0; //error: 'scope::object::nested_object::member_variable': is not a static member\r\n        internal_type undeclared_variable = 0; //error: 'undeclared_variable': is not a member of 'scope::object::nested_object'\r\n        inline void undeclared_function() { /*code*/ }  //error: 'undeclared_function': is not a member of 'scope::object::nested_object'\r\n        //etc.\r\n    };\r\n\r\n    nested_object::internal_type nested_object::zzz() {} //old-style definition can be used also. should be resolved as scope::object::nested_object::internal_type scope::object::nested_object::zzz();\r\n};\r\n\r\n}\r\n```\r\nИдея довольно простая. К сожалению такое нельзя делать используя ключевое слово namespace потому, что компилятор не будет знать что программист хочет определить - глобальную функцию в пространстве имен или же функцию класса. Да и сам класс с пространством имен может конфликтовать. Но это можно сделать с помощью дополнительного ключевого слова. Очевидно, что минус введения нового ключевого слова это то, что старый код, который использует это слово может поломаться. (На самом деле это моё самое большое опосение по этому предложению. Но в c++11 же добавляли новые ключевые слова, возможно со скрипом, но всё же)\r\n\r\nЧто касается самой конструкции implementation object {}, то она просто говорит компилятору, что всё что определено внутри скобок будет относится к структуре object, в данном случае, которая находится в пространстве имен scope. Таким образом группировка кода позволяет уменьшить избыточность и повысить читабельность кода (Зависит от ситуации конечно. Я давно привык к синтаксису c++, ниже будет пример с шаблонами :P). Т.к. код сгруппирован, то следоватьно внутри блока будет только реализация конкретного класса. Это может поспособствовать организации кода. Возможно кому-то это покажется неудобным, т.к. не получится временно создать глобальную функцию/переменную внутри implementation блока и её придётся помещать в начало. С другой стороны предполагается, что у класса может быть несколько implementation блоков, если требуется вынести часть реализации в другое место или нужно сделать include чего-то прямо в середину файла (мало ли). Сам implementation по-сути работает как некое пространство, внутри которого можно не писать длинные конструкции с путями к реализуемой сущности и/или добавлять параметры шаблона относящиеся к классу для которого мы делаем имплементацию. Не уверен как компиляторы парсят определения функций, но на первый взгляд кажется, что implementaion блок может немного уменьшить время компиляции. Компилятору не нужно будет постоянно парсить типы для нового встреченного определения, он может взять тип из контекста, который у него есть после встречи ключевого слова implementation. Так же отпадает надобность добавлять названия классов в возвращаемые типы, если мы используем тип из нашего класса, ну в общем всё что можно из контекста блоков взять.\r\n\r\nТеперь посмотрим на вариант с шаблонами. Есть, например, библиотека gml с математикой для OpenGL на манер GLSL. Там довольно много шаблонов с вынесенной реализацией в .inl файлы. Так же зависимость двух классов друг от друга (возможно это плохая архитектура) может потребовать вынести реализацию шаблонов из класса, чтобы можно было сделать #include другого файла (ну или если банально два небольших шаблонных класса с несколькими функциями находятся в одном файле, и реализацию снизу нужно написать). В общем шаблонный код может выглядеть как-то так:\r\n```cpp\r\n//template_object.h\r\nnamespace scope\r\n{\r\n\r\ntemplate<class T1>\r\nstruct template_object\r\n{\r\n    template<class T2>\r\n    struct nested_object\r\n    {\r\n        using internal_type = size_t;\r\n        static internal_type static_variable;\r\n\r\n        template<class U1, class U2>\r\n        T1 foo(U1 u1, U2 u2);\r\n\r\n        template<class U1, class U2>\r\n        T2 bar(U1 u1, U2 u2);\r\n    };\r\n\r\n    template<class U1, class U2>\r\n    T1 xxx(U1 u1, U2 u2);\r\n\r\n    template<class U1, class U2>\r\n    T1 yyy(U1 u1, U2 u2);\r\n\r\n    template<class U1, class U2>\r\n    T1 zzz(U1 u1, U2 u2);\r\n};\r\n\r\n}\r\n\r\n#include \"template_object.inl\"\r\n\r\n//template_object.inl\r\nnamespace scope\r\n{\r\n\r\ntemplate<class T1>\r\ntemplate<class T2>\r\ntemplate_object<T1>::nested_object<T2>::internal_type template_object<T1>::nested_object<T2>::static_variable = 0;\r\n\r\ntemplate<class T1>\r\ntemplate<class T2>\r\ntemplate<class U1, class U2>\r\ninline T1 template_object<T1>::nested_object<T2>::foo(U1 u1, U2 u2) { /*code*/ }\r\n\r\ntemplate<class T1>\r\ntemplate<class T2>\r\ntemplate<class U1, class U2>\r\ninline T2 template_object<T1>::nested_object<T2>::bar(U1 u1, U2 u2) { /*code*/ }\r\n\r\ntemplate<class T1>\r\ntemplate<class U1, class U2>\r\ninline T1 template_object<T1>::xxx(U1 u1, U2 u2) { /*code*/ }\r\n\r\ntemplate<class T1>\r\ntemplate<class U1, class U2>\r\ninline T1 template_object<T1>::yyy(U1 u1, U2 u2) { /*code*/ }\r\n\r\ntemplate<class T1>\r\ntemplate<class U1, class U2>\r\ninline T1 template_object<T1>::zzz(U1 u1, U2 u2) { /*code*/ }\r\n\r\n}\r\n```\r\nту же самую реализацию можно было бы записать следующим образом:\r\n```cpp\r\n//template_object.inl\r\nnamespace scope\r\n{\r\n\r\ntemplate<class T1>\r\nimplementation template_object<T1>\r\n{\r\n    template<class T2>\r\n    implementation nested_object<T2>\r\n    {\r\n        internal_type static_variable = 0;\r\n\r\n        template<class U1, class U2>\r\n        inline T1 foo(U1 u1, U2 u2) { /*code*/ }\r\n\r\n        template<class U1, class U2>\r\n        inline T2 bar(U1 u1, U2 u2) { /*code*/ }\r\n    }\r\n\r\n    template<class U1, class U2>\r\n    inline T1 xxx(U1 u1, U2 u2) { /*code*/ }\r\n\r\n    template<class U1, class U2>\r\n    inline T1 yyy(U1 u1, U2 u2) { /*code*/ }\r\n\r\n    template<class U1, class U2>\r\n    inline T1 zzz(U1 u1, U2 u2) { /*code*/ }\r\n}\r\n\r\n}\r\n```\r\nВозможно такой вариант без шаблонных параметров U1 и U2 будет наглядней:\r\n```cpp\r\n//template_object.inl\r\nnamespace scope\r\n{\r\n\r\ntemplate<class T1>\r\ntemplate<class T2>\r\ntemplate_object<T1>::nested_object<T2>::internal_type template_object<T1>::nested_object<T2>::static_variable = 0;\r\n\r\ntemplate<class T1>\r\ntemplate<class T2>\r\ninline T1 template_object<T1>::nested_object<T2>::foo() { /*code*/ }\r\n\r\ntemplate<class T1>\r\ntemplate<class T2>\r\ninline T2 template_object<T1>::nested_object<T2>::bar() { /*code*/ }\r\n\r\ntemplate<class T1>\r\ninline T1 template_object<T1>::xxx() { /*code*/ }\r\n\r\ntemplate<class T1>\r\ninline T1 template_object<T1>::yyy() { /*code*/ }\r\n\r\ntemplate<class T1>\r\ninline T1 template_object<T1>::zzz() { /*code*/ }\r\n\r\n}\r\n//vs\r\nnamespace scope\r\n{\r\n\r\ntemplate<class T1>\r\nimplementation template_object<T1>\r\n{\r\n    template<class T2>\r\n    implementation nested_object<T2>\r\n    {\r\n        internal_type static_variable = 0;\r\n        inline T1 foo() { /*code*/ }\r\n        inline T2 bar() { /*code*/ }\r\n    }\r\n    inline T1 xxx() { /*code*/ }\r\n    inline T1 yyy() { /*code*/ }\r\n    inline T1 zzz() { /*code*/ }\r\n}\r\n\r\n}\r\n```\r\nНу и небольшой пример с c++ в перемешку с objective-c в котором есть подобная конструкция. Язык obj-c позволяет с её помощью делать много других интересных вищей, но это другая история. Так же хотелось бы упоминуть что в obj-c используется ключевое слово @implementation для этих целей. Поэтому поддержка подобного ключего слова для c++ не должна ломать .mm файлы. Возможно в таком случае лучше использовать ключевое слово definition в c++.\r\n```cpp\r\n//FooBar.h\r\nclass Foo\r\n{\r\n    void foo();\r\n};\r\n\r\n@interface Bar : NSObject\r\n-(void)bar;\r\n@end\r\n\r\n//FooBar.mm\r\nimplementation Foo\r\n{\r\n    void foo() { /*code*/ }\r\n};\r\n\r\n@implementation Bar\r\n    -(void)bar { /*code*/ }\r\n@end\r\n```\r\nНа первый взгляд obj-c может показаться страшным, и я знаю c++ программистов, которые сразу вскрикивают услышав слово objective-c и начинают говорить про его ужасный синтаксис. Но проработав 2 года на obj-c и около 5 лет с c++. Моё мнение склоняется к тому, что obj-c выглядит более читабельным чем c++. Хотя, отчасти на это оказывают влияние спецефичные для obj-c механики, которые вряд ли появятся в c++. Моё мнение может быть субъективным. Так что хотелось бы получить объективную и конструктивную критику этого предложения. :)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/309/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/309/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/308",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/308/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/308/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/308/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/308",
    "id": 844288285,
    "node_id": "MDU6SXNzdWU4NDQyODgyODU=",
    "number": 308,
    "title": "Неявный оператор присваивания для классов с const полями",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:35:57Z",
    "updated_at": "2021-03-30T09:36:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -3\r\n_Автор идеи:_ **Андрей Руссков**\r\n\r\nУбрать ограничение на изменяемость полей для копирующего оператора присваивания\r\n\r\nСейчас для классов с const полями неявный оператор присваивания не генерируется, т.к. он эквивалентен поэлементному присваиванию полей, недоступному в случае const. Пример:\r\n```cpp\r\nstruct S {\r\n  int a;\r\n  const int b;\r\n};\r\n\r\nS s {1,2};\r\ns = {3,4}; // error: non-static const member 'const int S::b', can't use default assignment operator @ gcc\r\n```\r\n\r\nОднако, при таком подходе теряется сама суть ограничения const для поля класса - неизменяемость поля выливается в незаменяемость экземпляра. В таком случае легально заменить экземпляр можно используя пару из деструктора и copy-конструктора:\r\n```cpp\r\nauto p = &s;\r\ns.~S();\r\nnew (std::launder(p)) S({3,4});\r\n```\r\nчто куда хуже отражает суть намерений программиста.\r\n\r\n \r\n\r\nПредлагаю: не удалять неявный оператор копирующего присваивания из-за наличия const полей в случае доступности копирующих конструкторов этих полей.\r\n\r\n \r\n\r\nВлияние на существующий код: может поменяться поведение для кода, зависящего от свойства is_copy_assignable.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/308/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/308/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/307",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/307/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/307/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/307/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/307",
    "id": 844282001,
    "node_id": "MDU6SXNzdWU4NDQyODIwMDE=",
    "number": 307,
    "title": "Добавить в стандартную библиотеку intrusive_ptr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:29:50Z",
    "updated_at": "2021-03-30T09:30:16Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -0\r\n_Автор идеи:_ **kotbegemot** @kotbegemot\r\n\r\nУстал от того что в стандартной библиотеки не какой альтернативе shared_ptr предлагаю добавить intrusive_ptr.\r\nhttps://github.com/kotbegemot/intrusive_ptr принимаю предложения и комментарии.\r\n\r\n```cpp\r\ntemplate<class T>\r\n    class intrusive_ptr {\r\n    public:\r\n        using pointer = T*;\r\n        using const_pointer = const T*;\r\n        using element_type = T;\r\n        using reference = T&;\r\n        using const_reference = const T&;\r\n\r\n        constexpr intrusive_ptr() noexcept : ptr_(nullptr) {}\r\n\r\n        intrusive_ptr(pointer raw_ptr, bool add_ref = true) noexcept {\r\n            set_ptr(raw_ptr, add_ref);\r\n        }\r\n\r\n        intrusive_ptr(intrusive_ptr &&other) noexcept : ptr_(other.detach()) {}\r\n\r\n        intrusive_ptr(const intrusive_ptr &other) noexcept {\r\n            set_ptr(other.get(), true);\r\n        }\r\n\r\n        template<class Y>\r\n        intrusive_ptr(intrusive_ptr<Y> other) : ptr_(other.detach()) {\r\n            static_assert(std::is_convertible<Y *, T *>::value,\r\n                          \"Y* is not assignable to T*\");\r\n        }\r\n\r\n        intrusive_ptr &operator=(pointer ptr) noexcept {\r\n            reset(ptr);\r\n            return *this;\r\n        }\r\n\r\n        intrusive_ptr &operator=(intrusive_ptr other) noexcept {\r\n            swap(other);\r\n            return *this;\r\n        }\r\n\r\n        ~intrusive_ptr() {\r\n            if (ptr_) {\r\n                intrusive_ptr_release(ptr_);\r\n            }\r\n        }\r\n\r\n        pointer detach() noexcept {\r\n            auto result = ptr_;\r\n            if (result) {\r\n                ptr_ = nullptr;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        pointer release() noexcept {\r\n            return detach();\r\n        }\r\n\r\n        void reset(pointer new_value = nullptr, bool add_ref = true) noexcept {\r\n            auto old = ptr_;\r\n            set_ptr(new_value, add_ref);\r\n            if (old) {\r\n                intrusive_ptr_release(old);\r\n            }\r\n        }\r\n\r\n        pointer get() const noexcept {\r\n            return ptr_;\r\n        }\r\n\r\n        pointer operator->() const noexcept {\r\n            return ptr_;\r\n        }\r\n\r\n        reference operator*() const noexcept {\r\n            return *ptr_;\r\n        }\r\n\r\n        bool operator!() const noexcept {\r\n            return ptr_ == nullptr;\r\n        }\r\n\r\n        explicit operator bool() const noexcept {\r\n            return ptr_ != nullptr;\r\n        }\r\n\r\n        void swap(intrusive_ptr &other) noexcept {\r\n            std::swap(ptr_, other.ptr_);\r\n        }\r\n\r\n        template<class C>\r\n        intrusive_ptr<C> downcast() const noexcept {\r\n            return (ptr_) ? dynamic_cast<C *>(get()) : nullptr;\r\n        }\r\n\r\n        template<class C>\r\n        intrusive_ptr<C> upcast() const noexcept {\r\n            return (ptr_) ? static_cast<C *>(get()) : nullptr;\r\n        }\r\n\r\n    private:\r\n        inline void set_ptr(pointer raw_ptr, bool add_ref) noexcept {\r\n            ptr_ = raw_ptr;\r\n            if (raw_ptr && add_ref) {\r\n                intrusive_ptr_add_ref(raw_ptr);\r\n            }\r\n        }\r\n\r\n        pointer ptr_;\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/307/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/307/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/306",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/306/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/306/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/306/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/306",
    "id": 844279421,
    "node_id": "MDU6SXNzdWU4NDQyNzk0MjE=",
    "number": 306,
    "title": "<algorithm> который можно использовать в constexpr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:27:12Z",
    "updated_at": "2021-03-30T09:28:53Z",
    "closed_at": "2021-03-30T09:28:53Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nНеобходимо для рефлексии, метаклассов и упрощения метапрограммирования.\r\n\r\nАлгоритмы не используещие swap помечаются как constexpr в https:/wg21.link/p0202\r\n\r\nОставшиеся алгоримы, использующие swap, помечаются как constexpr в https:/wg21.link/p0879",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/306/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/306/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/305",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/305/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/305/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/305/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/305",
    "id": 844276891,
    "node_id": "MDU6SXNzdWU4NDQyNzY4OTE=",
    "number": 305,
    "title": "std::complex котороый можно использовать в constexpr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-30T09:24:41Z",
    "updated_at": "2021-03-30T09:33:26Z",
    "closed_at": "2021-03-30T09:33:26Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nПо почте РГ21 попросили сделать так, чтобы std::complex мог использоваться в constexpr функциях.\r\n\r\nНеобходимо добавить несколько constexpr к функциям, да предоставить прототип, показывающий что действительно возможно реализовать constexpr методы класса в современном C++.\r\n\r\nПредложение и прототип: \"Constexpr for std::complex\" http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0415r1.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/305/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/305/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/304",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/304/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/304/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/304/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/304",
    "id": 844273950,
    "node_id": "MDU6SXNzdWU4NDQyNzM5NTA=",
    "number": 304,
    "title": "Убедить международный комитет не дублировать все контейнеры стандартной библиотеки",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:21:51Z",
    "updated_at": "2021-03-30T09:23:03Z",
    "closed_at": "2021-03-30T09:22:23Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +16, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nЕсть предложение по созданию constexpr_vector. Идея хорошая, но потенциально выльется в дублирование всех контейнеров стандартной библиотеки с припиской constexpr_.\r\n\r\nСтоит показать альтернативы такому подходу.\r\n\r\nВ [std::constexpr_vector<T>](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0597r0.html) предлагается сделать специальный контейнер, который сможет аллоцировать память в константных выражениях и который можно будет использовать только в constexpr функциях только если они в constexpr контексте.\r\n\r\nИдея отличная, но потенциально выльется в дублирование всех контейнеров стандартной библиотеки с припиской constexpr_.\r\n\r\nНеобходимо убедить международный комитет в том, что возможно модифицировать уже имеющиеся контейнеры так, что их можно будет использовать в constexpr.\r\n\r\nПредложение: \"Changing attack vector of the constexpr_vector\" http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0639r0.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/304/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/304/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/303",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/303/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/303/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/303/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/303",
    "id": 844272400,
    "node_id": "MDU6SXNzdWU4NDQyNzI0MDA=",
    "number": 303,
    "title": "Constexpr для std::char_traits и std::string_view",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-30T09:20:19Z",
    "updated_at": "2021-03-30T09:20:36Z",
    "closed_at": "2021-03-30T09:20:36Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nМетоды std::string_view помечены как constexpr, но их по прежнему невозможно использовать в константных выражениях. Стоит это исправить.\r\n\r\nНеобходимо пометить часть методов std::char_traits как constexpr и убедиться в том, что данное изменение можно произвести не ухудшив производительность приложения.\r\n\r\nПредложение: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0426r1.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/303/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/303/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/302",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/302/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/302/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/302/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/302",
    "id": 844271089,
    "node_id": "MDU6SXNzdWU4NDQyNzEwODk=",
    "number": 302,
    "title": "*affinity* support",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:18:59Z",
    "updated_at": "2021-03-30T09:19:31Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -1\r\n_Автор идеи:_ **void78**\r\n\r\n\r\nCurrently C++ is not aware of set/get affinity calls.\r\nGiven the fact C++ has threads' support out of the box it makes sense to make one step ahead and think about adding that functionality.\r\n\r\nSometime it's crucial for the application to handle incoming events as much as possible.\r\nOne of the possible way for that might be 'stealing' CPU core from the OS so does not participate in scheduling and bind your thread to that core.\r\nSure we can always make kind of cpu binder:\r\n```cpp\r\nclass ThreadCpuBinder\r\n{\r\npublic:\r\n   ThreadCpuBinder(int cpu)\r\n   {\r\n      if(cpu != -1)\r\n      {\r\n          cpu_set_t cpuSet;\r\n\r\n          CPU_ZERO(&cpuSet);\r\n          CPU_SET(cpu, &cpuSet);\r\n\r\n          if(pthread_setaffinity_np(pthread_self(), sizeof(cpuSet), &cpuSet))\r\n          {\r\n              // error indication\r\n          }\r\n      }\r\n   }\r\n};\r\n```\r\n\r\nHope you've got enough with that)\r\nAs for me I'd prefer to see 'cpu_set_t' class/struct (or whatever it will be called) which contains CPUs out thread/task/async is allowed to use.\r\nImplementing that sort of class has one important property - backward compatibility: in case you do not care about affinity you can simple  ignore that parameter on creating stage.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/302/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/302/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/301",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/301/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/301/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/301/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/301",
    "id": 844269635,
    "node_id": "MDU6SXNzdWU4NDQyNjk2MzU=",
    "number": 301,
    "title": "constexpr для begin/end/reverse_iterator/move_iterator и базовых методов array",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-30T09:17:26Z",
    "updated_at": "2021-03-30T09:17:54Z",
    "closed_at": "2021-03-30T09:17:54Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nПометить часть простых методов и классов как constexpr\r\n\r\nПредложение: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/301/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/301/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/300",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/300/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/300/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/300/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/300",
    "id": 844264702,
    "node_id": "MDU6SXNzdWU4NDQyNjQ3MDI=",
    "number": 300,
    "title": "compile-time memory::unit ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-30T09:12:11Z",
    "updated_at": "2021-03-31T09:00:05Z",
    "closed_at": "2021-03-31T08:59:58Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -3\r\n_Автор идеи:_ **neondev9**\r\n\r\n\r\nПо мотивам std::chrono::duration и по мотивам календаря (С++20), шаблонный тип memory::unit, представляющий собой единицу измерения количества информации, предоставляющий удобные литералы и преобразования в другие размерности, а также арифметику в удобочитаемом виде.\r\nПредставленный пример работы типа основан на рабочем концепте (С++14). Изменения в ядре никакие не требуются. Имена типов и литералов\r\nможно поменять.\r\nВ арифметике общий тип вычисляется по принципу наименьшей размерности: Кбайт + байт -> байт; Мбайт + Кбайт -> Кбайт.\r\n\r\n```cpp\r\ninclude \"memory_unit.h\"\r\n\r\nconstexpr void Foo()\r\n{\r\n\tusing namespace memory::literals;\r\n\r\n\tconstexpr memory::bits\t    a1{1};\r\n\tconstexpr memory::bytes\t    a2{1};\r\n\tconstexpr memory::kilobytes a3{1};\r\n\tconstexpr memory::megabytes a4{1};\r\n\tconstexpr memory::gigabytes a5{1};\r\n\tconstexpr memory::terabytes a6{1};\r\n\r\n\tconstexpr memory::kilobits  a7{1}; // kilobits!\r\n\tconstexpr memory::megabits  a8{1};\r\n\tconstexpr memory::gigabits  a9{1};\r\n\r\n\tconstexpr memory::nibbles   b1{1}; // 4 bits\r\n\tconstexpr memory::words\t    b2{1}; // platform_type\r\n\t// literals\r\n\tconstexpr memory::bits      literal_1 = 1bit;\r\n\tconstexpr memory::bytes\t    literal_2 = 1byte;\r\n\tconstexpr memory::kilobytes literal_3 = 1kb;\r\n\tconstexpr memory::megabytes literal_4 = 1mb;\r\n\tconstexpr memory::gigabytes literal_5 = 1gb;\r\n\tconstexpr memory::terabytes literal_6 = 1tb;\r\n\t\t\t\t\t\t\t\t\t\t  \r\n\tconstexpr memory::kilobits  literal_7 = 1kbit; \r\n\tconstexpr memory::megabits  literal_8 = 1mbit;\r\n\tconstexpr memory::gigabits  literal_9 = 1gbit;\r\n\t// floating-point literals + conversion\r\n\tconstexpr memory::bytes\t    e1 = 2.5mb; // 2621440 bytes\r\n\tconstexpr memory::kilobytes e2 = 2.5mb; // 2560 kilobytes\r\n\t// conversion\r\n\tconstexpr memory::bits\t    d1 = 1byte; // d3.count() returned 8\r\n\tconstexpr memory::bytes\t    d2 = 1kb;\t// ok: kilobyte > byte\r\n\tconstexpr memory::bytes\t    d3 = 100mb;\t// ok: megabyte > byte\r\n\tconstexpr memory::megabytes d4 = 2gb;\t// ok: gigabyte > megabyte\r\n\r\n\tconstexpr memory::kilobytes error = 512byte; // error C2440: cannot convert from \"memory::bytes\" to \"memory::kilobytes\"\r\n\t// but...\r\n\tconstexpr memory::kilobytes not_error1 = memory::unit_cast<memory::kilobytes>(1024byte); // 1 kilobytes\r\n\tconstexpr memory::kilobytes not_error2 = memory::floor<memory::kilobytes>(2561byte);\t // 2 kilobytes\r\n\tconstexpr memory::kilobytes not_error3 = memory::ceil <memory::kilobytes>(2561byte);\t // 3 kilobytes\r\n\tconstexpr memory::kilobytes not_error4 = memory::round<memory::kilobytes>(2561byte);\t // 3 kilobytes\r\n\r\n\tconstexpr auto floating_point_type = 1.25kb; // typeid: memory::unit<long_double, memory::internal_ratio::kilobytes>\r\n\t// arithmetic\r\n\tconstexpr auto f1 = 3kb + 5kb;  // memory::killobytes{8}\r\n\tconstexpr auto f2 = 3kb + 5mb;  // 3 kilobytes + 5 megabytes = memory::kilobytes{5123}\r\n\r\n\tconstexpr auto f3 = f2 + 5byte; // 5123 kilobytes + 5 bytes = memory::bytes{5245957}\r\n\tconstexpr auto f4 = 1gb + 512mb - 100kb; // 1 gigabyte + 512 megabyte - 100 kilobytes = memory::kilobytes{1572764}\r\n\t// mixed arithmetic: double + long long int + double\r\n\tconstexpr auto f5 = 1.25kb + 1mb + 0.07mb; // 1096.93 kilobytes\r\n\r\n\t// comparison\r\n\tconstexpr bool g1{ 1kb == 1024byte }; // true\r\n\tconstexpr bool g2{ 512mb != 0.5gb };  // false\r\n\tconstexpr bool g3{ 1mb > 1kb };\t      // true\r\n\tconstexpr bool g4{ 1tb < 1gb };\t      // false\r\n\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/300/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/299",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/299/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/299/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/299/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/299",
    "id": 844261678,
    "node_id": "MDU6SXNzdWU4NDQyNjE2Nzg=",
    "number": 299,
    "title": "Добавить inline constexpr для std::nothrow внутри <new>",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      },
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T09:08:54Z",
    "updated_at": "2021-03-30T09:11:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Текущая декларация имеет следующий вид:\r\n```cpp\r\nstruct nothrow_t\r\n{\r\n#if __cplusplus >= 201103L\r\n  explicit nothrow_t() = default;\r\n#endif\r\n};\r\n\r\nextern const nothrow_t nothrow;\r\n```\r\nПри компиляции с -nostdlib выдает ошибку линковки (не находит константу std::nothrow)\r\n\r\nТекущий workaround:\r\n```cpp\r\nauto p1 = new (std::nothrow_t{}) foo;\r\n```\r\nили\r\n```cpp\r\nauto mynothowconst = std::nothrow_t{};\r\n\r\nauto p2 = new (mynothowconst) foo;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/299/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/299/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/298",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/298/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/298/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/298/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/298",
    "id": 844260144,
    "node_id": "MDU6SXNzdWU4NDQyNjAxNDQ=",
    "number": 298,
    "title": "Алгоритм для нахождения преобладающего элемента в последовательности",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T09:07:17Z",
    "updated_at": "2021-03-30T09:23:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -1\r\n_Автор идеи:_ **progzdeveloper**\r\n\r\nПредлагается добавить в STL реализацию алгоритма [для нахождения преобладающего элемента в последовательности](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B0_%D0%B3%D0%BE%D0%BB%D0%BE%D1%81%D0%BE%D0%B2_%D0%91%D0%BE%D0%B9%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%9C%D1%83%D1%80%D0%B0).\r\n\r\nПод преобладающим элементом подразумевается элемент который встречается больше n/2 раз в массиве длины n. Поиск может быть выполнен за линейное время с использованием O(1) памяти.\r\n\r\nЭтот алгоритм хорошо известен и имеет широкое применение.\r\n\r\nСигнатуры функций, реализующих алгоритм, могут выглядеть так:\r\n```cpp\r\ntemplate <class _FwdIt>\r\n_FwdIt majority_element(_FwdIt begin, _FwdIt end);\r\n\r\ntemplate <class _FwdIt, class _Comp>\r\n_FwdIt majority_element(_FwdIt begin, _FwdIt end, _Comp comp);\r\n```\r\nТип _FwdIt должен удовлетворять концепту forward-only итератора.\r\nФункции должны принимать диапазон [first, last), и возвращать итератор, указывающий на преобладающий элемент, если таковой имеется, иначе - last.\r\nВторой вариант функции принимает пользовательский функтор сравнения элементов, как это принято в STL.\r\n\r\nВ пару к представленным функциям, предлагаются также функции проверки - является ли некоторое значение преобладающим элементом:\r\n```cpp\r\ntemplate <class _FwdIt, class _Value>\r\nbool is_majority_element(_FwdIt begin, _FwdIt end, const _Value& x);\r\n\r\ntemplate <class _FwdIt, class _Value, class _Comp>\r\nbool is_majority_element(_FwdIt begin, _FwdIt end, const _Value& x, _Comp comp);\r\n```\r\nВ целом семантика этих функций схожа с предыдущими. Функции должны принимать диапазон [first, last) и проверяемый элемент x. Возвращаемое значение: true - если элемент x является преобладающим, иначе - false.\r\n\r\nDraft-реализация алгоритмов доступна на [github](https://github.com/progzdeveloper/majority-element-proposal).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/298/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/298/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/297",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/297/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/297/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/297/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/297",
    "id": 844257650,
    "node_id": "MDU6SXNzdWU4NDQyNTc2NTA=",
    "number": 297,
    "title": "Универсальный метод (maybe_const)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:04:48Z",
    "updated_at": "2021-03-30T09:05:55Z",
    "closed_at": "2021-03-30T09:05:49Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -5\r\n_Автор идеи:_ **Андрей Марцинкевич**\r\n\r\nИдея в том, что бы можно было написать метод, который бы работал как с const this, так и не с const. Проблема особенно актуальна для классов контейнеров, ибо сейчас нужно пистаь разные методы для const и не const\r\n\r\nКак это может выглядеть:\r\n\r\n \r\n```cpp\r\ntemplate <typename T>\r\nclass Val\r\n{\r\npublic:\r\n\r\n  decltype(auto) get() maybe_const\r\n  {\r\n     return _val;\r\n  }\r\n\r\nprivate:\r\n  T _val;\r\n};\r\n\r\n\r\nVal<int> val;\r\nconst Val<int>& cval = val;\r\n\r\nval.get() = 4; //OK, return int&\r\ncval.get() = 5; //Compile error, return const int&\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/297/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/297/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/296",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/296/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/296/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/296/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/296",
    "id": 844255368,
    "node_id": "MDU6SXNzdWU4NDQyNTUzNjg=",
    "number": 296,
    "title": "Добавить проверку на `nullptr` в конструкторе `basic_string(const char_type *)`",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T09:02:36Z",
    "updated_at": "2021-03-30T09:03:27Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -11\r\n_Автор идеи:_ **Евгений Захаров**\r\n\r\nКод\r\n\r\n ```\r\n\r\nconst char *str = nullptr;\r\n\r\nif(myService.isOnline()){\r\n\r\n    str = myService.name();\r\n\r\n}\r\n\r\nstd::string s = str;\r\n\r\n```\r\n\r\nупадет на последней строке если условие не выполнится. Как следствие `std::string s = 0;` тоже упадет. Логичнее добавить проверну на `nullptr` и в его случае инициализировать пустую строку",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/296/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/295",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/295/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/295/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/295/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/295",
    "id": 844249537,
    "node_id": "MDU6SXNzdWU4NDQyNDk1Mzc=",
    "number": 295,
    "title": "Перенести boost::intrusive_ptr и boost::thread_specific_ptr в стандартную библиотеку",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-30T08:56:30Z",
    "updated_at": "2021-03-30T09:33:10Z",
    "closed_at": "2021-03-30T09:33:10Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -0\r\n_Автор идеи:_ **Виктор Губин**\r\n\r\nВ стандартной библиотеке не хватает интеллектуального указателя с встроенным счетчиком ссылок (make_shared/enable_shared_from_this не совсем то) и Hazard pointer-ра. Однако они есть в Boost, и что если их перенести в стандартную библиотеку вслед за shared_ptr и weak_ptr ?\r\n\r\nBoost не всегда есть под рукой, к тому-же в [есть ситуации](https://google.github.io/styleguide/cppguide.html) когда вообще нельзя использовать Boost или можно только часть библиотек.\r\n\r\nsmart_pointer и thread уже включены в стандартную библиотеку, почему-бы ее не расширить проверенными решениями.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/295/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/295/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/294",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/294/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/294/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/294/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/294",
    "id": 844243849,
    "node_id": "MDU6SXNzdWU4NDQyNDM4NDk=",
    "number": 294,
    "title": "std::allocate_unique",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2021-03-30T08:50:34Z",
    "updated_at": "2022-10-26T09:24:15Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -0\r\n_Автор идеи:_ **Андрей Марцинкевич**\r\n\r\nВ общем мы имеем std::make_unique, но почему то не имеем std::allocate_unique для работы с кастомными аллокаторами. Ибо инициализировать сейчас unique_ptr для кастомного аллокатора довольно не тривиально (выделить память, вызвать конструктор, написать правильно custom_deleter). Поэтому и предлагаю вынести всю эту работу в std::allocate_unique. Думаю добавить его в STL особо не составит труда.\r\n\r\nПример использования:\r\n```cpp\r\nCustomAlloc<CustomStruct> alloc;\r\nauto up = std::allocate_unique<int>(alloc, customArg);\r\n\r\n//вместо\r\n\r\nCustomAlloc<CustomStruct>  alloc;\r\n\r\nauto newObj = new (alloc.allocate(1)) TestStruct,\r\n\r\nauto dealloc = [alloc = std::move(alloc)](CustomStruct* obj)\r\n{\r\n  obj->~CustomStruct(); \r\n  alloc.deallocate(obj, 1);\r\n};\r\n\r\n\r\nauto up = std::unique_ptr<TestStruct, decltype(dealloc)>(newObj, dealloc);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/294/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/294/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/293",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/293/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/293/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/293/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/293",
    "id": 844241275,
    "node_id": "MDU6SXNzdWU4NDQyNDEyNzU=",
    "number": 293,
    "title": "noexcept перегрузга",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:47:54Z",
    "updated_at": "2021-03-30T08:48:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -5\r\n_Автор идеи:_ **Андрей Марцинкевич**\r\n\r\nСуть, что бы можно было писать разные варианты одной и той-же функции (одна выбрасывает исключение, другая нет)\r\n\r\nИбо сейчас приходиться либо мучаться с шаблонами, либо использовать разные имена.\r\n\r\nПример:\r\n```cpp\r\nstd::unique_ptr<CustomFile> openFile(const std::string& filename)\r\n{\r\n  if (!FileManager.isFileExist())\r\n  {\r\n    throw NoFileExistException();\r\n  }\r\n}\r\n\r\nstd::unique_ptr<CustomFile> openFile(const std::string& filename) noexcept\r\n{\r\n  if (!FileManager.isFileExist())\r\n  {\r\n    return nullptr;\r\n  }\r\n}\r\n\r\n//вызов\r\n \r\nauto file_with_except = openFile(\"SomeFile.txt\"); //Exception\r\nauto file_no_except   = (std::no_throw) openFile(); // file_no_except == nullptr\r\n```\r\n \r\n\r\nВместо std::no_throw и noexcept может быть что-нибудь другое",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/293/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/293/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/292",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/292/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/292/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/292/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/292",
    "id": 844238481,
    "node_id": "MDU6SXNzdWU4NDQyMzg0ODE=",
    "number": 292,
    "title": "Стандартизировать поведение маленьких числовых типов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:45:05Z",
    "updated_at": "2021-03-30T08:45:25Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -1\r\n_Автор идеи:_ **Тигран Салуев**\r\n\r\nВ C++ есть целый ряд (обычно) восьмибитных интов: int8_t, int_least8_t, uint8_t, uint_least8_t. Сейчас они являются синонимами для char, но у char есть довольно непредсказуемое поведение: при печати в ostream он печатается как символ, без конвертации в десятичную систему. В итоге попытки напечатать маленькое целое заканчиваются неожиданным выводом непечатных символов. Возможно, есть ещё аналогичные проблемные моменты. Нужно сделать так, чтобы все инты вели себя как инты, при любых обстоятельствах.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/292/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/292/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/291",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/291/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/291/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/291/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/291",
    "id": 844231683,
    "node_id": "MDU6SXNzdWU4NDQyMzE2ODM=",
    "number": 291,
    "title": "Возможность явно указать квалификатор метода в момент вызова.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T08:37:46Z",
    "updated_at": "2021-03-30T08:44:08Z",
    "closed_at": "2021-03-30T08:44:07Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -4\r\n_Автор идеи:_ **A**\r\n\r\nНе редко декларация класса содержит одноименные методы с одинаковой сигнатурой, но с разными квалификаторами. При этом реализация const методов, обычно, является более легковесной. Решение - дублировать вызов константных методов с помощью неконстантных (например, begin () const и end () const дублировать сbegin () const и сend () const) - не выглядит красивым.\r\n\r\nВероятно, лучшим вариантом была бы возможность явно указать квалификатор вызываемого метода.\r\n```cpp\r\nstruct A\r\n{\r\n    void method ();\r\n    void method () const;\r\n};\r\n\r\nvoid foo ()\r\n{\r\n    A value;\r\n\r\n    // использовать\r\n    value.const method();\r\n\r\n    // вместо\r\n    const A & alias;\r\n    alias.method();\r\n\r\n    // или вместо\r\n    alias.сmethod();\r\n}\r\n```\r\nВыше преставлен упрощенный пример. Например, если использовать доступ к методам через элементы контейнера или умный указатель, или пользовательский тип, реализующий оператор ->, то можно было бы писать так:\r\n```cpp\r\n::std::shared_ptr< A > pointer = ::std::make_shared< A >();\r\npointer->const method();\r\n```\r\nПодобная семантика похожа, например, на явное указание template при вызове шаблонного метода\r\n```cpp\r\nstruct A\r\n{\r\n    template < typename _Type >\r\n    void method ();\r\n}\r\n\r\ntemplate < typename _T >\r\nvoid foo ()\r\n{\r\n    A value;\r\n    value.template method< _T >();\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/291/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/291/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/290",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/290/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/290/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/290/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/290",
    "id": 844230211,
    "node_id": "MDU6SXNzdWU4NDQyMzAyMTE=",
    "number": 290,
    "title": "std::string_view + c_str()",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:36:04Z",
    "updated_at": "2021-03-30T08:36:37Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -8\r\n_Автор идеи:_ **edc0a91c24342ae88891**\r\n\r\nДобавить метод по типу at(), только c_str(), который будет в рантайме проверять - является ли строка в string_view си-строкой и возвращать data(), либо - выкидывать эксепшн. Так же, можно реализовать is_cstr() - это позволит сделать проверку без исключений.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/290/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/290/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/289",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/289/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/289/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/289/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/289",
    "id": 844227626,
    "node_id": "MDU6SXNzdWU4NDQyMjc2MjY=",
    "number": 289,
    "title": "int128 на C++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:33:04Z",
    "updated_at": "2021-03-30T08:35:29Z",
    "closed_at": "2021-03-30T08:35:17Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +18, -0\r\n_Автор идеи:_ **sergeyyankovich2@tut.by**\r\n\r\nЯ считаю, что int128 точно должен быть в C++. Так же как и возможность реализовать деление 128-битного на 64-битное целое,\r\nс помощью одной div команды процессора (после компиляции),\r\nи умножение двух 64-битных с получением 128-битного целого, с помощью одной mul команды процессора (после компиляции).\r\n\r\nЕсли компилятор не поддерживает то, что поддерживает процессор - это огромный пробел компилятора.\r\n\r\nНе раз сталкивался с подобным мнением.\r\n\r\nРеализация на уровне компилятор не должна быть сложнее реализации __int64,  для  32-битных систем, которая существует уже давно.\r\n\r\nПреимущества -\r\n\r\nЛюбая длинная арифметка, всякие задачи факторизации и другие,  будут работать на порядок быстрее, если\r\nиспользовать один mul-div , вместо \"простыни иструкций процессора\", либо разбиении длинных целых на меньшие \"порции\" по int32. Причём разница (соотношение производительностей), с увеличением длины используемых чисел -\r\nрастёт с экспоненциальной зависимостью.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/289/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/289/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/288",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/288/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/288/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/288/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/288",
    "id": 844223424,
    "node_id": "MDU6SXNzdWU4NDQyMjM0MjQ=",
    "number": 288,
    "title": "Полноценный билдер/конфигуратор объектов.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:28:15Z",
    "updated_at": "2021-03-30T08:32:14Z",
    "closed_at": "2021-03-30T08:32:08Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -4\r\n_Автор идеи:_ **edc0a91c24342ae88891**\r\n\r\nВ си структура - это просто набор филдов, и в этом контексте он является полноценным билдером объектов. В  С++ это не так, и designated initializer мало полезен.\r\n\r\n \r\n\r\n \r\n\r\nСоответственно - предложение. Определить в рамках type{} внутри {} некое подобие блока конструктора, только ограниченного.\r\n\r\n \r\n\r\nРаботает в том случае, если определены конструкторы. Конструктор вызывается базовый, либо - можно вызвать нужный\r\n```cpp\r\nstruct type {\r\n\r\n  type() {/**/}\r\n\r\n  type(int a, int b): a(a), b(b) {}\r\n\r\n  void f(int) {}\r\n\r\n  int a, b;\r\n\r\n};\r\n\r\ntype{} //базовый, если он есть\r\n\r\ntype{.type(1, 2)}//вызов нужного.\r\n\r\n//альтернатива, дефолтная\r\n\r\ntype{1, 2}\r\n\r\n//дефолтный контекст - *this после вызова конструктора. .field == (*this).field\r\n\r\ntype{.a = 1}//вызов дефолтного конструктора, инициализация поля a\r\n\r\ntype{1, 2, .a = 3}//вызов type(int, int), инициализация филда a\r\n\r\n\r\ntype{.f(10)}//возможно вызывать функции.\r\n\r\ntype{.a = calc(this)}// доступен this\r\n\r\n//альтернатива\r\n\r\ntype{.a = calc(.this)}// доступен this\r\n\r\n//филды доступны свободно\r\n\r\ntype{.a = .b}\r\n\r\ntype{.a = this->b}\r\n```\r\n \r\n\r\nКейсы бесконечны, самое базовое и нужное:\r\n\r\n```cpp\r\nstd::vector{10, .reserve(.size())}\r\n\r\nstruct options {\r\n\r\n  options(): opt0(false), opt1(true), opt2(false) {}//defaults\r\n\r\n  bool opt0, opt1, opt2;\r\n\r\n};//в современном С++ можно инициализировать поля иначе, выкинув конструктор, но, вроде как, это работает только для standard layout\r\n\r\noptions{.opt0 = true}//defaults + opt0 == true\r\n```\r\n\r\nТак же, желательно, чтобы это всё работало в контекстах type name{}, type name = {};\r\n\r\n \r\n\r\nВсё это нам даёт возможность не только создать объект, но и сконфигурировать её + получить более мощную инициализацию.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/288/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/288/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/287",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/287/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/287/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/287/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/287",
    "id": 844220295,
    "node_id": "MDU6SXNzdWU4NDQyMjAyOTU=",
    "number": 287,
    "title": "ключевое слово \"base\" для для доступа к членам базового класса",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T08:24:50Z",
    "updated_at": "2021-04-02T15:28:26Z",
    "closed_at": "2021-04-02T15:28:17Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -9\r\n_Автор идеи:_ **Андрей Уланов**\r\n\r\nВ языках Java и C# есть ключевое слово \"base\" для доступа к членам базового класса.  В C++ этому мешает множественное наследование. Тем не менее задача актуальна, так как:\r\n1) позволяет сделать код лаконичнее\r\n2) избавляет от следующих ошибок:\r\n\r\nпусть D изначально наследовался от B\r\n```cpp\r\nclass B {\r\nvirtual void show();\r\n}\r\n\r\nclass D : public B {\r\nvoid show() {\r\n  B::show();\r\n}\r\n};\r\n```\r\n \r\n\r\nзатем в процессе разработки был добавлен следующий класс\r\n```cpp\r\nclass B2 : public B {\r\nvirtual void show() {\r\n  B::show();\r\n}\r\n};\r\n```\r\nи класс D стал наследоваться от B2\r\n```cpp\r\nclass D : public B2 {\r\nvoid show() {\r\n  B::show();\r\n}\r\n};\r\n```\r\nно при этом в методе D::show() разработчик может забыть заменить B::show() на B2::show(), чего не было бы, если бы можно было бы написать base::show();\r\n\r\nПредлагаю дополнить возможность использования ключевого слова base в случае, если класс имеет только одного предка. в случае множественного наследования - выдавать ошибку о невозможности использовать base",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/287/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/287/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/286",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/286/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/286/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/286/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/286",
    "id": 844214460,
    "node_id": "MDU6SXNzdWU4NDQyMTQ0NjA=",
    "number": 286,
    "title": "The default std::terminate_handler прерывает текущий поток, а не весь процесс",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-30T08:18:13Z",
    "updated_at": "2021-03-30T08:23:12Z",
    "closed_at": "2021-03-30T08:23:07Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -2\r\n_Автор идеи:_ **Виктор Губин**\r\n\r\nПердолжение очень простое.\r\n\r\nstd::terminate_handler по умолчанию должен прерывать только текущий поток (SIGSTOP), а не вызывать std::abort (SIGABRT).\r\n\r\nТаким образом, для одно-поточной логики поведение прораммы не изменится, аварийная остановка единственного потока ведет к аварийной остановке всего процесса.\r\n\r\nОднако в случае много-поточного приложения, например web сервера, обращение к std::terminate например: по выбросу исключения std::bad_alloc при нехватке памяти, или std::ios_base::failure при отказе HD диска, не приведет к краху всех потоков процесса, в том числе и тех которые могут завершится нормально. \r\n\r\nПодобная модель используется в Java.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/286/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/286/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/285",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/285/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/285/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/285/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/285",
    "id": 844213447,
    "node_id": "MDU6SXNzdWU4NDQyMTM0NDc=",
    "number": 285,
    "title": "стандартизировать математические константы, типа M_PI",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:16:59Z",
    "updated_at": "2021-04-06T19:11:31Z",
    "closed_at": "2021-03-30T08:17:18Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +24, -0\r\n_Автор идеи:_ **Константин Ивлев**\r\n\r\nстандартизировать распространенные математические константы типа M_PI\r\n\r\nде-факто уже поддерживаются основными компиляторами\r\n\r\nhttps://msdn.microsoft.com/en-us/library/4hwaceh6.aspx?f=255&MSPPError=-2147217396\r\n\r\nhttps://www.gnu.org/software/libc/manual/html_node/Mathematical-Constants.html\r\n\r\nхотя требуют дополнительных макросов для использования в зависимости от компилятора (_USE_MATH_DEFINES, _GNU_SOURCE, _XOPEN_SOURCE)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/285/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/285/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/284",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/284/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/284/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/284/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/284",
    "id": 844212048,
    "node_id": "MDU6SXNzdWU4NDQyMTIwNDg=",
    "number": 284,
    "title": "добавить котангенс",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:15:22Z",
    "updated_at": "2021-03-30T08:16:22Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Константин Ивлев**\r\n\r\nтангенс std::tan уже есть в стандартной библиотеке, но отсутсвует котангенс. приходится писать его через тангенс или синус/косинус",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/284/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/284/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/283",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/283/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/283/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/283/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/283",
    "id": 844211108,
    "node_id": "MDU6SXNzdWU4NDQyMTExMDg=",
    "number": 283,
    "title": "стандартизировать #pragma once",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:14:18Z",
    "updated_at": "2021-04-06T19:14:30Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +20, -4\r\n_Автор идеи:_ **Константин Ивлев**\r\n\r\nстандартизировать #pragma once (например, как просто #once), проблем возникнуть не должно, так так основные компиляторы (MSVC, GCC, Clang) уже поддерживают #pragma once",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/283/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/283/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/282",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/282/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/282/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/282/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/282",
    "id": 844209943,
    "node_id": "MDU6SXNzdWU4NDQyMDk5NDM=",
    "number": 282,
    "title": "Правильный constexpr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-30T08:12:56Z",
    "updated_at": "2022-01-27T06:43:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -1\r\n_Автор идеи:_ **edc0a91c24342ae88891**\r\n\r\nconstexpr - не как константа времени компиляции, а как константа времени исполнения. Либо, снять ограничения с constexpr.\r\n\r\nС constexpr существует проблема, которая постоянно мешает. Выражается она в том, что constexpr - есть просто константное выражение времени компиляции. \r\n\r\n\r\nПредлагаю ввести новое понятие, либо изменить старое. constexpr - есть не КОНСТАНТНОЕ выражение, а просто выражение уровня компиляции, которое относительно рантайма является константой, и только относительно него.\r\n\r\n \r\n\r\nПример. constexpr auto a = 10; a = 20; - это должно работать, а в рантайм \"a\" должна попадать как константа со значением 20. Думаю, не нужно разъяснять разницу между константной и не константой.\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\nПохожее поведение существует в constexpr-функциях, но это не выглядит как решения. Выглядит как костыль. Т.е. как constexpr мы можем получить только возвращаемое значение, а самое тело, даже в рамках вызова в constexpr-контексте - не является constexpr, ведь constexpr-функция может вызываться не только в constexpr-контексте.\r\n\r\n \r\n\r\n \r\n\r\n \r\n```cpp\r\nconstexpr void f() {\r\n\r\n  int a;// a не является constexpr, даже если функция вызывается в constexpr-контексте.\r\n\r\n  t<a> // -- не сработает\r\n\r\n}\r\n```\r\n \r\n\r\nТут, вроде как, нет особых технических сложностей относительно текущего решения, но - это решит множество проблем. Применений очень много. Начиная от обходов таппла через for на счётчиках, заканчивая компилтайм-счётчиками.\r\n\r\n \r\n\r\n \r\n\r\nЧастичное решение - сделать (full)constexpr-фуннкции. Т.е. раз контекст не влияет на семантику функции, то нужно просто запретить её вызовы вне constexpr-контекста.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/282/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/282/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/281",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/281/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/281/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/281/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/281",
    "id": 844208248,
    "node_id": "MDU6SXNzdWU4NDQyMDgyNDg=",
    "number": 281,
    "title": "новый кеуворд self для лямбд",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-30T08:10:57Z",
    "updated_at": "2022-08-12T05:54:37Z",
    "closed_at": "2022-08-12T05:54:37Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -14\r\n_Автор идеи:_ **dreverser**\r\n\r\nБезумная идея сократить конструкцию [self=shared_from_this()] к простому [self] в случае когда клас унаследован от enable_shared_from_this\r\n\r\nИ self == this если не унаследован, но self используется.\r\n\r\nСогласен, легко укладывается под define self, а вдруг моя идея найдет поддержку другими учасниками",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/281/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/281/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/280",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/280/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/280/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/280/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/280",
    "id": 843734098,
    "node_id": "MDU6SXNzdWU4NDM3MzQwOTg=",
    "number": 280,
    "title": "Шаблонный CV-квалификатор",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T19:38:49Z",
    "updated_at": "2021-03-30T06:27:24Z",
    "closed_at": "2021-03-30T06:27:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -2\r\n_Автор идеи:_ **xjossy**\r\n\r\nФормулировка проблемы\r\n\r\nСейчас приходится дублировать код при наличии const и не-const версии одного метода в классе. Типичный пример - геттер:\r\n```cpp\r\nclass T;\r\n\r\nclass A {\r\npublic:\r\n  T& getT() {\r\n    return t;\r\n  }\r\n\r\n  const T& getT() const {\r\n    return t;\r\n  }\r\n\r\nprivate:\r\n  T t;\r\n};\r\n```\r\nЕсли логика этой функции более сложна, то возникает нежелательное дублирование кода. Элегантного метода решения на данный момент не существует. Скотт Мейерс рекомендует использовать const_cast, что не способствует читаемости и надёжности кода. В современном Стандарте его подход реализуется так:\r\n```cpp\r\nclass T;\r\n\r\nclass A {\r\npublic:\r\n  T& getT() {\r\n    //something complicated\r\n  }\r\n\r\n  const T& getT() const {\r\n    return const_cast<T&>(std::as_const(*this).getT());\r\n  }\r\n\r\nprivate:\r\n  T t;\r\n};\r\n```\r\nТакже возможно решение с шаблонной функцией, которая обязана быть статической (чтобы избежать необходимости указания квалификатора). Она также может быть настроена на нежелательные типы (если это специально не исключено). Но даже этот пример не решает проблемы дублирования сигнатуры функции:\r\n```cpp\r\nclass T;\r\n\r\nclass A {\r\n  template<class ARef>\r\n  static auto& getTImpl(ARef* pthis) {\r\n    //something compicated\r\n  }\r\npublic:\r\n  T& getT() {\r\n    return getTImpl(this);\r\n  }\r\n\r\n  const T& getT() const {\r\n    return getTImpl(this);\r\n  }\r\n\r\nprivate:\r\n  T t;\r\n};\r\n```\r\nПредлагаемое решение\r\n\r\nДобавить новый тип неклассовых параметров шаблона - qualifier, который может применяться к функции. Пример кода:\r\n```cpp\r\nclass T;\r\n\r\nclass A {\r\npublic:\r\n  template<qualifier cv>\r\n  cv<T>& getT() cv {\r\n    //something compicated\r\n  }\r\n\r\nprivate:\r\n  T t;\r\n};\r\n```\r\nЭто полностью решит проблему.\r\n\r\nМинусы этого решения:\r\n\r\n1. Необходимо ввести новое ключевое слово qualifier, причём глобальное, так как в этом контексте может появится любое имя скалярного типа. В качестве решения проблемы можно создать enum-тип std::qualifier, наделённый дополнительными возможностями:\r\n* его значение (как шаблонного параметра) может выводиться из квалификатора this\r\n* он может применяться к типу, наделяя его соотв. квалификаторами. Это может быть сделано без вмешательства в core: std::apply_qualifier<cv, T> (вместо cv<T> в примере)\r\n* constexpr значение типа std::qualifier может применяться к функциям наравне с const-volatile квалификаторами.\r\n\r\nТакое решение позволит обойтись без дополнительных ключевых слов.\r\n\r\n2. Необходимо проработать использования volatile-квалификатора, так как пример выше подразумевает наличие volatile и const volatile специализации. Не ясно, нужны ли они. В качестве решения предлагается возможность ограничивать квалификатор только одним введением дополнительных типов: std::const_qualifier, std::volatile_qualifier.\r\n\r\n3. Необходимо убедиться в том, что добавление идентификатора на местро квалификатора не вызовет синтаксических неоднозначностей.\r\n\r\nС учётом всех этих замечаний, решение могло бы быть таким:\r\n```cpp\r\nclass T;\r\n\r\nclass A {\r\npublic:\r\n  template<std::const_qualifier cv>\r\n  std::apply_qualifier<cv, T&> getT() cv {\r\n    //std::apply_qualifier<cv, T&> в возвращаемом типе обычно можно заменить на auto\r\n    //something compicated\r\n  }\r\n\r\nprivate:\r\n  T t;\r\n};\r\n```\r\nЗаметка о реализации\r\n\r\nНаиболее существенной проблемой в реализации будет скорее всего вывод значения квалификатора, как шаблонного параметра. Это можно разрешить, так как thiscall функция содержит неявный параметр this, из типа которого могут быть выведены квалификаторы (даже в рамках современного Стандарта).\r\n\r\nДопольнительная мотивация - ещё один пример применения\r\n\r\nРассмотрим class SerializableScheme, который позволяет сериалиовывать и десериализовывать некоторое количество данных. Этот класс может использовать указатели, чтобы сразу помещать данные в нужное место. Его интерфейс может быть таким:\r\n```cpp\r\nclass SerializableScheme {\r\npublic:\r\n  template<class T>\r\n  void addData(T& data);\r\n\r\n  std::string save() const;\r\n  void load(const std::string& saved);\r\n};\r\n```\r\nЕго использование может быть таким:\r\n```cpp\r\nclass A {\r\npublic:\r\n  SerializableScheme getScheme() {\r\n    SerializableScheme res;\r\n\r\n    res.addData(a);\r\n    res.addData(b);\r\n    res.addData(c);\r\n\r\n    return res;\r\n  }\r\n\r\nprivate:\r\n  int a, b, c;\r\n};\r\n\r\n//использование:\r\nA a;\r\n\r\n//сохранение:\r\nstd::ofstream(\"a.txt\") << a.getScheme().save();\r\n\r\n//загрузка\r\nstd::string saved;\r\nstd::ifstream(\"a.txt\") >> saved;\r\na.getScheme().load(saved);\r\n```\r\nПроблема в том, что с помощью такого сериализатора не получится сохранить констанстный объект A.\r\n\r\nРешение - сделать getScheme() константным методом не сработает, т. к. для объект, полученный из констрантного объекта A не сможет реализовать метод load() (без применения const_cast).\r\n\r\nОстаётся только такое решение:\r\n```cpp\r\nclass A {\r\npublic:\r\n  SerializableScheme getScheme() {\r\n    SerializableScheme res;\r\n\r\n    res.addData(a);\r\n    res.addData(b);\r\n    res.addData(c);\r\n\r\n    return res;\r\n  }\r\n\r\n  ConstSerializableScheme getScheme() const {\r\n    ConstSerializableScheme res;\r\n\r\n    res.addData(a);\r\n    res.addData(b);\r\n    res.addData(c);\r\n\r\n    return res;\r\n  }\r\n\r\nprivate:\r\n  int a, b, c;\r\n};\r\n```\r\nЕсли объект A сложнее, то дублирование кода будет более существенным.\r\n\r\nС введением параметра квалификатора решение было бы таким:\r\n```cpp\r\ntemplate<std::const_qualifier cv>\r\nusing SerializableSchemeT = ...; // SerializableScheme для пустого cv, ConstSerializableScheme для константного cv\r\n\r\nclass A {\r\npublic:\r\n  template<std::const_qualifier cv>\r\n  SerializableSchemeT<cv> getScheme() cv {\r\n    SerializableSchemeT<cv> res;\r\n\r\n    res.addData(a);\r\n    res.addData(b);\r\n    res.addData(c);\r\n\r\n    return res;\r\n  }\r\n\r\nprivate:\r\n  int a, b, c;\r\n};\r\n```\r\n\r\nСпасибо всем, кто дочитал до конца, надеюсь, идея понравилась",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/280/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/280/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/279",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/279/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/279/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/279/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/279",
    "id": 843728199,
    "node_id": "MDU6SXNzdWU4NDM3MjgxOTk=",
    "number": 279,
    "title": "Требуется простой и прозрачный механизм рекурсивного вызова лямбда-функций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T19:33:07Z",
    "updated_at": "2022-08-12T06:03:30Z",
    "closed_at": "2022-08-12T06:03:11Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -0\r\n_Автор идеи:_ **Vyacheslav Meshkov**\r\n\r\nВ обычной функции можно без лишних усилий написать рекурсивный вызов void `f() { f(); }`, чего не скажешь о лямбдах, хотя по сути то ничто мешать не должно. В функциональных языка программирования такой проблемы же нет.\r\n\r\n`[...](...){ how_to_call_self_?(...); }`\r\n\r\nКак некий компромисный вариант можно предложить auto `func = [](){ func(); }`. Сейчас так нельзя. Но я уверен, что можно придумать лучше.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/279/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/279/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/278",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/278/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/278/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/278/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/278",
    "id": 843726613,
    "node_id": "MDU6SXNzdWU4NDM3MjY2MTM=",
    "number": 278,
    "title": "Контракты для корутин",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T19:31:29Z",
    "updated_at": "2021-03-30T06:28:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **Олег Власов**\r\n\r\nХочется что бы можно было использовать контракты в корутинах. Также как с функциями:\r\n```cpp\r\ntask<> tcp_echo_server(socket socket)\r\n[[expects: socket.is_open()]]\r\n {\r\n  char data[1024];\r\n  for (;;) {\r\n    size_t n = co_await socket.async_read_some(buffer(data));\r\n    co_await async_write(socket, buffer(data, n));\r\n  }\r\n}\r\n```\r\nПотому что, это даст возможность сообщать разработчику об ограничения работы с данной корутиной. И позволит компилятору оптимизорать работу с ней.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/278/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/278/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/277",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/277/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/277/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/277/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/277",
    "id": 843725608,
    "node_id": "MDU6SXNzdWU4NDM3MjU2MDg=",
    "number": 277,
    "title": "Инициализация массивов и контейнеров лямбдой (compile-time)",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      },
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T19:30:26Z",
    "updated_at": "2021-04-02T06:29:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -4\r\n_Автор идеи:_ **Denis**\r\n\r\nВ C++17 мы уже можем инициализировать массив не тривиальным образом во время компиляции, но для этого нам нужно писать constexpr функцию, например:\r\n```cpp\r\n#include <array>\r\n\r\nconstexpr std::array<int, 9> init() {\r\n    std::array<int, 9> arr {};\r\n\r\n    for(int i = 0; i < arr.size(); i++) {\r\n        arr[i] = i * i;\r\n    }\r\n\r\n    return arr;\r\n} \r\n\r\nint main() {\r\n\r\n    std::array<int, 9> arr = init();\r\n\r\n    return arr[3];\r\n}\r\n```\r\nКак вариант, можно было бы использовать подобный синтаксис (как будто встроенный std::generate):\r\n```cpp\r\n#include <array>\r\n\r\nint main() {\r\n\r\n    std::array<int, 9> arr{(v.begin(), v.end(), [n = 0] () mutable { return n++; })};\r\n\r\n    return arr[3];\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/277/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/277/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/276",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/276/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/276/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/276/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/276",
    "id": 843724359,
    "node_id": "MDU6SXNzdWU4NDM3MjQzNTk=",
    "number": 276,
    "title": "Раскрытие кортежей",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T19:29:08Z",
    "updated_at": "2021-03-30T06:31:00Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -1\r\n_Автор идеи:_ **_NN_**\r\n\r\nВместо неуклюжего `std::apply`:\r\n```cpp\r\nvoid f(int a, char c) {}\r\n\r\nauto t = make_tuple(1, 'a');\r\nstd::apply(f, t);\r\n```\r\nБыло бы полезно иметь синтаксис для распаковки, например:\r\n```cpp\r\nvoid f(int a, char c) {}\r\n\r\nauto t = make_tuple(1, 'a');\r\nf(...t);\r\n```\r\nОпределение: (синтаксис не окончательный)\r\n\r\nКод вида \"...a\" заменяется компилятором в:\r\n```cpp\r\nstd::get<0>(a), std::get<1>(a), ... std::get<std::tuple_size<decltype(a)>::value>(a)\r\n```\r\nТаким образом отпадает необходимость в std::apply, а также во вспомогательных функциях при передачи переменных параметров.\r\n\r\nВ данном примере вызывается функция g для каждого аргумента переданного в f, а сама g вызывается с различным набором параметров.\r\n```cpp\r\ntemplate<typename T>\r\nvoid g(T const&... t);\r\n\r\ntemplate<typename Tuple>\r\nvoid f(Tuple const&... t)\r\n{\r\n  (g(...t), ...);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/276/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/276/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/275",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/275/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/275/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/275/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/275",
    "id": 843722940,
    "node_id": "MDU6SXNzdWU4NDM3MjI5NDA=",
    "number": 275,
    "title": "Emplace iterators",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T19:27:31Z",
    "updated_at": "2021-03-29T19:28:03Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **Nate Reinar Windwood**\r\n\r\n```cpp\r\nstd::emplacer() -> std::emplace_iterator\r\nstd::back_emplacer() -> std::back_emplace_iterator\r\nstd::front_emplacer() -> std::front_emplace_iterator\r\n```\r\n\r\nПример реализации: [back_emplacer](https://stackoverflow.com/questions/18724999/why-no-emplacement-iterators-in-c11-or-c14/18726119#18726119).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/275/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/275/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/274",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/274/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/274/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/274/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/274",
    "id": 843721116,
    "node_id": "MDU6SXNzdWU4NDM3MjExMTY=",
    "number": 274,
    "title": "Добавление в стандарт возможности расширения типов",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T19:25:34Z",
    "updated_at": "2021-03-30T06:33:24Z",
    "closed_at": "2021-03-30T06:33:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -10\r\n_Автор идеи:_ **Darkpaladin2000**\r\n\r\nНемного кода:\r\n```cpp\r\nclass SomeClass {\r\n    int _a, int _b;\r\n};\r\n\r\nextension SomeClass {\r\npublic:\r\n    int sumOfFields() {\r\n        return _a + _b;\r\n    }\r\n};\r\n\r\n//main\r\nSomeClass object;\r\nauto res = object.sumOfFields();\r\n```\r\nРасширения позволят добавлять функциональность в классы стандартной библиотеки без наследования.\r\n\r\nНо будут ограничения на изменение существующей функциональности:\r\n1. Нельзя менять реализацию существующих методов и операторов\r\n2. Расширение не имеет своих конструкторов и деструктора, следовательно не имеет своих свойств.\r\n3. Из расширяемого класса нельзя вызывать методы расширения\r\n\r\nРасширения (extensions) используются в Swift.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/274/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/274/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/273",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/273/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/273/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/273/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/273",
    "id": 843719914,
    "node_id": "MDU6SXNzdWU4NDM3MTk5MTQ=",
    "number": 273,
    "title": "Гарантировать размер объекта в агрегации",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T19:24:20Z",
    "updated_at": "2021-03-30T06:37:51Z",
    "closed_at": "2021-03-29T19:24:36Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -2\r\n_Автор идеи:_ **_NN_**\r\n\r\nДопустим мы имеем простую обёртку над указателем.\r\n```cpp\r\ntemplate<typename T>\r\nstruct ptr\r\n{\r\n T* p;\r\n};\r\n```\r\nКомпилятор вправе добавить выравнивание по его усмотрению\r\n```cpp\r\ntemplate<typename T>\r\nstruct ptr\r\n{\r\n T* p;\r\n // padding\r\n};\r\n```\r\nВ случае использования этого типа в класса, компилятор вправе добавить выравнивание также и самого класса:\r\n```cpp\r\nclass X\r\n{\r\n ptr<int> p; \r\n // внутреннее выравнивание ptr<int>\r\n // выравнивание для поля p\r\n};\r\n```\r\nПолучатся, что использование указателя меньше влияет на размер класса чем использование обёртки вокруг него.\r\n\r\n\r\nПредложение:\r\n\r\nАтрибут указывающий не добавлять лишнего выравнивания для таких классов таким образом гарантирующей легковестность любой обёртки то бишь array, unique_ptr и т.п.\r\n```cpp\r\ntemplate<typename T>\r\nstruct ptr [[raw_size]]\r\n{\r\n T* p;\r\n // guaranteed no padding is added\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/273/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/273/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/272",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/272/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/272/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/272/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/272",
    "id": 843695592,
    "node_id": "MDU6SXNzdWU4NDM2OTU1OTI=",
    "number": 272,
    "title": "Интерполяция строк",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T18:57:19Z",
    "updated_at": "2021-03-30T06:40:48Z",
    "closed_at": "2021-03-30T06:40:48Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -13\r\n_Автор идеи:_ **Дмитрий Бравиков**\r\n\r\nВ C++ не хватает удобного типобезопасного способа подстановки переменных в шаблонную строку. Можно добавить интерполяцию строк, как в C#.\r\n\r\nПример кода:\r\n```cpp\r\nconst char* name = \"Bob\";\r\nint age = 32;\r\nstd::cout << $\"Hello. My name is {name}. I'm {age}.\" << std::endl;\r\n```\r\nВ стандартный вывод передается строка: `\"Hello. My name is Bob. I'm 32.\"`.\r\n\r\nСейчас символ доллара `$` не используется в языке.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/272/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/272/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/271",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/271/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/271/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/271/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/271",
    "id": 843694406,
    "node_id": "MDU6SXNzdWU4NDM2OTQ0MDY=",
    "number": 271,
    "title": "Альтернативное представление для операторa ==",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T18:56:01Z",
    "updated_at": "2021-03-29T18:56:20Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -13\r\n_Автор идеи:_ **Oleg Vorobiov**\r\n\r\nДобавить альтернативное представление для оператора ==, как это было сделано, например, для !=([not_eq](https://en.cppreference.com/w/cpp/keyword/not_eq)). На мой взгляд использование альтернативных операторов улучшает читаемость кода; например, сравните следующие блоки кода:\r\n\r\nС использованием альтернативных операторов:\r\n\r\nif (sender is NetworkNode::Bms and receiver is NetworkNode::Locker) { /* ... */ }\r\n\r\nИ без:\r\n\r\nif (sender == NetworkNode::Bms && receiver == NetworkNode::Locker) { /* ... */ }",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/271/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/271/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/270",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/270/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/270/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/270/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/270",
    "id": 843144447,
    "node_id": "MDU6SXNzdWU4NDMxNDQ0NDc=",
    "number": 270,
    "title": "unordered_map/set + capactity()",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T08:58:01Z",
    "updated_at": "2021-03-29T09:00:29Z",
    "closed_at": "2021-03-29T09:00:22Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -6\r\n_Автор идеи:_ **dreverser**\r\n\r\nХочется иметь возможность быстро получить размер используемой памяти у контейнера.\r\n\r\nОчень странно что у контейнеров есть столько ненужных на мой взгяд методов, которые никак не помогают вычислить объем аллоцируемой памяти.\r\n\r\nРазработчики парятся какими то вычислениями что бы узнать. \r\n\r\nhttps://stackoverflow.com/questions/25375202/how-to-measure-memory-usage-of-stdunordered-map\r\n\r\nИ все равно это будет не точно. Поскольку есть еще размер ноды.\r\n\r\nСамый точный способ выглядит уродски\r\n\r\nhttps://gist.github.com/yuyoyuppe/51e098c1adf64114d2b1\r\n\r\nВ string есть метод capacity а в контейнерах нет.\r\n\r\nНе знаю почему. Но хочется что бы появились.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/270/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/270/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/269",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/269/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/269/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/269/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/269",
    "id": 843142732,
    "node_id": "MDU6SXNzdWU4NDMxNDI3MzI=",
    "number": 269,
    "title": "Пропуск дефолтовых параметров в шаблонах и функциях",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:56:15Z",
    "updated_at": "2021-03-29T08:57:08Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -8\r\n_Автор идеи:_ **dreverser**\r\n\r\nИспользуя запятую пропускать указания аргументов если у них есть значения по умолчанию\r\n\r\nХочется иметь возможность не перечислять параметры шаблона контейнера что бы добраться до нужного.\r\n\r\nВ моем случае пример с аллокатором в unordered_map. К которому что бы добраться приходится пройтись по двум дефолтовым параметрам hash и equal, накладно.\r\n\r\nТак почему бы не дать возможность пропускать их  ?\r\n\r\nвместо\r\n```cpp\r\ntypedef std::unordered_map<int, EVO, std::hash, std::equal_to, \r\nAlloc_wrapped<std::pair<const int, EVO> >\r\n```\r\nпросто\r\n```cpp\r\ntypedef std::unordered_map<int, EVO,,, \r\nAlloc_wrapped<std::pair<const int, EVO> >\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/269/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/269/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/268",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/268/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/268/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/268/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/268",
    "id": 843140007,
    "node_id": "MDU6SXNzdWU4NDMxNDAwMDc=",
    "number": 268,
    "title": "Редизайн Networking TS",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-03-29T08:53:25Z",
    "updated_at": "2022-02-15T18:42:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +22, -0\r\n_Автор идеи:_ **dreverser**\r\n\r\nИз того что я смотрел предлагаемый в стандарт Networking TS это практически тот же самый asio из boost'a\r\n\r\nВот только в бусте он asio(асинхронный IO и для сериала, девайса, сети) а предлагаемый в стандарт он почему то весь превращается в Networking\r\n\r\nЭто не верный подход. Предложение в том что бы разбить его сущности на независимые части. И таким образом втянуть в стандарт по отдельности, пропозлами.\r\n\r\nОчень кратко по тому что я вижу из последнего Networking TS http://en.cppreference.com/w/cpp/experimental\r\n\r\n1)\r\n\r\n<buffer> вытянуть из пространства net/ и втянуть в стандарт отдельным независимым пропозлом, это всего лишь байтстримовый поток.\r\n\r\nВ который можно писать в конец, и читать сначала. Помоему не хватает только метода avalible() который скажет длинну от прочитанного до записаного (аналог из QT). Убрать из него все зависимости на реактор если они есть. Должна быть возможность использовать <buffer> как независимую от реактора сущность. Асинхронка если она сильно прибита к <buffer> нужно переместить в один из файлов реактора(io_context).\r\n\r\n2)\r\n\r\n<io_context> <executor> <timer> вытянуть из пространства net/ и втянуть в стандарт отдельным независимым пропозлом. Это асинхронный IO, он имеет отношение не только к нетворкингу, но и к IO девайсов. В него же добавиться возможность работать асинхронно с дескрипторами через <buffer>. Все зависимости на сокеты если они есть должны быть убранны из реактора.\r\n\r\n3)\r\n\r\n<socket> убирается жесткая зависимость на реактор (io_context) в конструкторе. А вся асинхронка переходит в отдельную сущность к примеру async_socket либо как то оборачивается в шаблон. <socket> <internet> остаются в пространстве net. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/268/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/268/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/267",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/267/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/267/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/267/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/267",
    "id": 843138232,
    "node_id": "MDU6SXNzdWU4NDMxMzgyMzI=",
    "number": 267,
    "title": "apply_permutation",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:51:32Z",
    "updated_at": "2021-03-29T11:55:32Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **zamazan4ik@tut.by** @ZaMaZaN4iK\r\n\r\nЧасто так бывает, что нужно переставить элементы в определённом порядке (не в случайно, так что std::shuffle не подходит). Для этих целей и предлагается функция std::apply_permutation",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/267/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/267/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/266",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/266/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/266/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/266/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/266",
    "id": 843136024,
    "node_id": "MDU6SXNzdWU4NDMxMzYwMjQ=",
    "number": 266,
    "title": "Параллельный for.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      },
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T08:49:12Z",
    "updated_at": "2021-03-29T08:50:55Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -10\r\n_Автор идеи:_ **pavelkolodin**\r\n\r\n\r\nЕсть 3 контейнера: a, b, c. Хочу запустить 1 range-цикл по ним всем одновременно:\r\n```cpp\r\nfor( auto i1 : a, auto i2 : b, auto i3 : c) {\r\n    \r\n}\r\n```\r\n\r\nНа каждой итерации i1, i2, i3 имеет очередное значение из соответствующего контейнера.\r\nЦикл помирает как только исчерпается самый мелкий контейнер.\r\n\r\nПример:\r\n```cpp\r\nstd::vector<int> a = {1, 2, 3};\r\nstd::vector<std::string> b = {\"hello\", \"world\", \"foo\", \"bar\"};\r\nstd::vector<int> c = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\r\n\r\n// Loop will stop after 3 iterations, because 'a' have minumal size = 3.\r\nfor ( auto i1 : a, auto i2 : b, auto i3 : c ) {\r\n    std::cout << i1 << \", \" << i2 << \", \" << i3 << \"\\n\";\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n1, hello, 9\r\n2, world, 8\r\n3, foo, 7",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/266/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/266/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/265",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/265/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/265/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/265/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/265",
    "id": 843134381,
    "node_id": "MDU6SXNzdWU4NDMxMzQzODE=",
    "number": 265,
    "title": "Кроссплатформенный код без препроцессора",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:47:27Z",
    "updated_at": "2021-03-29T08:48:14Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -2\r\n_Автор идеи:_ **Иван Шипицин**\r\n\r\nСделать условную компиляцию силами самого компилятора, то есть заменить #if ... #endif на что-то вроде if constexpr static (...) { ... }\r\n\r\nСейчас для написания кросплатформенного кода используется препроцессор, так как он умеет выкидывать ненужный код, но работает он только с определениями препроцессора.  С другой стороны, для условной компиляции в C++17 добавили if constexpr, но компилятор все равно анализирует оба пути выполнения (что не подходит для написания кроссплатформеного кода). Я предлагаю объединить эти два способа, и создать что-то вроде if constexpr static (...) {...} (синтаксис подлежит обсуждению).\r\n\r\nЭта конструкция позволяет в качестве условия использовать любые компайл-тайм константы и игнорировать код под ложным условием.\r\n```cpp\r\nvoid InitDriver() {\r\n    if constexpr static (platform_name == \"windows\") { //platform_name - константа, определенная где-то в стандартной библиотеке\r\n        INITIALIZE_DRIVER(); //некая функция WinApi\r\n    } else if constexpr static (platform_name == \"linux\") {\r\n        init_drv(); // некий системный вызов линукса\r\n    } else {\r\n        static_assert(false,\"Unsupported OS\")\r\n    }\r\n}\r\n```\r\nВ данном примере, если бы код разбирался компилятором, даже если условие было ложным, то он бы не скомпилировался, жалуясь на функцию, не существующую в текущем окружении.\r\n\r\nВпрочем, некоторое количество кода, огражденного препроцессором, не может быть скомпилировано. Например, непарные фигурные скобки. В данном случае компилятору будет логично считать, что после первой закрывающей скобки тело if constexpr static заканчивается и дальнейший текст не будет игнорироваться компилятором. В таком случае, требуется каким-то способом экранировать фигурные скобки. Например, писать само условие возле каждой закрывающей/открывающей фигурной скобки. Код начинает выглядеть громоздко, поэтому необходимо обсуждение для улучшения синтаксиса.\r\n```cpp\r\nvoid InitDriver() {\r\n    if constexpr static (platform_name == \"windows\") { //Код для виндовса сломан, и должен игнорироваться, иначе вызовет ошибки компиляции\r\n        INITIALIZE_DRIVER();[; {\r\n        } ** //на этой строке компилятору следовало бы остановиться, но нам этого не надо\r\n        14 {] } \r\n        } @@ 554 $%(*\r\n        8)qwerty \r\n    } (platform_name == \"windows\") else if constexpr static (platform_name == \"linux\") {\r\n        init_drv(); \r\n    } (platform_name == \"linux\") else (platform_name == \"linux\") {\r\n        static_assert(false,\"Unsupported OS\")\r\n    } (platform_name == \"linux\")\r\n}\r\n```\r\nТакже, на код, находящийся в теле выражения, можно не создавать собственную область видимости (тем самым ещё больше приблизив эту конструкцию к дефайнам), что позволит создавать переменные, а затем использовать их даже в коде, находящемся вне конструкции условной компиляции.\r\n```cpp\r\nvoid InitDriver() {\r\n    if constexpr static (platform_name == \"windows\") {\r\n        HANDLER h = GetPreInitHandler(); //находится в области видимости функции\r\n    }\r\n    Init();\r\n    if constexpr static (platform_name == \"windows\") {\r\n        PostInitWindowsWorkaround(h);\r\n    }\r\n    std::cout<<h; // компилируется на windows, но ругается на непонятную переменную на остальных системах\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/265/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/265/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/264",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/264/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/264/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/264/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/264",
    "id": 843132967,
    "node_id": "MDU6SXNzdWU4NDMxMzI5Njc=",
    "number": 264,
    "title": "Unbounded integers",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-29T08:45:49Z",
    "updated_at": "2021-04-06T19:12:23Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +23, -0\r\n_Автор идеи:_ **zamazan4ik@tut.by** @ZaMaZaN4iK\r\n\r\nУже есть пропозал про wide_int: #84 . Но он про числа, размер которых нам известен на стадии компиляции.\r\n\r\n \r\n\r\nUnbounded integers могут расширяться в рантайме на столько, сколько позволяет нам ОС и способны вместить сколь угодно большие числа. Вот текст оригинального предложения: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4038.html\r\n\r\n \r\n\r\nК сожалению, автор (Pete Becker), судя по всему, забросил пропозал на произвол судьбы. Хотелось бы возродить это дело. Но с некоторыми поправками к нему:\r\n\r\n*    Выкинуть из предложения класс bits, так как это уже реализуется другим предложением: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0237r9.pdf . Вместо этого своего класса добавить просто в отдельном предложении взаимодействие с классами для работы с битами из бумаги выше.\r\n*    Переделать специализацию std::hash (сейчас делается по-другому)\r\n*    Вместо класса integer_data_proxy просто использовать вектор с возможностью выбора аллокатора\r\n*    Добавить ravlue версии к алгоритмам\r\n*    pow, sqrt, sqr и так далее выбросить из методов класса и сделать перегрузки как свободные функции. Также посмотреть, к каким математическим функциям нужны ещё перегрузки и описать всё это отдельной бумагой\r\n*    выбросить метод is_zero\r\n\r\n \r\n\r\nЕсть какие-то ещё идеи по улучшению?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/264/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/264/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/263",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/263/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/263/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/263/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/263",
    "id": 843130625,
    "node_id": "MDU6SXNzdWU4NDMxMzA2MjU=",
    "number": 263,
    "title": "std::stoul и прочие конвертеры строка -> число должны быть constexpr и должны принимать string_view",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:43:15Z",
    "updated_at": "2021-04-02T18:20:40Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Лягуха Пепе**\r\n\r\nВ данный момент эти конверсии кидают эксепшены при проблемах, в варианте constexpr-evaluation вероятно надо ограничиться какими-нибудь констэкспр-ассертами.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/263/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/263/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/262",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/262/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/262/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/262/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/262",
    "id": 843123530,
    "node_id": "MDU6SXNzdWU4NDMxMjM1MzA=",
    "number": 262,
    "title": "Type functions для зависимых типов.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-29T08:35:31Z",
    "updated_at": "2021-03-29T08:42:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -0\r\n_Автор идеи:_ **d-yaroshev**\r\n\r\nПри написании любого шаблонного кода, возникает необходимость писать одни и теже helpers:\r\n```cpp\r\ntemplate <typename C>\r\nusing Iterator = typename C::iterator;\r\n\r\ntemplate <typename I>\r\nusing ValueType = typename std::iterator_traits<I>::value_type;\r\n\r\ntemplate <typename I>\r\nusing Reference = typename std::iterator_traits<I>::reference;\r\n```\r\nОчень надоедает, особенно если есть несколько разных Concepts с которыми приходится работать (контейнеры, аллокаторы, указатели).\r\n\r\nХотелось бы иметь стандартное решение.\r\n\r\nС Concepts оно должно реализовываться достаточно просто. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/262/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/262/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/261",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/261/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/261/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/261/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/261",
    "id": 843121191,
    "node_id": "MDU6SXNzdWU4NDMxMjExOTE=",
    "number": 261,
    "title": "Реализация property",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:33:05Z",
    "updated_at": "2021-03-29T08:34:26Z",
    "closed_at": "2021-03-29T08:34:20Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -6\r\n_Автор идеи:_ **octaviarius**\r\n\r\nНе знаю, кому как, а мне очень нехватает наличия свойств в классах. Да, можно использовать геттеры и сеттеры, но это не очень удобно , громоздко и не очевидно.\r\n\r\nдля сравнения:\r\n```cpp\r\nclass CMyClass{\r\nprivate:\r\n int a;\r\n float b;\r\npublic:\r\n////\r\n \r\n int getA() {return a;}\r\n void setA(int value){a = value;}\r\n\r\n float getB() {return b;}\r\n void setB(float value){b = value;}\r\n};\r\n\r\nCMyClass c;\r\n\r\nvoid main(){\r\n\r\n int vInt = 45;\r\n float vFloat = 3.5;\r\n\r\n c.setA(vInt);\r\n c.setB(float(c.getA) * vFloat);\r\n\r\n vFloat = c.getB(); \r\n \r\n};\r\n```\r\n \r\n\r\nи вот это:\r\n```cpp\r\nclass CMyClass{\r\nprivate:\r\n int a;\r\n float b;\r\npublic:\r\n////\r\n \r\n property int A{\r\n  int get(){return a;}\r\n  void set(int value) {a = value;}\r\n }\r\n \r\n property float B{\r\n  float get() {return b;}\r\n  void set(float value){b = value;}\r\n }\r\n};\r\n\r\n\r\nCMyClass c;\r\n\r\nvoid main(){\r\n\r\n int vInt = 45;\r\n float vFloat = 3.5;\r\n\r\n //выглядит культурнее и ближе для восприятия\r\n c.A = vInt;\r\n c.B = float(c.A) * vFloat;\r\n\r\n vFloat = c.B; \r\n \r\n};\r\n```\r\n \r\n\r\nКонечно это простой пример, всё сложнее на деле, и длинные конструкции отлично бы заменились на более краткие и приятные глазу. По сути же свойство это та же переменная, только со расширением методики обращения к данным.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/261/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/261/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/260",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/260/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/260/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/260/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/260",
    "id": 843111403,
    "node_id": "MDU6SXNzdWU4NDMxMTE0MDM=",
    "number": 260,
    "title": "Хотелось бы иметь функцию, являющуюся аналогом функции String.join из Java, но в виде отдельной функции.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-29T08:22:25Z",
    "updated_at": "2022-02-19T10:47:49Z",
    "closed_at": "2022-02-19T10:47:49Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **gavvs1977**\r\n\r\nПорой возникает необходимость в следующем: в некотором контейнере, поддерживающем двунаправленные итераторы, содержатся строки типа std::basic_string, и хотелось бы склеить все эти строки в одну, но разделив склеиваемые строки заданным разделителем. \r\n\r\nИногда бывает необходимо следующее: в некотором контейнере, поддерживающем двунаправленные итераторы, содержатся строки типа std::basic_string, и хотелось бы склеить все эти строки в одну, но разделив склеиваемые строки заданным разделителем.\r\n\r\nНиже приведена возможная реализация:\r\n```cpp\r\ntemplate<typename BidirectionalIt,\r\n         typename CharT,\r\n         typename Traits    = std::char_traits<CharT>,\r\n         typename Allocator = std::allocator<CharT>>\r\nstd::basic_string<CharT, Traits, Allocator> join(BidirectionalIt first,\r\n                                                 BidirectionalIt last,\r\n                                                 const std::basic_string<CharT, Traits, Allocator>& separator)\r\n{\r\n    using str_type = std::basic_string<CharT, Traits, Allocator>;\r\n    str_type result;\r\n    if(first == last){\r\n        return result;\r\n    }\r\n    auto pre_last = --last;\r\n    if(first == pre_last){\r\n        return *first;\r\n    }\r\n    for(auto it = first; it != pre_last; ++it){\r\n        result += *it + separator;\r\n    }\r\n    result += *pre_last;\r\n    return result;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/260/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/260/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/259",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/259/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/259/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/259/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/259",
    "id": 843109865,
    "node_id": "MDU6SXNzdWU4NDMxMDk4NjU=",
    "number": 259,
    "title": "Ассемблерные функции.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:20:41Z",
    "updated_at": "2021-03-29T08:21:19Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -4\r\n_Автор идеи:_ **int33h-tm**\r\n\r\nДобавить в язык возможность написания чисто ассемблерных функций.\r\n\r\nВо многих современных компиляторах С++ есть очень нетривиальные, но все же возможности написания ассемблерных вставок. Но их поддержка на уровне компилятора, в некоторых случаях, оставляет желать лучшего...Но давайте не будем заострять внимание именно на ассемблерных вставках, а подумаем немножечко глобальнее...\r\nС++ наследник языка С, который являет собой язык процедурного программирования, следовательно объектом нашего рассмотрения должна стать функция(процедура)...\r\n\r\nИдея довольно проста. Нам нужно придумать вариант реализации функции с внутренним ассемблерным кодом, которая сможет встроиться в наш код с помощью компилятора.(В современном gcc, есть возможность вызова некоторых команд процессора напрямую с помощью специальных intrinsic-функций, которые говорят компилятору выполнить прямую подстановку, но эти средства крайне ограниченны)\r\nНедолгими размышлениями мы приходим к такому первоначальному ответу:\r\n```\r\nasm <retval> func([params]){\r\n    //только aссемблерный код\r\n}\r\n```\r\n\r\n(Ассемблерный код напрямую подставляется компилятором на место функции без всяких проверок. В случае вызова какой-либо функии, компилятор должен заменить ее вызов исходя из своей внутренней логики)\r\nНо тут надо вспомнить, что языки С/С++ являются кроссплатформенными, чем ассемблер не может похвастаться. Это надо чем-то компенсировать... И тут вспоминается, что в последних стандартах(C++14) в язык была добавлена возможность помечать некоторые функции словом [[deprecated]]. Раз мы можем теперь помечать функции, то почему бы не пометить нашу функцию, как функцию для определенной платформы...\r\n```cpp\r\n[[platform(x86)]]\r\nasm <retval> func([params]){\r\n    //ассемблерный код для платформы x86\r\n}\r\n```\r\nТаких функций мы можем реализовать огромное множество для самых разных платформ(главное, чтобы совпадала сигнатура). Также желательно добавить еще способ дополнительного описания флагов процессора, таких как SSE, AVX и других, для того, чтобы использовать более расширенный набор команд.\r\n\r\nТеперь встает вопрос, а как компилятору определить какую из них выбрать? Тут тоже можно дать ответ:\r\nПодбирается наиболее подходящая функция в следующем порядке:\r\n\r\n1)нужная платформа + флаги\r\nЕсли есть несколько доступных(все указанные флаги у этого процессора есть) реализаций под конкретную платформу, но с разным кол-вом флагов, то будет выбираться вариант с наибольшим кол-вом.\r\n\r\n2)общая реализация.(обычный С/С++ код)\r\nЕсли нет общей реализации, то сообщить об ошибке компиляции под требуемую платформу.\r\n\r\nГотово! Хотел бы я сказать, но ведь нужно еще подумать о передаче параметров...\r\n\r\nВ ассемблере параметры могут передаваться как через стек, так и через регисты => нужно научиться передавать параметры через регистры => Т.к. мы уже указали платформу до описания сигнатруры, то можем использовать следующую кострукцию:\r\n```cpp\r\n//функция inc (префиксный оператор ++)\r\n[[platform(x86), core_flags(...)]]\r\nasm int inc(register int ebx) //register <type> <reg_name>\r\n{\r\n    inc ebx\r\n    mov eax, ebx //по умолчанию возвращаемое значение кладется в регистр rax/eax/ax.\r\n    ret\r\n}\r\n\r\n...\r\n\r\nint main()\r\n{\r\n    int x = 0;\r\n    ...\r\n    inc(x);\r\n//equal to:\r\n//  mov ebx, &x\r\n//  call inc\r\n    ...\r\n}\r\n```\r\nВот теперь, наверно, все.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/259/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/259/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/258",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/258/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/258/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/258/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/258",
    "id": 843108480,
    "node_id": "MDU6SXNzdWU4NDMxMDg0ODA=",
    "number": 258,
    "title": "Переработать логику исключения std::ios_base::failure",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-29T08:19:04Z",
    "updated_at": "2021-03-29T08:19:04Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -1\r\n_Автор идеи:_ **pavel.darashkevich**\r\n\r\nВозвращать исходную ошибку в исключении. \r\nНе бросать исключение в коде, который корректен (код ниже), если не включать исключения. \r\nДобавить возвращение кода ошибки последним аргументом в функциях std::ifstream/std::ofstream и им подобным.\r\n\r\nПишем простую программу, которая считывает все числа из файла (файл состоит из чисел типа int, разделённых пробелами), после этого выводим сумму.\r\n\r\n \r\n```cpp\r\n#include <iostream>\r\n#include <vector>\r\n#include <fstream>\r\n#include <numeric>\r\n#include <iterator>\r\n\r\n\r\nint main(const int argc, const char* argv[]) {\r\n    if (argc == 1) {\r\n        std::cerr << \"Usage: program path_to_file\" << std::endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    const std::string path { argv[1] };\r\n\r\n    std::ifstream in(path);\r\n    const auto numbers = std::vector<int>(\r\n        std::istream_iterator<int>(in),\r\n        std::istream_iterator<int>()\r\n    );\r\n\r\n    std::cout << std::accumulate(numbers.begin(), numbers.end(), 0LL);\r\n\r\n    return EXIT_SUCCESS;\r\n}\r\n```\r\nКод короткий, достаточно понятный. А теперь подумаем: что будет, если файла нет или во время чтения достанут флешку, на которой этот файл записан? Хотелось бы как-то обрабатывать эти ситуации.\r\n\r\n \r\n\r\nМы-то знаем, что std::ifstream может бросать исключение при ошибках. Перепишем:\r\n```cpp\r\nstd::ifstream in;\r\nin.exceptions(std::ios_base::failbit);\r\nin.open(path);\r\n```\r\n \r\n\r\nИ сразу же замечаем 2 плохие вещи:\r\n\r\n1. Исключение std::ios_base::failure содержит мало информации об ошибке:\r\n```\r\nterminate called after throwing an instance of 'std::ios_base::failure'\r\n  what():  basic_ios::clear: iostream error\r\n```\r\n \r\n\r\nЧто можно понять из этого сообщения? Только то, что что-то пошло не так при работе с потоками, а что именно (проблема с файлом или с его содержимым) -- не понятно. Более того, в большой программе это вообще не информативный вывод, хуже не придумаешь.\r\n\r\n2. Даже если файл существует, содержит только числа, всё равно кидается исключение после того, как достигается конец потока (кроме eofbit выставляется failbit, что логично). Как побороть это, не написав кучу некрасивого кода? Отказываться от исключений и писать так?\r\n\r\n \r\n```cpp\r\n#include <iostream>\r\n#include <vector>\r\n#include <fstream>\r\n#include <numeric>\r\n#include <iterator>\r\n#include <string>\r\n\r\n\r\nint main(const int argc, const char* argv[]) {\r\n    if (argc == 1) {\r\n        std::cerr << \"Usage: program path_to_file\" << std::endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    const std::string path { argv[1] };\r\n\r\n    std::ifstream in;\r\n    in.open(path);\r\n\r\n    if (in.fail()) {\r\n        perror(\"Can't open file\");\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    std::vector<int> numbers;\r\n\r\n    while (!in.eof()) {\r\n        int number;\r\n        in >> number;\r\n\r\n        if (in.eof()) {\r\n            break;\r\n        }\r\n\r\n        if (in.fail()) {\r\n            if (errno) {\r\n                perror(\"Error while reading from file\");\r\n            } else {\r\n                std::cerr << \"Invalid file format! Value out of `int` domain or not number.\" << std::endl;\r\n            }\r\n\r\n            return EXIT_FAILURE;\r\n        }\r\n\r\n        numbers.push_back(number);\r\n    }\r\n\r\n    std::cout << std::accumulate(numbers.begin(), numbers.end(), 0LL);\r\n    return EXIT_SUCCESS;\r\n}\r\n```\r\n \r\n\r\nЧто-то длинно получилось... При этом я не учёл то, что на Windows ошибки правильнее смотреть через GetLastError() и выводить по-другому. Что хотелось бы написать?\r\n```cpp\r\n#include <iostream>\r\n#include <vector>\r\n#include <fstream>\r\n#include <numeric>\r\n#include <iterator>\r\n#include <string>\r\n\r\n\r\nint main(int argc, char** argv) {\r\n    if (argc == 1) {\r\n        std::cerr << \"Usage: program path_to_file\" << std::endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    try {\r\n        const std::string path { argv[1] };\r\n\r\n        std::ifstream in;\r\n        in.exceptions(std::ios_base::failbit);\r\n        in.open(path);\r\n\r\n        const std::vector<int> numbers {\r\n            std::istream_iterator<int>(in),\r\n            std::istream_iterator<int>()\r\n        };\r\n\r\n        std::cout << std::accumulate(numbers.begin(), numbers.end(), 0LL);\r\n    } catch (const std::ios_base::failure& e) {\r\n        std::cerr << \"Error while processing file: \"\r\n                  << \"Action: \" << e.action().name() // See below\r\n                  << \"Reason: \" << e.code().message() // Invalid format or system error\r\n                  << std::endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n\r\n    return EXIT_SUCCESS;\r\n}\r\n```\r\nКоротко и очень информативно, если возвращается соответствующая ошибка.\r\n\r\n \r\n\r\nИтого, что предлагается?\r\n\r\n1. Улучшить качество отдаваемых исключений:\r\n\r\n1.1. Возвращать ошибку, код которой соответствует исходной (файл не найден и т.п.). При ошибке чтения из-за неверного формата -- тоже соответствующая ошибка (новую категорию parse_error {domain, format}?). И только в том случае, если код ошибки получить невозможно -- текущий вариант. \r\n\r\n1.2. Также вместо бессмысленного basic_ios::clear тогда уже писать имя функции, которую пользователь вызвал. А ещё лучше -- завести enum (или что-то более хитрое) и его тоже возвращать:\r\n\r\n \r\n```cpp\r\nenum stream_action {\r\n    open,\r\n    close,\r\n    read,\r\n    write,\r\n    seek,\r\n    // etc\r\n};\r\n```\r\nЗачем? Чтобы можно было не только вывести хорошее сообщение об ошибке после отлавливания в любом месте программы, но и реализовать какую-то логику на основе этого.\r\n\r\n1.3. Может подумать над тем, чтобы в исключении ещё было имя файла? Не думал, технически реализуемо ли это без накладных расходов, но всё же.\r\n\r\n \r\n\r\n2. При использовании конструкции \r\n\r\n \r\n```cpp\r\nconst std::vector<int> numbers (\r\n    std::istream_iterator<int>(in),\r\n    std::istream_iterator<int>()\r\n);\r\n```\r\nне должно выбрасываться исключение из-за того, что дошли до конца потока (если я не прав, жду полного и объёмного объяснения, почему этот код должен работать в режиме без исключений и не работать в противоположном). \r\n\r\nКак это исправить? Сделать функцию (название и вид можно придумать лучше):\r\n\r\n \r\n```cpp\r\ntemplate <typename T>\r\nbool try_read(T& var);\r\n\r\ntemplate <typename T>\r\nbool try_read(T& var, std::error_code& code); // чтобы узнать, eof или что-то другое, хотя может быть лишнее, тут можно подумать.\r\n```\r\nИ использовать её внутри данного итератора. Да и кроме него она, думаю, будет полезной.\r\n\r\n \r\n\r\n3. В std::ifstream сделать функции с последним аргументом типа std::error_code для его получения, как сделано в std::filesystem. \r\n\r\n \r\n```cpp\r\nvoid open(const std::string& path, std::error_code& code);\r\nvoid close(std::error_code& error);\r\n// etc\r\n```\r\n \r\n\r\nЧто-то очень объёмно получилось... Даже не знаю, как это лучше было разделить, поэтому написал как есть. Надеюсь, среди этого наболевшего есть хоть что-то полезное ;).\r\n\r\n \r\n\r\nСпасибо.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/258/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/258/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/257",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/257/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/257/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/257/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/257",
    "id": 843105889,
    "node_id": "MDU6SXNzdWU4NDMxMDU4ODk=",
    "number": 257,
    "title": "Конструктор string_view от пары указателей",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:16:13Z",
    "updated_at": "2021-03-29T08:17:04Z",
    "closed_at": "2021-03-29T08:17:04Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **Дмитрий**\r\n\r\nСобственно предложение тривиальное:\r\n```cpp\r\nconstexpr basic_string_view(const CharT* b, const CharT* e);\r\n```\r\nПо удачному стечению обстоятельств итераторы std::string_view также являются указателями на символ, так что они автоматически подпадают под этот случай.\r\n\r\nВозможно, ещё не помешал бы конструктор от итераторов std::string, но тут я уже не уверен.\r\n\r\nС точки зрения теории пара указателей всегда взаимозаменяема с указателем и размером, но с точки зрения практического кода бывает удобнее, поэтому я считаю, что нужны оба варианта.\r\n\r\nВозьмём простой пример:\r\n```cpp\r\n#include <iostream>\r\n#include <string_view>\r\n#include <vector>\r\n\r\n#include <boost/algorithm/string/split.hpp>\r\n\r\nint main ()\r\n{\r\n    std::string_view view(\"qwe;rty\");\r\n\r\n    std::vector<std::string_view> tokens;\r\n    boost::split(tokens, view, [] (auto c) {return c == ';';});\r\n\r\n    for (auto x: tokens)\r\n    {\r\n        std::cout << x << std::endl;\r\n    }\r\n}\r\n```\r\nК сожалению, он не компилируется:\r\n```\r\n/usr/local/include/boost/range/iterator_range_core.hpp:873:55: error: invalid conversion from ‘boost::range_detail::extract_const_iterator<boost::iterator_range<const char*>, true>::type {aka const char*}’ to ‘std::basic_string_view<char>::size_type {aka long unsigned int}’ [-fpermissive]\r\n             return SeqT( boost::begin( r ), boost::end( r ) );\r\n                                             ~~~~~~~~~~^~~~~\r\n```\r\nЕсли же вышеуказанный конструктор добавить, то всё прекрасно компилируется и работает.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/257/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/257/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/256",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/256/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/256/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/256/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/256",
    "id": 843101163,
    "node_id": "MDU6SXNzdWU4NDMxMDExNjM=",
    "number": 256,
    "title": "Беспредельный copy elision",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "rusyaev-roman",
      "id": 38460316,
      "node_id": "MDQ6VXNlcjM4NDYwMzE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/38460316?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rusyaev-roman",
      "html_url": "https://github.com/rusyaev-roman",
      "followers_url": "https://api.github.com/users/rusyaev-roman/followers",
      "following_url": "https://api.github.com/users/rusyaev-roman/following{/other_user}",
      "gists_url": "https://api.github.com/users/rusyaev-roman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rusyaev-roman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rusyaev-roman/subscriptions",
      "organizations_url": "https://api.github.com/users/rusyaev-roman/orgs",
      "repos_url": "https://api.github.com/users/rusyaev-roman/repos",
      "events_url": "https://api.github.com/users/rusyaev-roman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rusyaev-roman/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "rusyaev-roman",
        "id": 38460316,
        "node_id": "MDQ6VXNlcjM4NDYwMzE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/38460316?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rusyaev-roman",
        "html_url": "https://github.com/rusyaev-roman",
        "followers_url": "https://api.github.com/users/rusyaev-roman/followers",
        "following_url": "https://api.github.com/users/rusyaev-roman/following{/other_user}",
        "gists_url": "https://api.github.com/users/rusyaev-roman/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rusyaev-roman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rusyaev-roman/subscriptions",
        "organizations_url": "https://api.github.com/users/rusyaev-roman/orgs",
        "repos_url": "https://api.github.com/users/rusyaev-roman/repos",
        "events_url": "https://api.github.com/users/rusyaev-roman/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rusyaev-roman/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-03-29T08:10:40Z",
    "updated_at": "2021-04-06T18:57:16Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +35, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nПравила copy elision в секции [[class.copy.elision]](http://eel.is/c++draft/class.copy.elision) отлично работают!\r\n\r\nОднако они подразумевают, что функция в исходном коде будет являться функцией и в бинарнике. Что не верно, для оптимизирующих компиляторов, умеющих встраивать тела функций и делать link-time оптимизации.\r\n\r\nДля таких компиляторов в ассемблерном коде программы зачастую можно встретить цепочки копирования+удаления объекта. Другими словами можно увидеть нечто подобное после встраивания функций:\r\n```cpp\r\nint caller() {\r\n    A a;\r\n    // ...\r\n\r\n    A b = a;\r\n    a.~A();\r\n    // ...\r\n\r\n    A c = b;\r\n    b.~A();\r\n    // ...\r\n}\r\n```\r\nПодобные цепочки всегда генерируются при:\r\n\r\n*    возврате субобъекта\r\n*    возврате элемента из structured binding\r\n*    std::move возвращаемого объекта\r\n*    возврате локального объекта используя ссылку\r\n*    возврате активного элемента union\r\n*    передаче параметра по копии в функцию в конце блока\r\n*    возврате объекта расположенного в std::aligned_storage\r\n*    возврате параметра функции, принятого по копии\r\n\r\nВ https://apolukhin.github.io/papers/ultimate_copy_elision.html предлагаю убрать существующие ограничения на copy elision и всегда позволять его делать если: копируемый локальный не volatile объект или его не volatile субобъект не используются после копирования.\r\n\r\nТакая формулировка не влияет на совместный scope объектов: Если код после inline выглядел как\r\n```cpp\r\nint caller() {\r\n    A a;\r\n    // ... #1\r\n\r\n    A b = a;\r\n    a.~A();\r\n    // ... #2\r\n\r\n    A c = b;\r\n    b.~A();\r\n    // ... #3\r\n\r\n    c.~A();\r\n}\r\n```\r\nТо с убранными ограничениями для copy elision код превратится в\r\n```cpp\r\nint caller() {\r\n    A a;\r\n    // ... #1\r\n    // ... #2\r\n    // ... #3\r\n\r\n    a.~A(); // бывший c.~A();\r\n}\r\n```\r\nПодобная оптимизация может положительно сказаться на времени компиляции и на время link-time оптимизации: в данный момент компиляторы пытаются встраивать вызов copy конструктора и деструктора и оптимизировать всё их содержимое в контексте текущей функции. Это ведёт к тому, что оптимизатор вынужден оптимизировать несколько мегабайт низкоуровнего кода, вместо того, чтобы просто выкинуть эти два вызова функций и работать с намного меньшими объёмами низкоуровневых команд.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/256/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/256/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/255",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/255/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/255/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/255/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/255",
    "id": 843099577,
    "node_id": "MDU6SXNzdWU4NDMwOTk1Nzc=",
    "number": 255,
    "title": "Целочисленные сортировки",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:08:51Z",
    "updated_at": "2021-03-29T08:09:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -1\r\n_Автор идеи:_ **Дмитрий**\r\n\r\nКак показывает практика, правильно написанные целочисленные сортировки быстры не только теоретически, но и вполне практически. Разница в скорости сортировки может достигать нескольких порядков. Жаль, что такие полезные алгоритмы до сих пор не стандартизированы.\r\n\r\n \r\n\r\nПредлагается следующий интерфейс поразрядной сортировки:\r\n```cpp\r\ntemplate <RandomAccessIterator I, RandomAccessIterator J, UnaryFunction Map>\r\nvoid radix_sort (I first, I last, J buffer, Map to_integer);\r\n```\r\n* [first, last) — сортируемый диапазон.\r\n\r\n* buffer — дополнительная память, требуемая для поразрядной сортировки. Её должно быть не менее чем distance(first, last).\r\n\r\n* to_integer — отображение элементов сортируемого диапазона в целые числа. В соответствии с ним и будет происходить сортировка.\r\n\r\nРезультат — отсортированный диапазон [first, last).\r\n\r\n \r\n\r\nОтносительно недавно появился boost::integer_sort, но этот алгоритм не нравится по следующим причинам:\r\n\r\n1. Он медленнее.\r\n\r\n2. Он менее гибок, т.к. не позволяет передать буфер снаружи, то есть самостоятельно производит аллокации.\r\n\r\n3. Он гибридный. Иначе говоря, сводится к std::sort на маленьких массивах. В результате в интерфейсе алгоритма есть две функции — shift и compare, которые могут быть рассогласованы, что потенциально может приводить к разным результатам сортировки в зависимости от размера сортируемого массива.\r\n\r\n \r\n\r\nВсе подробности, замеры, графики, идеи и обоснования тут: https://habrahabr.ru/post/271677/",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/255/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/255/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/254",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/254/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/254/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/254/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/254",
    "id": 843097714,
    "node_id": "MDU6SXNzdWU4NDMwOTc3MTQ=",
    "number": 254,
    "title": "ref-qualified operator () for lambda closure classes",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-29T08:06:40Z",
    "updated_at": "2021-03-29T08:07:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -2\r\n_Автор идеи:_ **webreh**\r\n\r\nСтандарт C++11 расширяет объявление non-static member functions понятием ref-qualifier, который влияет на возможность вызова соответствующей функции по lvalue reference и rvalue reference, тем самым обязывая вызывающего указать ссылку на постоянный или временный объект. Для operator() синтезированных лямбда-классов указание ref-qualifier невозможно.\r\n\r\nПредлагается дополнить синтаксис лямбда-выражений указанием ref-qualifier. Наиболее очевидным кажется синтаксис с указанием после опционального спецификатора mutable/constexpr\r\n```cpp\r\n[captures] <tparams> (params) specifiers ref-quailifier exception attr {}\r\n```\r\nИспользование: например, для лямбда-выражений с захватом MoveConstructible объектов и последующей однократной сборкой результирующего объекта максимально естественным является указание operator() как &&. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/254/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/254/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/253",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/253/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/253/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/253/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/253",
    "id": 842174259,
    "node_id": "MDU6SXNzdWU4NDIxNzQyNTk=",
    "number": 253,
    "title": "Constexpr категория итераторов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-26T17:38:37Z",
    "updated_at": "2021-03-27T18:57:14Z",
    "closed_at": "2021-03-26T17:38:52Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +12, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nВ данный момент, многие методы std::basic_string_view и std::array помечены как constexpr. Однако constexpr для begin()/end() и подобных методов не гарантирует, что полученный итератор можно будет использовать в constexpr.\r\n\r\nТак, например, std::array::begin() помечен как constexpr, но нет гарантий что его можно использовать в [немодифицирующих](https://apolukhin.github.io/papers/constexpr_algo_r3.html) или [модифицирующих](https://apolukhin.github.io/papers/constexpr_swap.html) алгоритмах на этапе компиляции.\r\n\r\n[В данном предложении](https://apolukhin.github.io/papers/constexpr_iter_categ_r0.html) предлагается исправить этот недочёт и получить полнофункциональные контейнеры, которые можно использовать в constexpr.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/253/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/253/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/252",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/252/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/252/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/252/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/252",
    "id": 842171876,
    "node_id": "MDU6SXNzdWU4NDIxNzE4NzY=",
    "number": 252,
    "title": "Copy elision для субобъектов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "rusyaev-roman",
      "id": 38460316,
      "node_id": "MDQ6VXNlcjM4NDYwMzE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/38460316?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rusyaev-roman",
      "html_url": "https://github.com/rusyaev-roman",
      "followers_url": "https://api.github.com/users/rusyaev-roman/followers",
      "following_url": "https://api.github.com/users/rusyaev-roman/following{/other_user}",
      "gists_url": "https://api.github.com/users/rusyaev-roman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rusyaev-roman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rusyaev-roman/subscriptions",
      "organizations_url": "https://api.github.com/users/rusyaev-roman/orgs",
      "repos_url": "https://api.github.com/users/rusyaev-roman/repos",
      "events_url": "https://api.github.com/users/rusyaev-roman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rusyaev-roman/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "rusyaev-roman",
        "id": 38460316,
        "node_id": "MDQ6VXNlcjM4NDYwMzE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/38460316?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rusyaev-roman",
        "html_url": "https://github.com/rusyaev-roman",
        "followers_url": "https://api.github.com/users/rusyaev-roman/followers",
        "following_url": "https://api.github.com/users/rusyaev-roman/following{/other_user}",
        "gists_url": "https://api.github.com/users/rusyaev-roman/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rusyaev-roman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rusyaev-roman/subscriptions",
        "organizations_url": "https://api.github.com/users/rusyaev-roman/orgs",
        "repos_url": "https://api.github.com/users/rusyaev-roman/repos",
        "events_url": "https://api.github.com/users/rusyaev-roman/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rusyaev-roman/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-03-26T17:34:59Z",
    "updated_at": "2021-04-04T16:36:42Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +12, -0\r\n_Автор идеи:_ **yndx-antoshkka**\r\n\r\nУскорить С++ позволив copy elision в большем количестве мест\r\n\r\nВ C++17 если мы возвращаем субобъект из функции, для него невозможно применить copy elision. Получается, что в данном коде:\r\n```cpp\r\n#include <utility>\r\n#include <string>\r\n\r\nstd::pair<std::string, std::string> produce();\r\n\r\nstatic std::string first_non_empty() {\r\n    auto v = produce();\r\n    if (!v.first.empty()) {\r\n        return v.first;\r\n    }\r\n    return v.second;\r\n}\r\n\r\nint example_1() {\r\n    return first_non_empty().size();\r\n}\r\n```\r\nБудет копирование строки из v.second.\r\n\r\nСитуацию можно немного улучшить, если явно добавить std::move:\r\n```cpp\r\n#include <utility>\r\n#include <string>\r\n\r\nstd::pair<std::string, std::string> produce();\r\n\r\nstatic std::string first_non_empty_move() {\r\n    auto v = produce();\r\n    if (!v.first.empty()) {\r\n        return std::move(v.first);\r\n    }\r\n    return std::move(v.second);\r\n}\r\n\r\nint example_1_move() {\r\n    return first_non_empty_move().size();\r\n}\r\n```\r\nНо даже в этом случае компиляторы не генерируют оптимальный код, который в идеале должен выглядеть как\r\n```cpp\r\n#include <utility>\r\n#include <string>\r\n\r\nstd::pair<std::string, std::string> produce();\r\n\r\nint example_1_optimized() {\r\n    auto v = produce();\r\n    if (!v.first.empty()) {\r\n        return v.first.size();\r\n    }\r\n    return v.second.size();\r\n}\r\n```\r\nПредлагаю добавить больше разрешающих правил для copy elision в секцию [class.copy.elision] или разрешить coy elision для всех случаев, когда копируемый объект или субобъект не используются после копирования.\r\n\r\nПодробности (вместе с ассембленым кодом, доказательствами что copy elision оптимальнее чем std::move) доступны по ссыле: https://apolukhin.github.io/papers/subobjects_copy_elision.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/252/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/252/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/251",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/251/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/251/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/251/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/251",
    "id": 842168948,
    "node_id": "MDU6SXNzdWU4NDIxNjg5NDg=",
    "number": 251,
    "title": "Упростить синтаксис ламбда-выражений",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T17:30:34Z",
    "updated_at": "2021-03-26T17:31:25Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -7\r\n_Автор идеи:_ **Дмитрий**\r\n\r\nСуществующие лямбда-функции порой довольно многословны. Что если немного упростить их синтаксис. Имею ввиду не вырезать то, что есть, а добавить новый синтаксис, а именно:\r\n\r\n1. Сделать опциональным указание типа параметра\r\n\r\n2. Убрать return из тела лямбда-функций\r\n\r\nНасчет первого - идея не нова. Например на cppcon 2014 Герб Саттер уже как-то предлагал похожий вариант для range-for loop. Типа такого:\r\n```cpp\r\nfor(item : collection) {}\r\n```\r\nНе уверен, но по всей видимости это должно было интерпретировать как auto&& item. По аналогии можно сделать и в лямбдах. (Можно ли?)\r\n\r\nНасчет второго - можно было бы последнее выражение без ';' трактовать как возвращаемое значение (примерно как в Rust). Правда не уверен, что здесь нет каких-нибудь подводных камней по типу 'существующая грамматика уже настолько сложна, что это все не получится реализовать' или 'не будет обратной совместимости'.\r\n\r\n \r\n\r\nПо итогу, вместо этого:\r\n```cpp\r\nauto greater = [](auto&& x, auto&& y){ return x > y; };\r\n```\r\nМы получим это:\r\n```cpp\r\nauto greater = [](x, y){ x > y };\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/251/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/251/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/250",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/250/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/250/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/250/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/250",
    "id": 842167807,
    "node_id": "MDU6SXNzdWU4NDIxNjc4MDc=",
    "number": 250,
    "title": "Добавить метод split для std::string",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T17:28:52Z",
    "updated_at": "2021-03-26T17:29:35Z",
    "closed_at": "2021-03-26T17:29:28Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -1\r\n_Автор идеи:_ **Грандмастер Б.**\r\n\r\nПри работе со строками часто нужно необходимо разбить строку на отдельные слова,но так как split отсутствует в std, каждый велосипедирует как может",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/250/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/250/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/249",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/249/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/249/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/249/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/249",
    "id": 842166127,
    "node_id": "MDU6SXNzdWU4NDIxNjYxMjc=",
    "number": 249,
    "title": "Стандартизировать порядок вычисления аргументов переданных в функцию",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T17:26:32Z",
    "updated_at": "2021-03-26T17:27:32Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -9\r\n_Автор идеи:_ **Игорь**\r\n\r\n\r\nДавным-давно просто был ужасно опечален, узнав что в моем любимом С++ не стандартизован порядок исполнения аргументов у функции.\r\n\r\nЯ готов мириться со многими UB, но с таким не хочется. Про него писал еще вроде Майерс, но я так и не понял, почему никто не хочет взяться и стандартизировать такую важную вещь? Причем, в С++17 какие то были фиксы в сторону порядка вычислений каких-то выражений. Сейчас, скомпилив этот код ниже в последнем шланге и последнем gcc, я получаю совершенно разный вывод. Во многих проектах я неоднократно натыкался на этот UB. И я уверен, что натыкались на это все С++ разработчики. Объясните, что мешает урегулировать данное поведение, чтобы все вычислялось слева направо? Я так понял, изначально при проектировании С++ на этот вопрос не уделили должного внимания. Спасибо. Вот код который ведет себя по разному в разных компиляторах:\r\n\r\n \r\n```cpp\r\n#include <iostream>\r\nint foo() {\r\n    std::cout << \"foo\\n\"; return 42;\r\n}\r\n\r\nint bar() {\r\n    std::cout << \"bar\\n\"; return 42;\r\n}\r\n\r\nvoid some(int, int) { }\r\n\r\nint main() {\r\n    some(foo(), bar());\r\n}\r\n```\r\n \r\n\r\nОдин компилятор выводит:\r\n```\r\nfoo\r\nbar\r\n```\r\nДругой:\r\n```\r\nbar\r\nfoo\r\n```\r\nПока мне виднеется эта проблема сверх критической в языке.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/249/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/249/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/248",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/248/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/248/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/248/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/248",
    "id": 842094705,
    "node_id": "MDU6SXNzdWU4NDIwOTQ3MDU=",
    "number": 248,
    "title": "Attribute [[pack]] для разрешения сжатия путём изменения порядка переменных",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T15:58:38Z",
    "updated_at": "2021-03-26T16:00:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -4\r\n_Автор идеи:_ **zamazan4ik@tut.by** @ZaMaZaN4iK\r\n\r\nДобавить в C++ атрибут для разрешения компиляторам переупорядочивания порядка членов структуры\\класса для оптимизации размера структуры\\класса.\r\n\r\nОсновная ссылка и обсуждение:\r\n\r\nhttps://groups.google.com/a/isocpp.org/forum/?fromgroups=#!searchin/std-proposals/reorder/std-proposals/sjeBBZduXVc/C5nlKLRKOH0J\r\n\r\nОсновная идея: ввести атрибут в Стандарт, который будет разрешать переупорядочивать местами переменные в структурах.\r\n\r\nДля чего нужно переупорядочивание: снижение размера структуры, рандомизация порядка (пример из ядра Линукс). Если у Вас есть идеи, где это ещё может пригодиться, пишите в комментах. Я пока что фокусируюсь только на снижении размера структуры (что уже есть в Rust)\r\n\r\nКрайне рекомендую ознакомиться с изначальным обсуждением в гуглогруппе.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/248/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/248/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/247",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/247/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/247/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/247/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/247",
    "id": 842092256,
    "node_id": "MDU6SXNzdWU4NDIwOTIyNTY=",
    "number": 247,
    "title": "has_key(key), value_or(key, defaultValue)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      },
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:55:29Z",
    "updated_at": "2023-10-22T10:29:18Z",
    "closed_at": "2023-10-22T10:29:12Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -0\r\n_Автор идеи:_ **kitmouse**\r\n\r\nдобавить в ассоциативные контейнеры из stl (set, map, unordered_set, unordered_map) методы для\r\n1 проверки наличия ключа (возможные имена has_key, contains_key, вставьте_свое) \r\n2 (только map, unordered_map) получения значения по ключу, либо значения по умолчанию (принимается вторым аргументом), если такого ключа нет (возможное имя get_or, at_or, value_or, вставьте_свое, или как двухаргументная перегрузка at) ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/247/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/247/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/246",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/246/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/246/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/246/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/246",
    "id": 842090988,
    "node_id": "MDU6SXNzdWU4NDIwOTA5ODg=",
    "number": 246,
    "title": "Версия ядра",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T15:53:53Z",
    "updated_at": "2021-03-26T15:54:29Z",
    "closed_at": "2021-03-26T15:54:29Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -0\r\n_Автор идеи:_ **Dima Kos**\r\n\r\nХорошо бы добавить таки версию стандарта поддерживаемую данным конкретным компилятором.\r\n\r\nЯ честно говоря не читал ещё, что там по 20ке. И к сожалению(может меня подводит уставший мозг) я не нашел поиска по предложениям на этом сайте, что очень неудобно. Возможно кто-то это уже предлагал. Но всё же я хочу высказать своё мнение: Доколе мы будем писать портянки условной компиляции, учитывая всевозможные компиляторы и их версии - не пора бы уже ввести какие нибудь человеческие макросы для определения версии стандарта. \r\n\r\nКакой нибудь __CPPSTD_VERSION__ или что нибудь типа того. Я понимаю, что многие компиляторы не поддерживают стандарт целиком или уже начинают поддерживать фичи не принятого ещё стандарта, но я считаю, что всё равно нам этой проблемой стоит подумать. Например, эти макросы можно расширять по названиям ключевых нововведений, которые также прописаны в стандарте, а когда компилятор доходит до абсолютной готовности соответсвия тому или иному стандарту, то может задефайнить только __CPPSTD_VERSION__. А писатели библиотек соответсвенно будут чекать либо её либо конкретные отдельные фичи. По крайней мере всякие config.hpp будут меньше и больше вероятность, что это всё взлетит на каких нибудь малоизвестных компиляторах(при условии что они более менее следуют стандарту).\r\n\r\nPS\r\nЯ не знаю куда написать(письмом??...) по данному ресурсу - т.к. на сайте обратной связи я тоже не нашел, а так хотелось написать про отсутствие поиска. Конечно можно искать из поисковиков на данном сайте :), но согласитесь - это не то...",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/246/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/246/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/245",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/245/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/245/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/245/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/245",
    "id": 842089530,
    "node_id": "MDU6SXNzdWU4NDIwODk1MzA=",
    "number": 245,
    "title": "Перенести в стандартную библиотеку boost::lexical_cast",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:52:07Z",
    "updated_at": "2021-03-26T17:22:51Z",
    "closed_at": "2021-03-26T17:22:45Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -4\r\n_Автор идеи:_ **Игорь**\r\n\r\nБыло бы неплохо, если такая крайне часто используемая библиотека как boost::lexical_cast мигрировала бы в стандартную библиотеку.\r\n\r\n \r\n\r\nЧасто используемая и полезная библиотека обязана лежать в пространстве std чтобы лишний раз не грузить по этому поводу бусты.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/245/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/245/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/244",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/244/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/244/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/244/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/244",
    "id": 842085898,
    "node_id": "MDU6SXNzdWU4NDIwODU4OTg=",
    "number": 244,
    "title": "Передача переменных в функцию по имени аргумента",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:47:37Z",
    "updated_at": "2021-03-26T15:49:38Z",
    "closed_at": "2021-03-26T15:49:32Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -5\r\n_Автор идеи:_ **mixtapex**\r\n\r\nВозможность использовать функции как в python и других shell-языках (передача переменных в функцию по имени аргумента):\r\n```\r\nfunction('from' = 0, 'to' = 100, 'vector' = vector);\r\n```\r\n\r\nВ shell-языках типа Python, а так же в JS и т.д. есть способ передавать значение переменной в функцию по названию аргумента.\r\n\r\nА именно:\r\n```\r\nfunction('from' = 0, 'to' = 100, 'vector' = vector);\r\n```\r\n \r\n\r\nДанная возможность позволила бы повысить читаемость кода, так как не было бы необходимости смотреть определение фукнции, что бы понять какие аргументы и в какой последовательности задаются.\r\n\r\n \r\n\r\nП.С.: Некоторое время назад, если я ничего не путаю, то это обсуждалось в сообществе.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/244/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/244/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/243",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/243/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/243/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/243/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/243",
    "id": 842072836,
    "node_id": "MDU6SXNzdWU4NDIwNzI4MzY=",
    "number": 243,
    "title": "Добавить постфиксый оператор разыменовывания",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T15:31:25Z",
    "updated_at": "2022-08-11T18:44:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -12\r\n_Автор идеи:_ **kitmouse**\r\n\r\nПопадаются длинные строки, возвращающие значение, которое надо разыменовать, чтобы сравнить, присвоить и т.д..\r\n*foobaar.foobarmember[longIndexVariableName]->retrievePointerToSomething()->vectorOfPointers[anotherIndex] = anotherThing;\r\nВыражение легко читается слева направо - до того момента, когда вам надо понять, произошло ли присвоение к указателю, хранящемуся в vectorOfPointers, или к тому, на что он указывает. Тогда нужно перевести взгляд на начало и проверить наличие *\r\n\r\nПохожий механизм в c++ уже есть - мы можем использовать -> чтобы разыменовать объект и сразу же обратиться к его члену вместо \"(*\" слева от выражения и \").\" справа от него, спасая разработчика от необходимости постоянно переводить взгляд влево-вправо. То что им пользуются показывает, что этот оператор добавлен в язык не зря.\r\nНо если вы хотите не обратиться к члену того, на что, на что указывает длинное выражение, а, например сравнить (==), присвоить(=) или проиндексировать( [] ) его? Для таких операций сокращений нет, придется использовать пару \"(*\" и \")[idx]\". А читая это, придется переводить взгляд туда-сюда, и следить за тем, какой \"(*\" относится к какому \")[idx]\". Много сложнее. Именно для избежания подобного некогда был придуман ->\r\n\r\nВозьмем строку из \"основной мысли\"\r\n```cpp\r\n*foo.fooMember[IndexVariableName]->retrievePointer()->containerOfPointers[anotherIndex] = anotherThing;\r\n```\r\nОна уже плоха, из-за того, что чтобы прочесть ее надо из = перевести взгляд влево и проверить наличие * в начале, чтобы понять, что именно происходит. \r\nТеперь представьте себе, что containerOfPointers - это unique_ptr на абтрактный базовый класс, так что иначе чем через указатель им владеть нельзя:\r\n\r\n```cpp\r\n*(*foo.fooMember[IndexVariableName]->retrievePointer()->containerOfPointers)[anotherIndex] = anotherThing;\r\n```\r\nили возьмем пример худшего случая, в котором кучей контейнеров владеют по указателю:\r\n\r\n```cpp\r\n*(*(*(*foo->anotherfoos)[\"name4\"]->anotherfoos)[fooId]->getContainerSharedPtr)[0] != *bar\r\n```\r\nСравните с версие\r\n\r\nМожно продолжать приводить все более запутанные примеры, но я думаю, все и так уже поняли, что синтаксис получается запутанный. Его сложно читать, в нем проще простого пропустить ошибку и он попросту неприятен.\r\n\r\nОжним из обходов является \"longExpression[0]\", но работает оно только с сырыми указателями, и вводит читателя в заблуждение, т.к. в изначальном смысле означает \"получить первый элемент контейнера\" а не \"разыменовать то, что слева\". \r\n\r\nПоэтому, я предлагаю добавить синтаксис постфиксного разыменовывания. Придумывать видоизмененную версию для операторов индексирования, присвоения и каждого оператора сравления было бы неразумно, поэтому остается некий постфиксный оператор.\r\nКакой именно оператор - не предмет этого предложения, но, для примера возьмем \"<*\".\r\n\r\nПопробуем переписать примеры выше с использованием <*: (я не настаиваю на нем, это только как пример)\r\n\r\n```cpp\r\nfoo.fooMember[IndexVariableName]->retrievePointer()->containerOfPointers*<[anotherIndex]<* = anotherThing;\r\n\r\nfoo->anotherfoos<*[\"name4\"]->anotherfoos<*[fooId]->getContainerSharedPtr<*[0]<* != *bar\r\n```\r\nкрасота оператора , но теперь можно читать слево направо. Теперь",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/243/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/243/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/242",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/242/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/242/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/242/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/242",
    "id": 842068376,
    "node_id": "MDU6SXNzdWU4NDIwNjgzNzY=",
    "number": 242,
    "title": "Унификация структуры файла модуля ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:26:11Z",
    "updated_at": "2021-03-26T15:29:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -1\r\n_Автор идеи:_ **lobatsevichdmitry**\r\n\r\n\r\nСтруктуру файла модуля унифицировать, чтобы модуль, построенный одним компилятором, можно было бы использовать, собирая код другим компилятором, а разработчики библиотек могли бы выкладывать единую универсальную сборку.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/242/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/242/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/241",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/241/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/241/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/241/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/241",
    "id": 842066722,
    "node_id": "MDU6SXNzdWU4NDIwNjY3MjI=",
    "number": 241,
    "title": "Признак переменной UnSet",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T15:24:13Z",
    "updated_at": "2021-03-26T15:24:55Z",
    "closed_at": "2021-03-26T15:24:49Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Р**\r\n\r\nБывают ситуации когда переменная не инициализировалась действительным значением. Например не попала в блок под циклом или по сети не пришло ее значение. Для таких ситуация выбирается особое значение возможное у этого типа и логически закрепляется как Undefined. Например int i = -1; но как быть когда каждое возможное значение у данного типа отображает состояние которое нужно получить или считать. Например у bool remoteProcessDone = false; но мы не получали пакет с этим признаком и не ясно точно что обозначет этот флаг. Для этого обычно вводиться еще один флаг.\r\n\r\nПредлагаю ввести модификатор переменной unset который добавлял бы признак того что переменой было назначено новое действительное значение. Так же этим состоянием можно было управлять - снимать признак назанчения.\r\n\r\nНапример:\r\n```cpp\r\nbool unset remoteProcessDone = false;\r\n\r\n....\r\n\r\nif (ConnectToRemoteProcess()) {\r\n\r\nremoteProcessDone = GetRemoteStateDoneProcess();\r\n\r\n}\r\n\r\n \r\n\r\nif(remoteProcessDone) {\r\n\r\n//true\r\n\r\n} else {\r\n\r\n//false\r\n\r\n} unset {\r\n\r\n// unset/undefined\r\n\r\n}\r\n\r\n \r\n\r\n//так же можно задавать блок в коде где проверяется что переменные были явно назначены\r\n\r\nch_unset {\r\n\r\nremoteProcessDone,\r\n\r\n......\r\n\r\n//тут идет проверка всех переменных на признак того что им были назначены значения.\r\n\r\n//если хоть одна из переменных была unset можно генерировать исключения или обработчик.\r\n\r\n}\r\n\r\n \r\n\r\nremoteProcessDone = true/false; // set\r\n\r\nunset(remoteProcessDone); //снимаем признак назначения переменной.\r\n\r\n//remoteProcessDone -  unset\r\n```\r\n \r\n\r\nтехнически сами признаки можно хранить в виде битов, битовыми наборами в памяти.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/241/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/241/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/240",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/240/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/240/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/240/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/240",
    "id": 842062482,
    "node_id": "MDU6SXNzdWU4NDIwNjI0ODI=",
    "number": 240,
    "title": "Короткая запись \"foreach\"",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:19:06Z",
    "updated_at": "2022-08-11T18:46:55Z",
    "closed_at": "2022-08-11T18:46:55Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -16\r\n_Автор идеи:_ **Р**\r\n\r\n\r\nВ С++11 ввели аналог foreach, типа:\r\n```cpp\r\nfor (auto x : list) { /* .. */ },\r\n```\r\nМожно запись укоротить до `for (list) { /* item */ }`, доступ к текущему элементу в итерации например через ключевое слово item или типа того.\r\nЛибо `foreach (list) {}` , `fors (list) {}` (for short)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/240/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/240/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/239",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/239/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/239/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/239/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/239",
    "id": 842060863,
    "node_id": "MDU6SXNzdWU4NDIwNjA4NjM=",
    "number": 239,
    "title": "Switch по объектам произвольных типов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:17:15Z",
    "updated_at": "2021-04-06T19:12:07Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +25, -5\r\n_Автор идеи:_ **Евгений**\r\n\r\nВ данный момент конструкция switch-case работает только с целыми числами и enum-ами, хотелось бы иметь возможность использовать switch-case с произвольными данными. Часто не хватает switch'а по строкам, например.\r\n\r\n \r\n```cpp\r\n// example\r\nstd::string color(\"red\");\r\nswitch(color) {\r\n    case \"red\": {\r\n       // red color processing logic\r\n       break;\r\n    }\r\n    case \"green\": {\r\n        // green color processing logic\r\n        break;\r\n    }\r\n    case \"blue\": {\r\n        // blue color processing logic\r\n        break;\r\n    }\r\n    default: {\r\n        std::cerr << \"unknown color: \" << color << std::endl;\r\n    }\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/239/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/239/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/238",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/238/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/238/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/238/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/238",
    "id": 842051465,
    "node_id": "MDU6SXNzdWU4NDIwNTE0NjU=",
    "number": 238,
    "title": "member functions в качестве UnaryFunction для алгоритмов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:09:58Z",
    "updated_at": "2021-03-26T15:16:24Z",
    "closed_at": "2021-03-26T15:16:18Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **Antervis**\r\n\r\nРазрешить передавать в STL алгоритмы member function типа значения контейнера\r\n\r\nПростой пример:\r\n```cpp\r\nvector v = {\"abc\"s, \"\"s, \"123\"s};\r\n// Поиск пустой строки - сейчас\r\nauto it = find_if(v.begin(), v.end(), [](auto &s) { return s.empty() });\r\n// Поиск пустой строки - предлагаемый\r\nauto it = find_if(v.begin(), v.end(), &string::empty);\r\n```\r\n\r\nЕсли я правильно понимаю, в реализации алгоритмов изменится только явный вызов на std::invoke.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/238/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/238/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/237",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/237/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/237/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/237/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/237",
    "id": 842043469,
    "node_id": "MDU6SXNzdWU4NDIwNDM0Njk=",
    "number": 237,
    "title": "Добавить расширяющие класс/структуру методы.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T15:04:33Z",
    "updated_at": "2021-03-26T15:09:05Z",
    "closed_at": "2021-03-26T15:08:59Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -5\r\n_Автор идеи:_ **Игорь**\r\n\r\nПредложение добавить конструкцию, которая как бы расширяла внутренний мир существующего пользовательского объекта. Но на самом деле, компилятор должен будет сгенерировать специальный внешний метод.\r\n\r\nОчень часто хочется расширить существующий объект каким-либо методом, при этом не затронув интерфейс и структуру поставляемего класса.\r\n\r\n \r\n\r\nЕсли не трогать код поставляемого класса, сейчас принято делать свободные функции или перегружать операторы, которые будут принимать экземпляр существующего класса в том или ином виде и производить определенные над ним действия.\r\n\r\n \r\n\r\nПредлагаю ввести новую конструкцию в язык, которая будет делать весь этот процесс под капотом, при этом, на уровне синтаксиса предлагать пользователю интерфейс вызова нового метода, как будто он действительно принадлежит экземпляру класса.\r\n\r\n \r\n\r\nДалее будет приведен пример того как это могло бы выглядеть. На лучшее наименование ключевого слова не претендую. В идеале обходиться без новых ключевых слов, но в голову других вариантов не приходит.\r\n\r\n \r\n\r\nПриведу пример по все той же \"наболевшей\"  реализацией метода .split.\r\n\r\nВот так будет выглядеть определение расширяющего класс/структуру метода:\r\n```cpp\r\nstd::vector<std::string> std::string::split(const std::string& delim) extension\r\n{\r\n    /// Здесь какая-либо реализация логики данной функции...\r\n\r\n    /// this - получение константного указателя на экземпляр класса, для которого создаем расширяющий метод\r\n    auto pos = this->find(delim);\r\n    \r\n    /// ...\r\n\r\n    return  std::vector<std::string>(res);\r\n}\r\n```\r\nКомпилятором этот метод будет преобразован в нечто:\r\n\r\n \r\n```cpp\r\nstd::vector<std::string> compiler_some_name_split(std::string* const str, const std::string& delim);\r\n```\r\nКоторый будет откликаться на синтаксис .split:\r\n```cpp\r\nstd::string str;\r\nauto res = str.split(\"\\n\");\r\n```\r\nВсе равно, что бы мы вызвали:\r\n```cpp\r\nstd::string str;\r\nauto res = compiler_some_name_split(&str, \"\\n\");\r\n```\r\n \r\n\r\nЧисто концептуальный второй пример для наглядности, абстрагируясь от строк:\r\n\r\n \r\n```cpp\r\nstruct A\r\n{\r\n    int value;\r\n    int foo() { return value; }\r\n};\r\n\r\n\r\nint A::bar() extension\r\n{\r\n    return this->foo();\r\n}\r\n\r\n// Компилятором будет создано со своим каким он захочет именем:\r\nint _bar(A* const a)\r\n{\r\n    return a->foo();\r\n}\r\n\r\nint main()\r\n{\r\n    A a{42};\r\n    std::cout << a.bar(); // 42\r\n    // Вместо конструкции выше по факту будет вызвано\r\n    std::cout << _bar(&a);\r\n}\r\n```\r\n \r\n\r\nИ последний пример, если мы захотим добавить расширяющий метод для шаблонного класса:\r\n```cpp\r\ntemplate <class T>\r\nstruct A\r\n{\r\n    T value;\r\n\r\n    T foo() { return value; }\r\n};\r\n\r\n/// Таким образом мы создаем расширяющий метод для всех типов шаблонного класса A\r\ntemplate<class T>\r\nT A<T>::bar() extension\r\n{\r\n    return this->foo();\r\n}\r\n\r\n/// Такую функцию сгенерирует компилятор с именем, которое он захочет\r\ntemplate <class T>\r\nT _bar(A<T>* const a)\r\n{\r\n    return a->foo();\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    A<int> a{42};\r\n    std::cout << a.bar(); // 42\r\n    /// Вместо конструкции выше будет выполнена эта:\r\n    std::cout << _bar(&a);\r\n}\r\n```\r\n \r\n\r\nПо сути - это добавление синтаксического сахара для вызова методов.\r\n\r\nПриму любую критику, почему данная фича не может быть добавлена в ядро языка. Реализовать такое компилятору думаю будет совсем не сложно.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/237/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/237/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/236",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/236/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/236/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/236/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/236",
    "id": 841942536,
    "node_id": "MDU6SXNzdWU4NDE5NDI1MzY=",
    "number": 236,
    "title": "арные операторы",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T13:06:41Z",
    "updated_at": "2021-03-26T13:07:00Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -10\r\n_Автор идеи:_ **post-increment**\r\n\r\nПозволить операторам иметь произвльную арность\r\n\r\nПример языка Julia.\r\n\r\n![image](https://user-images.githubusercontent.com/1700098/112635700-30f63580-8e4d-11eb-9953-9eed6f986be1.png)\r\n\r\nПодобную механику было бы интересно встроить в С++.\r\n\r\nЧто это может дать?\r\nОсновное достоинство которое мне видится это отложенные вычисления.\r\n```cpp\r\n//with some other proposals this looks like\r\nauto operator+(std::string&& init, std::string&&... args )\r\n{\r\n    return std::lazy_sum{std::forward(init), std::forward(args)...};\r\n}\r\n\r\nstd::string sum = s1+s2+s3;\r\n// magic is done when lazy_sum is passed to operator=\r\n// buffer is allocated for given size then copying of data without\r\n//    temporary strings is made\r\n```\r\n\r\nСейчас подобное провернуть удастся с помощью binary-expression-tree.\r\nДля чего потребуется рекурсивное определение сложения для lazy-sum и string.\r\n\r\nЖду ваших мыслей и комментариев по этому поводу.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/236/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/236/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/235",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/235/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/235/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/235/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/235",
    "id": 841936556,
    "node_id": "MDU6SXNzdWU4NDE5MzY1NTY=",
    "number": 235,
    "title": "Несколько аргументов в перегруженном brackets operator",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-26T12:59:08Z",
    "updated_at": "2022-01-27T07:01:02Z",
    "closed_at": "2022-01-27T07:00:52Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -5\r\n_Автор идеи:_ **Олег Ляттэ**\r\n\r\nЭто позволит использовать более лаконичные и понятные выражения для доступа к многомерным массивам и подобным структурам\r\n\r\nЕсли возникает необходимость работы с многомерными структурами, то иногда приходится делать так (на примере матрицы трансформации):\r\n```cpp\r\nclass Matrix\r\n{\r\npublic:\r\n  float* operator[](int row);\r\n};\r\n\r\nMatrix m;\r\nm[3][1] = 0.0f;\r\n```\r\nМы используем operator[] с одним аргументом, который должен вернуть нечто (в данном случае указатель), к чему можно ещё раз применить operator[] с одним аргументом, и так до тех пор, пока не достигнется нужное количество измерений.\r\n\r\n \r\n\r\nХорошо, если это \"нечто\" - некий простой встроенный тип (ссылка на массив или указатель). А если это некая внутренняя структура, которую хотелось бы сохранить приватной? Приходится добавлять вспомогательные типы-хелперы, единственная задача которых - быть промежуточным звеном в цепочке квадратных скобок.\r\n\r\nС предложенным изменением можно написать так:\r\n```cpp\r\nclass Matrix\r\n{\r\npublic:\r\n  float& operator[](int row, int column);\r\n};\r\n\r\nMatrix m;\r\nm[3, 1] = 0.0f;\r\n```\r\nЗдесь нет промежуточных типов, и не надо гадать, что происходит: один вызов оператора для получения нужного результата. А увеличение количества измерений приведёт лишь к появлению дополнительных аргументов оператора.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/235/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/235/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/234",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/234/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/234/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/234/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/234",
    "id": 841935376,
    "node_id": "MDU6SXNzdWU4NDE5MzUzNzY=",
    "number": 234,
    "title": "Не пора ли разрешить возвращать разные типы у overloaded методов?",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T12:57:31Z",
    "updated_at": "2021-03-26T12:57:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -11\r\n_Автор идеи:_ **Pavel**\r\n\r\nКак только компилятор видит разные возвращаемые типы - сразу врубает explicit у методов, чтобы не было никаких неявных преобразований.\r\n\r\nИнтерфейсы будут ещё более лаконичными, как мне кажется. Что-то проблем не вижу сходу.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/234/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/233",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/233/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/233/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/233/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/233",
    "id": 841934641,
    "node_id": "MDU6SXNzdWU4NDE5MzQ2NDE=",
    "number": 233,
    "title": "const ctor (и возможно dtor)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T12:56:24Z",
    "updated_at": "2021-03-26T12:56:43Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -1\r\n_Автор идеи:_ **post-increment**\r\n\r\nДанное предложение я рассматриваю как уменьшение boiler-plate.\r\nПри создании const-объекта и non-const-объекта могут быть различия.\r\nХотелось бы иметь квалификатор const для конструктора, позволяющий контекстно создавать const-объект.\r\n\r\nПример того, как это может работать.\r\n```cpp\r\nclass Index\r\n{\r\npublic:\r\n    Index(int* rhs, int len)\r\n    : data_{rhs}\r\n    , length_{len}\r\n    {}\r\n\r\n    Index(int const* rhs, int len) const\r\n    : data_{const_cast<int*>(rhs)} // Note: only for this example\r\n    , length_{len}\r\n    {}\r\n    \r\n    Index(Index& rhs)\r\n    : data_{rhs.data_}\r\n    , length_{rhs.length_}\r\n    {}\r\n\r\n    Index(Index const& rhs) const\r\n    : data_{rhs.data_}\r\n    , length_{rhs.length_}\r\n    {}\r\n\r\n\r\n    //some other ctors and methods\r\n    \r\n    int  operator[](int i) const { return data_[i]; }\r\n    int& operator[](int i) &     { return data_[i]; }\r\n    \r\nprivate:\r\n    int* data_;\r\n    int  length_;\r\n};\r\n\r\nvoid do_smth(Index const& ind)\r\n{\r\nIndex ref_ind(ind);// error: non-const c-tor can't take const Index&\r\n// do smth\r\n}\r\n\r\nint main\r\n{\r\n   int* data[10];\r\n   for(int k = 0; k < 10; ++k)\r\n     data[k] = k+3;\r\n   int const* cdata = data;\r\n   Index mut_ind(data+3, 7);          // ok\r\n   Index const const_ind(cdata+2, 8); // ok\r\n\r\n   mut_ind[0] = 0;   // ok\r\n   const_ind[0] = 3; // error: can't access non-const operator[]\r\n\r\n   do_smth(mut_ind);\r\n   Index ind1(cdata + 1, 9); // error: non-const c-tor can't take const int* \r\n\r\n   Index const const_ind1(const_ind); // ok\r\n   Index mut_ind1(mut_ind);           //ok\r\n   Index ind2(const_ind);   // error: non-const c-tor can't take const Index&\r\n}\r\n```\r\nВ данном примере const-объект может быть создан только по const int*.\r\nДля простоты примера я сделал const_cast.\r\nОпасаюсь, что пример может показаться притянутым за уши, поэтому также добавил конструкторы копии.\r\nИтак, non-const-объект в этом случае может быть создан только из non-const-объекта.\r\n\r\nКак это можно сделать сейчас? Как мне видится...\r\nСоздать класс ConstIndex и прописать для него все const-методы.\r\nОтнаследовать от него класс Index и про писать для него все non-const методы.\r\nПочему так? Чтобы защитить constness объекта-ссылки от создания non-const ссылки через копию.\r\nЕсли не создавать ConstIndex, то получается такой пример некорректного использования квалификатора const. \r\n```cpp\r\n// Bad example\r\nclass Index1\r\n{\r\npublic:\r\n    Index1(Index1 const& i);// copy\r\nprivate:\r\n};\r\n\r\nvoid do_smth1(Index1 const& ind)\r\n{\r\n   Index1 ref_ind(ind);\r\n   // got access to all non-const methods\r\n}\r\n```\r\nЕсли же ввести в язык указанную конструкцию, то\r\n\r\n*    не потребуется создавать ConstIndex.\r\n*    получаем const-safe. функция do_smth не сможет создать non-const-объект-ссылку-на-данные и их менять.\r\n\r\nЖду обратной связи.\r\nХотелось бы увидеть помимо плюсов и минусов ваше мнение, понимание и объяснение.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/233/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/233/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/232",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/232/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/232/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/232/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/232",
    "id": 841931589,
    "node_id": "MDU6SXNzdWU4NDE5MzE1ODk=",
    "number": 232,
    "title": "Больше допустимых типов для нетиповых аргументов шаблонов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T12:52:11Z",
    "updated_at": "2021-03-26T12:55:04Z",
    "closed_at": "2021-03-26T12:55:03Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -2\r\n_Автор идеи:_ **ldvsoft**\r\n\r\nПредлагаю разрешить передавать в качестве нетиповых параметров шаблонов большее множество типов, например POD от допустимых типов (включая так или иначе std::tuple, std::pair), а также некоторые типы из стандартной библиотеки (std::optional от допустимых типов).\r\n\r\nПричины: мы и так уже можем передавать в шаблон несколько значений по отдельности. Почему нельзя передавать некоторую логично их объединяющую структуру, имеющую всю необходимую семантику (скажем, constexpr-конструкторы, операторы равенства и прочее)? Мы и так уже можем написать два шаблона (один с аргументом, другой без него); а также писать constexpr if. Мы могли бы писать один шаблон с constexpr-if на наличие значения в std::optional?\r\n\r\nВозможно это потребует введения каких-то правил, trait-ов для описания, какие типы допустимы. Мне кажется можно обойтись и относительно небольшим расширением доступных типов.\r\n\r\nЕдинственными препятствием я вижу манглинг, но он должен быть отдан на решение компиляторам, которые могут хранить хоть байтовое представление значения; а также необходимость компилятору в момент компиляции выполнения constexpr-кода в выводе типов, но компиляторы и сейчас выполняют эти вычисления, но только на целочисленных типах и аналогичных.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/232/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/232/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/231",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/231/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/231/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/231/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/231",
    "id": 841929384,
    "node_id": "MDU6SXNzdWU4NDE5MjkzODQ=",
    "number": 231,
    "title": "memory_traits спецификатор для allocator ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T12:49:05Z",
    "updated_at": "2021-03-26T12:51:18Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -3\r\n_Автор идеи:_ **Victor Gubin**\r\n\r\nМотивация. STL контейнеры позволяют определить собственный распределитель памяти, и принимают std::allocator в качестве параметра по умолчанию.\r\nЕсли нужно использовать распределитель памяти, отличный от используемого std::allocator - следует реализовать собственный шаблон Allocator, как правило путем копирования кода std::allocator и внесением незначительных (в объеме кода) изменений.\r\n\r\nВ большинстве случаев создание не стандартной реализации шаблона allocator, связанно с необходимостью заменить вызовы к базовом операторам new и delete. Это необходимо для замены универсального алгоритма распределения памяти используемого стандартной библиотекой, и не подходящего для конкретного случая. При этом глобально переопределять std::new и std::delete нежелательно.\r\n\r\nВ тоже время, шаблон allocator весьма сложный класс, и все STL контейнеры требуют четкого соблюдения интерфейса Allocator от любой не стандартной реализации. Таким образом, для замены обращений к стандартному распределителю памяти, на более подходящий для конкретного контейнера, нужно посути продублировать код std::allocator в собственной реализации, изменив всего несколько строк кода.\r\n\r\nКонцепция memory_traits\r\n\r\nmemory_traits это небольшой proxy интерфейс над базовым распределителем памяти, который просто реализуем и может быть передан базовому шаблону allocator.\r\n\r\nНапример для  обращения к глобальным операторам new и delete memory_traits будет выглядеть следующим образом\r\n```cpp\r\nstruct memory_traits {\r\n\r\n\tstatic void* allocate(std::size_t count) {\r\n\t\treturn ::operator new( count );\r\n\t}\r\n\r\n\tstatic void* allocate(std::size_t size, const std::nothrow_t&) noexcept\r\n\t{\r\n\t\treturn ::operator new( size, std::nothrow );\r\n\t}\r\n\r\n\tstatic void release(void* const ptr) noexcept\r\n\t{\r\n\t\t::operator delete( ptr );\r\n\t}\r\n\r\n};\r\n```\r\n\r\n\r\nТогда в стандартной библиотеке можно ввести следующий шаблон\r\n```cpp\r\ntemplate<typename T, typename MemoryTraits >\r\nclass basic_allocator {\r\n\ttypedef MemoryTraits memory_traits_type;\r\n....\r\n\tpointer allocate(size_type __n, const void* = 0) {\r\n\t\t....\r\n\t\tpointer *ptr = memory_traits_type::allocate( _n );\r\n\t\t....\r\n\t}\r\n...\r\n\t// rest \r\n};\r\n```\r\n\r\n\r\nИ спецификацию std::allocator можно определить как  ( если это нужно ).\r\n```cpp\r\ntemplate<typename T>\r\nclass allocator: public basic_allocator <T, memory_traits> {\r\n\ttypedef std::size_t size_type;\r\n\ttypedef ptrdiff_t difference_type;\r\n\ttypedef T* pointer;\r\n\ttypedef const T* const_pointer;\r\n\ttypedef T&  reference;\r\n\ttypedef const T& const_reference;\r\n\ttypedef T value_type;\r\n\r\n\ttemplate<typename T1>\r\n\tstruct rebind {\r\n\t\ttypedef allocator<T1> other;\r\n\t};\r\n\t\r\n\tconstexpr allocator() noexcept:\r\n\t\tbasic_allocator<T, memory_traits>()\r\n\t{}\r\n\r\n\tconstexpr allocator(const allocator& other) noexcept:\r\n\t\theap_allocator_base<T, memory_traits>( other )\r\n\t{}\r\n\r\n\ttemplate<typename _Tp1>\r\n\tconstexpr allocator(const allocator<_Tp1>& other) noexcept\r\n\t{}\r\n\r\n\t~allocator() noexcept = default;\r\n};\r\n```\r\n\r\n\r\nТаким образом, можно легко заменять std::allocator для любого контейнера, потребуется только реализовать memory_traits и передать его шаблону std::basic_allocator.\r\n\r\n Например:\r\n\r\n\r\n\r\nВведение memory_traits и std::basic_allocator затронут уже существующий код. Но определить Allocator для конкретного контейнера станет намного проще.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/231/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/231/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/230",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/230/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/230/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/230/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/230",
    "id": 841927176,
    "node_id": "MDU6SXNzdWU4NDE5MjcxNzY=",
    "number": 230,
    "title": "Проблемы при использовании сопрограмм",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T12:46:02Z",
    "updated_at": "2021-03-26T12:47:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -0\r\n_Автор идеи:_ **grigory.demchenko**\r\n\r\nВ новом стандарте планируется использовать stackless сопрограммы. Проблема с ними в том, что они заставляют использовать ключевое co_async, изменяя возвращаемый тип с T на future. Однако не у всех методов есть возвращаемые типы. Например, нельзя в конструкторе и деструкторе объектов вызывать co_await, т.к. комплятор не может вызывать асинхронно конструктор и деструктор.\r\nТакие действия бывают полезны для RAII объектов типа unique_lock, portal и др.\r\n\r\n```cpp\r\nvoid synchronized()\r\n{\r\n    std::unique_lock<async_mutex> lock;\r\n    myAction();\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/230/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/230/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/229",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/229/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/229/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/229/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/229",
    "id": 841924976,
    "node_id": "MDU6SXNzdWU4NDE5MjQ5NzY=",
    "number": 229,
    "title": "Complie-time коллекция всех значений enum'a",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T12:42:55Z",
    "updated_at": "2021-03-26T12:45:07Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -3\r\n_Автор идеи:_ **Антон Паймышев**\r\n\r\nБыло бы неплохо если бы была возможность во время компиляции получить std::array(?) со всеми значиями enum'a\r\n```cpp\r\nenum class Color\r\n{\r\n\tRed, Green, Blue\r\n};\r\n\r\nvoid f()\r\n{\r\n\tstatic_assert(std::foo<Color>().size() == 3);\r\n\tstatic_assert(std::foo<Color>()[0] == Color::Red);\r\n\tstatic_assert(std::foo<Color>()[1] == Color::Green);\r\n\tstatic_assert(std::foo<Color>()[2] == Color::Blue);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/229/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/229/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/228",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/228/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/228/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/228/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/228",
    "id": 841740495,
    "node_id": "MDU6SXNzdWU4NDE3NDA0OTU=",
    "number": 228,
    "title": "векторные инструкции в стандартной библиотеке",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T09:03:34Z",
    "updated_at": "2021-03-26T09:05:20Z",
    "closed_at": "2021-03-26T09:05:14Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -2\r\n_Автор идеи:_ **Дмитрий Назаров**\r\n\r\nДобавить возможность явного использования векторных инструкций на тех платформах, где они поддерживаются, программная эмуляция - на остальных. \r\n\r\nВ настоящее время на множестве платформ доступны векторные инструкции для сложения, вычитания, умножения и т.д. В ряде компиляторов (gcc, clang, msvc) уже имеются соответствующие расширения для работы с такими инструкциями.\r\n```cpp\r\n// пример из документации на gcc\r\ntypedef int v4si __attribute__ ((vector_size (16)));\r\n\r\nv4si a, b, c;\r\n\r\nc = a + b;\r\n```\r\nБыло бы неплохо иметь в стандарте соответствующие функции для работы с этими расширениями. С одной стороны, компиляторы и так в праве использовать их при оптимизации кода. С другой - применение таких функций будет дополнительной подсказкой компилятору о намерениях разработчика. На платформах, которые не поддерживают векторные расширения, можно использовать программную эмуляцию в виде цикла. В стандарте уже применяется аналогичный подход с эмуляцией std::atomic через использование мьютексов. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/228/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/228/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/227",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/227/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/227/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/227/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/227",
    "id": 841738705,
    "node_id": "MDU6SXNzdWU4NDE3Mzg3MDU=",
    "number": 227,
    "title": "Тип данных для строк UTF-8 ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T09:01:04Z",
    "updated_at": "2021-03-26T09:01:39Z",
    "closed_at": "2021-03-26T09:01:29Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -3\r\n_Автор идеи:_ **Victor Gubin**\r\n\r\nВести тип данных для поддержки UNICODE строк с переменной длинной символа на уровне компилятора.\r\n\r\n## Мотивация\r\n\r\nВ текущем стандарте строковый тип данных, это попросту массив байтов памяти.  Все операции по работе с строками перекладываются\r\nна плечи программиста или бибилиотек. При этом в большинстве случаев работа с строками с переменной длинны символа\r\n может быть реализованна на уровне языка и комилятора.\r\n\r\nНа уровне языка можно ввести тип данных ustring, для которого выполняются следующие условия.\r\n\r\nТип - всегда указалель на область памяти\r\n```cpp\r\nustring LOREM = u8\"Lorem ipsum\";\r\n```\r\nu8\"String\" Единсвенный способ задать значение из литерала,\r\n\"Lorem ipsum\" (не факт что UTF-8),  L\"Lorem ipsum\", u\"Lorem ipsum\", U\"Lorem ipsum\"  - ошибка компиляции.\r\n\r\nРазрешаются только следующиее операторы:\r\n\r\nИнткементация: ++a/a++  переводит указатель на следующий символ т.е. на 1/2/3/4 байта вперед в зависимости от текущего значения.\r\nЕсли указетель выходит за границы строки ('\\0'), то значение адреса сводится к nullptr.\r\n\r\nАдресный +\r\n```cpp\r\nustring LOREM = u8\"Lorem ipsum\";\r\n\r\nustring a = LOREM + 2;\r\n\r\nэкивалент for(ustring a = LOREM, size_t i=0; i < 2; ++i, ++a);\r\n\r\nustring a = (LOREM + 13); // nullptr и ошибка компиляции для литералов.\r\n```\r\nВзятиие адреса:\r\n```cpp\r\nustring LOREM = u8\"Lorem ipsum\";\r\n\r\nchar32 b = *LOREM;\r\n\r\n*LOREM = U'l';\r\n```\r\nразрешается только сведение к типу символа достаточно широкому для хранения полного UNICODE значения т.е. минимум 4-ре байта,\r\n(char32, int, uint32_t и т.п.). И присвоение значения от типа не более чем 4-ре байта длинной.\r\n\r\nКомпилятор гененирует код для коддирования/де-коддирования символов в UTF-8/UTF-32\r\n\r\nОператор string_cast\r\n```cpp\r\nustring u8str = string_cast(U\"Lorem ipsum\"); \r\n\r\nchar16_t u16str[] = string_cast(u8str);\r\n\r\nchar32_t u32str[] = string_cast(u32str);\r\n```\r\nКомпилятор генерирует код для преобразования между представлениями UNICODE строк (или конвертирует строки на этапе компиляции, для литералов). Для локальных переменных функций память выделяется на стеке\r\nесли размер исходной строки заранее известен компилятору.     \r\n\r\nДля совместимости с С функцими, допускатется\r\n```cpp\r\nustring u8str = u8\"Lorem ipsum\";\r\n\r\nconst char* c_str = static_cast<const char*>(u8str);\r\n```\r\nА так-же допускается прямое приведение типа из указателя на другой тип данных, c указанием размера памяти в байтах т.е. например:\r\n```cpp\r\nvoid *rdbuf = std::calloc(1024, 1); std::fread(rdbuf, 1, 1024, fd);\r\n\r\nconst ustring u8str = string_cast( rdbuf, 1024);\r\n```\r\nПоведение delete [] u8str при этом не опеределено, поэтому компилятор явно генерирует ошибку при delete [] u8str\r\n\r\nВыделение динамической пямяти:\r\n```cpp\r\nustring a = new ustring [16]; // выделяет аналогично new char32_t[16]\r\n```\r\nособождение строго по delete [] a;\r\n\r\nsizeof\r\n\r\nЕсли ustring s = u8\"Lorem ipsum\";\r\n\r\nтогда:\r\n\r\nsizeof(s)  - тоже что sizeof(void*) \r\n\r\nsizeof(&s) - длина строки в символах \r\n\r\nsizeof(*s) - дилина символа в байтах 1/2/3/4\r\n\r\nsizeof(&&s) - кол-во памяти занятое строкой в памяти в байтах",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/227/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/227/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/226",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/226/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/226/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/226/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/226",
    "id": 841736932,
    "node_id": "MDU6SXNzdWU4NDE3MzY5MzI=",
    "number": 226,
    "title": "Пул потоков в стандартной библиотеке",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:58:40Z",
    "updated_at": "2021-03-26T08:59:07Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +18, -0\r\n_Автор идеи:_ **Osmironov**\r\n\r\n\r\nНа сегодняшний момент в std существует класс, позволяющий создавать новые потоки выполнения - std::thread, однако отсутствует реализация пула потоков, который мог бы работать с целой очередью задач, балансируя нагрузку между потоками. Я не считаю себя крупным специалистом в C++, однако, на сколько я знаю, реализации такого пула содержатся в библиотеке tbb, в библиотеках ОС QNX, в множестве open-source проектов. Почему бы не внести одну из них (или несколько) в стандарт?\r\n\r\nP.S. возможно, над таким предложением уже работают, прошу меня простить в этом случае. Повторюсь, что не являюсь крупным профессионалом.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/226/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/226/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/225",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/225/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/225/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/225/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/225",
    "id": 841736027,
    "node_id": "MDU6SXNzdWU4NDE3MzYwMjc=",
    "number": 225,
    "title": "constexpr std::hash",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:57:20Z",
    "updated_at": "2021-04-06T19:10:22Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +25, -0\r\n_Автор идеи:_ **Дмитрий Назаров**\r\n\r\n\r\nОпределить operator() в std::hash как constexpr. Добавить стандартные реализации для std::hash для массивов базовых типов.\r\n\r\nВ некоторых ситуациях было бы полезно уметь вычислять хэш на этапе компиляции. Например, для строковых литералов сигнатура могла бы выглядеть как-нибудь вот так.\r\n```cpp\r\ntemplate<size_t _Size>\r\nstruct hash<char const (&)[_Size]>\r\n{\r\n    constexpr hash() = default;\r\n\r\n    using _S = char const [_Size];\r\n    constexpr std::size_t operator()(_S &str) const noexcept\r\n    {\r\n        return constexpr_implementation(str, _Size); // релизация компилятором того или иного алгоритма\r\n    }\r\n};\r\n```\r\nПреемущества - возможность использования результата везде, где можно использовать constexpt. Например, в switch конструкции.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/225/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/225/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/224",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/224/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/224/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/224/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/224",
    "id": 841735101,
    "node_id": "MDU6SXNzdWU4NDE3MzUxMDE=",
    "number": 224,
    "title": "Спецификация типа данных обязывающая использовать значение",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:55:58Z",
    "updated_at": "2021-03-26T08:56:26Z",
    "closed_at": "2021-03-26T08:56:26Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **Sergey Kovalev**\r\n\r\n```cpp\r\ntypedef __value_must_be_used int error_code;\r\n\r\nerror_code foo();\r\n\r\nfoo(); // compile error: value must be used\r\nif (int err=foo()) { analyze(err); } // ok\r\n```\r\n\r\nПочему бы не добавить спецификатор который запрещает не использовать возвращаемый результат.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/224/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/224/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/223",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/223/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/223/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/223/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/223",
    "id": 841734167,
    "node_id": "MDU6SXNzdWU4NDE3MzQxNjc=",
    "number": 223,
    "title": "piecewise_construct для кортежей",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:54:35Z",
    "updated_at": "2021-03-26T08:55:02Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Sergey K**\r\n\r\n\r\n\r\nХотелось бы сконструировать кортеж, элементы которого не copy-constructible, не move-constructible и не имеют конструктора с одним аргументом или конструктора по умолчанию.\r\n\r\nУ пары (std::pair) есть конструктор для поэлементного конструирования. Первым аргументом он принимает плейсхолдер std::piecewise_construct, а двумя последующими аргументами - кортежи из любого количества элементов. Каждый кортеж разбирается на элементы, которые передаются в конструктор соответствующего элемента пары как список аргументов (ожидается, что элемент пары имеет соответствующий конструктор). Кортеж является естественным обобщением пары, поэтому хотелось бы видеть такой конструктор и для кортежей.\r\n\r\nПример:\r\n```cpp\r\nstruct Foo {\r\n\tFoo(const Foo&) = delete;\r\n\tFoo(Foo&&) = delete;\r\n\tFoo& operator=(const Foo&) = delete;\r\n\tFoo& operator=(Foo&&) = delete;\r\n\t/* Единственный способ создания структуры -\r\n\t * конструктор с более чем одним аргументом.\r\n\t */\r\n\tFoo(int, float) {}\r\n};\r\n\r\nint main()\r\n{\r\n\tint a = 1;\r\n\tfloat b = 3.14f;\r\n\tstd::pair<Foo, Foo> fooPair(std::piecewise_construct, std::tie(a, b), std::tie(a, b)); // ОК\r\n\tstd::tuple<Foo> fooTuple(std::piecewise_construct, std::tie(a, b)); // Ошибка - нет такого конструктора у кортежа\r\n}\r\n```\r\nЕщё один возможный вариант использования - создание кортежа с раскрытием списка шаблонных параметров, которое делается через раскрытие sizeof и оператора \"запятая\":\r\n\r\nhttps://stackoverflow.com/questions/22560100/how-to-initialize-all-tuple-elements-by-the-same-arguments\r\n```cpp\r\ntemplate <typename... TElements>\r\nstruct Container {\r\n    // Некорректный код из ответа на SO. Нет такого конструктора.\r\n    Container(Foo foo, Bar bar)\r\n        : tuple(std::piecewise_construct, (sizeof(TElements), std::tie(foo, bar))...)\r\n    {}\r\n    std::tuple<TElements...> tuple;\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/223/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/222",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/222/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/222/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/222/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/222",
    "id": 841732967,
    "node_id": "MDU6SXNzdWU4NDE3MzI5Njc=",
    "number": 222,
    "title": "Ослабить требование к второму аргументу в static_assert",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      },
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T08:52:51Z",
    "updated_at": "2023-10-22T10:31:52Z",
    "closed_at": "2023-10-22T10:31:44Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +43, -0\r\n_Автор идеи:_ **smertigdon**\r\n\r\n\r\n\r\nТекущая версия стандарта требует, чтобы второй аргумент static_assert'а являлся string literal, что не позволяет использовать в нём constexpr char*\r\n\r\n\r\nПри написании библиотек/вспомогательных шаблонных классов разработчики часто используют static_assert для контроля входных данных и промежуточных результатов. Однако сообщения, выдаваемые при нарушении обязательств, должны быть строковыми литералами. Так как сама проверка может происходить где-то в недрах библиотеки, то и выдать универсальное понятное сообщение не всегда представляется возможным. \r\n\r\nПредложение состоит в том, чтобы разрешить использование constexpr char* значений в качестве второго аргумента static_assert. Это позволит писать код с более информативными сообщениями об ошибках времени компиляции.\r\n\r\nПредставим старый код:\r\n```cpp\r\n#include <type_traits>\r\n#include <string>\r\n\r\ntemplate <class... Args>\r\nclass foo {\r\n  static_assert(std::conjunction_v<std::is_pod<Args>...>, \"All args must be pod!\");\r\n};\r\n\r\nint main() {\r\n\tfoo<int, std::string, float> f;\r\n}\r\n```\r\nСообщение об ошибке будет соответствующим. А теперь представим, что каждый из аргументов - это синоним типа и их более десятка. И какой-то из них после очередного рефакторинга перестал быть POD. На поиск источника проблемы уйдёт драгоценное время.\r\n\r\nА теперь новый код, если предложение примут:\r\n```cpp\r\ntemplate <class... Args>\r\nclass foo {\r\n  static_assert(std::conjunction_v<std::is_pod<Args>...>, compile_time_joiner(\"All args must be pod, but \", type_name<find_non_pod<Args...>>, \" isn't\"));\r\n};\r\n```\r\nПреимущество очевидно. На данный момент существует несколько реализаций compile-time строк, множество алгоритмов для работы с типами, поэтому реализация compile_time_joiner, type_name<..> и find_non_pod<...> - не проблема. С учётом того, что идёт активная работа над рефлексией, то упростится и работа с типами. Там подоспеет и аналог sprintf времени компиляции. А раз у нас будет более удобное метапрограммирование, значит нужны и информативные сообщения об ошибках!",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/222/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/222/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/221",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/221/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/221/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/221/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/221",
    "id": 841704238,
    "node_id": "MDU6SXNzdWU4NDE3MDQyMzg=",
    "number": 221,
    "title": "Сделать операторы сравнения контейнеров независимыми от типа аллокатора",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:12:47Z",
    "updated_at": "2021-04-06T19:09:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +27, -1\r\n_Автор идеи:_ **smertigdon**\r\n\r\n\r\nТекущая реализация операторов сравнения не позволяет работать с объектами классов-контейнеров из STL с различными аллокаторами. Нужно исправить такое недоразумение.\r\n\r\nМотивация следующая. Следующий код не будет компилироваться \r\n```cpp\r\n#include <memory>\r\n#include <vector>\r\n \r\ntemplate <class T>\r\nstruct custom_allocator : std::allocator<T> {};\r\n \r\nint main() {\r\n\tstd::vector<int, std::allocator<int>> a;\r\n\tstd::vector<int, custom_allocator<int>> b;\r\n\ta == b; // compilation error, no match for 'operator=='\r\n\treturn 0;\r\n}\r\n```\r\nПричина очевидна - оператор сравнения определён лишь для объектов идентичных типов, что включает в себя и типы аллокаторов. Однако сам аллокатор не влияет на внутреннюю структуру контейнера и, следовательно, не должен влиять на логику различных операций над контейнером, которые его не меняют (точнее, на более широкий класс - которые не вызывают выделения памяти).\r\n\r\nПредложение следующее - заменить сигнатуру операторов сравнения с \r\n```cpp\r\ntemplate <class T, class Allocator>\r\nbool operator==(const std::vector<T, Allocator>& lhs, const std::vector<T, Allocator>& rhs) { ... }\r\n```\r\nна\r\n```cpp\r\ntemplate <class T, class Allocator1, class Allocator2>\r\nbool operator==(const std::vector<T, Allocator1>& lhs, const std::vector<T, Allocator2>& rhs) { ... }\r\n```\r\nАналогично для всех прочих операторов сравнения, а также для всех контейнеров. \r\n\r\nОбратную совместимость это не ломает, зато немного упрощает жизнь разработчику.\r\n\r\n \r\n\r\nP.S. Есть ощущение, что данную идею можно развить и дальше, например, на конструкторы копирования, операторы присваивания (не учитывая их перемещающие аналоги). Возможно, стоит обдумать какую-то концепцию, которая позволит вырезать тип аллокатора из типа-контейнера и оперировать универсальным образом везде, где не происходит перераспределения памяти.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/221/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/221/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/220",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/220/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/220/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/220/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/220",
    "id": 841701702,
    "node_id": "MDU6SXNzdWU4NDE3MDE3MDI=",
    "number": 220,
    "title": "Добавить constexpr к __func__",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T08:09:02Z",
    "updated_at": "2021-03-27T18:59:47Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +15, -1\r\n_Автор идеи:_ **WPMGPRoSToTeMa**\r\n\r\nВ текущем виде __func__ нельзя использовать в constexpr выражениях.\r\n\r\nИмя функции известно во время компиляции, так что логично, чтобы его можно было использовать в constexpr выражениях.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/220/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/220/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/219",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/219/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/219/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/219/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/219",
    "id": 841700261,
    "node_id": "MDU6SXNzdWU4NDE3MDAyNjE=",
    "number": 219,
    "title": "Исправить внутренний тип переменной при захвате константной ссылки по значению в лямбдах",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:06:56Z",
    "updated_at": "2021-03-26T08:08:05Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -5\r\n_Автор идеи:_ **Антон**\r\n\r\nСейчас при захвате константной ссылки (например const int &) по значению в лямбде получаем const (const int) переменную даже в случае mutable лямбды.\r\n\r\nИмеем\r\n\r\nint i = 0;\r\nconst int &j = i;\r\n\r\nСледующий код не компилируется в силу того, что лямбда не mutable (j внутри лямбды имеет тип const int) и это выглядит естественно.\r\n```cpp\r\n[j]()\r\n{\r\n    j = 1;\r\n}();\r\n```\r\nСледующий код тоже не компилируется, хотя мы явно указываем спецификатор mutable, (j внутри лямбды по-прежнему имеет тип const int).\r\n```cpp\r\n[j]() mutable\r\n{\r\n    j = 1;\r\n}();\r\n```\r\nКомпилируется только код с явным указанием копии:\r\n```cpp\r\n[j = j]() mutable\r\n{\r\n    j = 1;\r\n}();\r\n```\r\nБыло бы логичнее если mutable отменял const спецификаторы для всех внутренних переменных лямбды в любом случае.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/219/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/219/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/218",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/218/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/218/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/218/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/218",
    "id": 841698967,
    "node_id": "MDU6SXNzdWU4NDE2OTg5Njc=",
    "number": 218,
    "title": "File mapping and shared memory in C++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:05:09Z",
    "updated_at": "2021-03-26T08:05:27Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +19, -0\r\n_Автор идеи:_ **zamazan4ik@tut.by** @ZaMaZaN4iK\r\n\r\nЗдравствуйте.\r\n\r\nПредлагаю на рассмотрение идею добавления в Стандарт поддержки file mapping и разделяемой памяти в Стандарт. Мой пропозал является переработкой пропозала от Ion Gaztanaga (автора Boost.Interprocess) и основывается на реализации этих вещей в Boost.Interprocess.\r\n\r\nТакже есть альтернативное предложение от автора Boost.AFIO насчёт маппинга файлов.\r\n\r\n \r\n\r\nСо всеми этими вещами рекомендую ознакомиться по данной ссылке: Google Groups\r\n\r\n \r\n\r\nP.S. Если Вы интересуетесь вещами, которые пытаются втянуть в Стандарт, то посещайте данную гугл группу (может даже стоит на stdcpp.ru ссылку перманентную где-то оставить).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/218/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/218/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/217",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/217/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/217/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/217/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/217",
    "id": 841696638,
    "node_id": "MDU6SXNzdWU4NDE2OTY2Mzg=",
    "number": 217,
    "title": "Дедукция Deleter параметра std::unique_ptr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T08:01:53Z",
    "updated_at": "2021-03-26T08:02:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -1\r\n_Автор идеи:_ **Yaroslav**\r\n\r\nЭто моя первая заметка по языку С++, не судите строго.\r\nНедавно обнаружил некоторое различие в дедукции std::shared_ptr и std::unique_ptr\r\n\r\nВ отличае от\r\n```cpp\r\n    auto shBuf = std::shared_ptr<char>(\r\n                    static_cast<char*>(\r\n                            std::calloc(\r\n                                    BUFSIZE, \r\n                                    sizeof(char)\r\n                            )\r\n                    ),  \r\n                    std::free\r\n            ); \r\n```\r\nне компилируется\r\n```cpp\r\n    auto upBuf = std::unique_ptr<char, decltype(deleter)>(\r\n                    static_cast<char*>(\r\n                            std::calloc(\r\n                                    BUFSIZE, \r\n                                    sizeof(char)\r\n                            )\r\n                    ),\r\n                    std::free\r\n            );\r\n```\r\nдля компиляции необзодим хак вида:\r\n```cpp\r\n    auto deleter = [](char *ptr)\r\n            {              \r\n                    std::free(ptr);\r\n            };             \r\n                           \r\n            auto upBuf = std::unique_ptr<char, decltype(deleter)>(\r\n                    static_cast<char*>(\r\n                            std::calloc(\r\n                                    BUFSIZE,\r\n                                    sizeof(char)\r\n                            )\r\n                    ),     \r\n                    deleter                                                                          \r\n            ); \r\n```\r\nПолагаю, что данную неточность стоит пофиксить. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/217/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/216",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/216/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/216/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/216/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/216",
    "id": 841695340,
    "node_id": "MDU6SXNzdWU4NDE2OTUzNDA=",
    "number": 216,
    "title": "Пропуск полей в объявлении structured bindings",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T08:00:04Z",
    "updated_at": "2023-10-22T10:34:31Z",
    "closed_at": "2023-10-22T10:34:25Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -3\r\n_Автор идеи:_ **Sergey K**\r\n\r\nХотелось бы иметь возможность инициализировать подмножество значений в объявлении structured bindings.\r\n\r\nС++17 позволяет разобрать массив, кортеж или структуру на именованные элементы вот таким образом:\r\n```cpp\r\nauto foo(int x, int y)\r\n{\r\n    // ...whatever...\r\n    return std::make_tuple(/*четыре элемента*/);\r\n}\r\n\r\nauto [a, b, c, d] = foo(2, 3);\r\n```\r\nА что если b никогда не будет использоваться? Было бы полезно пропустить одно или несколько полей в structured binding declaration, например так:\r\n```cpp\r\nauto [a, _, c, d] = foo(2, 3);\r\n```\r\nили так:\r\n```cpp\r\nauto [a, void, c, d] = foo(2, 3);\r\n```\r\nОба этих примера несовершенны. В первом случае _ является валидным идентификатором и не подходит на роль плейсхолдера для игнорирования значения. Во втором же случае название типа стоит на месте идентификатора, что выглядит неоднородно и может вызвать замешательство при первых ознакомлениях с таким синтаксисом.\r\n\r\nВозникает несколько вопросов:\r\n1) Нужна ли вообще такая функциональность?\r\n2) Если нужна, то каким должен быть синтаксис? Уместен ли вариант с void? Ваши предложения?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/216/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/216/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/215",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/215/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/215/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/215/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/215",
    "id": 841694379,
    "node_id": "MDU6SXNzdWU4NDE2OTQzNzk=",
    "number": 215,
    "title": "Возможность изпользовать std::make_shared с приватными конструкторами и фабричными методами",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T07:58:35Z",
    "updated_at": "2021-03-26T07:58:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -5\r\n_Автор идеи:_ **fgenatre**\r\n\r\nВ нынешнем виде std::make_shared<>() не позволяет конструировать объекты с приватным конструктором даже при вызове из подходящего контекста (разве что только с некоторыми ухищрениями, типа наследования пустого производного класса и создания его экземпляра или объявлении вызываемой функции как friend для создаваемого класса).\r\nМежду тем, на текущий момент не видно каких-либо серьезных преград разрешить использование std::make_shared<>() для объектов с приватными конструкторами.\r\n\r\nstd::make_shared<>() имеет ряд преимуществ перед обычным конструированием std::shared_ptr - к примеру, память и выделяется за один раз, а не за два (согласно рекомендации в стандарте),  и сам объект и счетчик ссылок на него распалагаются в куче рядом (что в некоторых случаях может дать небольшой плюс в плане оптимизации).\r\nВ нынешнем виде std::make_shared<>() не позволяет конструировать объекты с приватным конструктором даже при вызове из подходящего контекста (разве что только с некоторыми ухищрениями, типа наследования пустого производного класса и создания его экземпляра или объявлении вызываемой функции как friend для создаваемого класса).\r\nМежду тем,  на текущий момент не видно каких-либо серьезных преград разрешить использование std::make_shared<>() для объектов с приватными конструкторами - компилятору понадобится просто определить допустимость подобной операции в зависимости от контекста вызова (как сейчас при обычном создании shared_ptr).\r\n\r\nБонусом можно еще разрешить использовать make_shared<>() с фабричными методами, возвращающими сырой указатель (типа SomeObject* SomeObject::create(), например при использовании сторонних библиотек) - только там заранее неизвестно какой объект вернется (может быть сконструирован объект одного из унаследованных классов), следовательно, заранее память не аллоцируешь, и  как вариант, компилятор может генерировать вариант фабричного метода, в котором вместо 'new' будет вызываться make_shared, и сконструированный умный указатель будет передаваться в вызываюшую функцию\r\n\r\nПлюсы: упрощение кода и улучшение читаемости.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/215/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/215/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/214",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/214/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/214/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/214/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/214",
    "id": 841693479,
    "node_id": "MDU6SXNzdWU4NDE2OTM0Nzk=",
    "number": 214,
    "title": "Неявный return в конце функции",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T07:57:17Z",
    "updated_at": "2022-08-11T18:49:42Z",
    "closed_at": "2022-08-11T18:49:41Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -28\r\n_Автор идеи:_ **Antervis**\r\n\r\nПредлагаю ослабить требование к синтаксису функций, а именно: убрать требование к наличию ключевого слова return в её конце.\r\n```cpp\r\n// Есть\r\nint func(int a) {\r\n    return a*5; \r\n}\r\n\r\n// Предложение:\r\nint func(int a) {\r\n    a*5; \r\n}\r\n```\r\nДалее по тексту rv - возвращаемое значение\r\n\r\nТребования: rv последнего оператора функции неявно преобразуется в rv функции. последний оператор не имеет побочных эффектов.\r\n\r\nПодробнее по поводу второго:\r\n```cpp\r\nauto func(int i) {\r\n    i *= 5; // func вернет int(i*5). Сейчас это warning: statement has no effect\r\n}\r\n\r\n\r\nauto func(int &i) {\r\n    i *= 5; // side effect - мутирующий доступ: func вернет void\r\n}\r\n\r\nauto func = [&i] { i *= 5; } // side effect - мутирующий доступ: func вернет void\r\n```\r\nВлияние на существующий код: для ситуаций, когда тип rv функции указан явно, изменение будет безвредным - в нынешнем стандарте это UB. Требование к отсутствию побочных эффектов разрешает возможную проблемную ситуацию со сменой типа rv для шаблонных функций и замыканий.\r\n\r\n \r\n\r\nДля чего это всё: можно писать более короткие лямбды:\r\n```cpp\r\n[](auto x) { x > 5; }\r\n```\r\nВ дополнение также можно убрать требование к наличию ; у последнего оператора добавить неявный auto аргументам лямбд:\r\n```cpp\r\n[](x) { x > 5 };\r\n```\r\nПодобное поведение сейчас есть в других яп, том же Rust",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/214/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/214/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/213",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/213/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/213/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/213/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/213",
    "id": 841692280,
    "node_id": "MDU6SXNzdWU4NDE2OTIyODA=",
    "number": 213,
    "title": "Добавить в std::memory_resource функцию inner_resource",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T07:55:37Z",
    "updated_at": "2021-03-26T07:55:58Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -0\r\n_Автор идеи:_ **ru.night.beast**\r\n\r\nРасширить std::memory_resource функционалом из std::scoped_allocator_adaptor.\r\n\r\nДля организации различных стратегий аллокации при использовании вложенных контейнеров предлагаю добавить в std::memory_resource функцию \r\n```cpp\r\nstd::memory_resource* inner_resource() noexept { return get_inner_resource(); }\r\n\r\nvirtual std::memory_resource* inner_resource() noexept { return this; }\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/213/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/213/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/212",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/212/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/212/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/212/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/212",
    "id": 841691299,
    "node_id": "MDU6SXNzdWU4NDE2OTEyOTk=",
    "number": 212,
    "title": "Использовать вложенные библиотеки вместо std2.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T07:54:08Z",
    "updated_at": "2021-03-26T07:54:48Z",
    "closed_at": "2021-03-26T07:54:43Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -1\r\n_Автор идеи:_ **d-yaroshev**\r\n\r\nПосмотрел большую часть обсуждений про std2 на недавнем CppNow. Присутствующие в подавляющем большинстве были в той или иной степени за. Мне кажется что std2 является худшим решением чем использовать вложенные библиотеки (и мне не нравится писать цифру 2).\r\n\r\nЕсть несколько вещей которые хотят, когда говорят про std2.\r\n\r\n- Breaking changes в поведении.\r\n\r\nДо известной степени это не возможно. Мы не можем поправить std::max или std::partition в std2 и научить этому разработчиков. Если что и будет добавлять сложности языку так это дубликаты, которые радикально (или в очень тонких случаях - не знаю что хуже) отличаются в поведении.\r\n\r\nНекоторые из таких изменений можно провернуть, но мне кажется лучше не в std2, в специальных namespace.\r\n\r\nНапример - small optimized vector вполне может жить в отдельном namespace ровно так же как и вектор с полиморфным аллокатором pmr. Мне кажется что std::vector<int, std::sml::allocator<16>> (мб алиас как с pmr, std::sml::vector<int, 16>) сильно менее проблатично для принятия чем std2::vector у которого правила инвалидации итераторов вдруг отличаются от std::vector.\r\n\r\n- Новые библиотеки.\r\n\r\nПервый раз я услышал про std2 от Eric Niebler когда он рассказывал про ranges. Даже если действительно нельзя положить ranges просто в std из-за коллизий имен, преимущество std2 перед std::rng кажется сомнительным. В std уже есть примеры нескольких библиотек, решающих одну и туже задачу - C и C++ способы ввода/вывода например, так что это тоже не кажется очень уж страшным.\r\n\r\n- Breaking changes в интерфейсе.\r\n\r\nТут на самом деле наверное самый большой бонус от std2 который можно было бы получить - маленькие изменения в интерфейсе, который улучшат ваш код но сломают компиляцию в нескольких местах, если их просто так включить. Например возможность навесить concepts на алгоритмы. Но подобные вещи можно делать так же внутри под библиотек. Например std::rng::sort(f, l) может накладывать более жесткие ограничения на f, l так как для пользователя понятно,что это отдельная библиотека, уоторая поставляется вместе со стандартом, но она при этом достаточно не зависима. Ну и в целом, насколько полезны такие поломки.\r\n\r\n- Засилие имен в std.\r\n\r\nВ std очень много имен, которые друг с другом конфликтуют и мешаются. Но с std2 мы скоро окажемся ровно в той же ситуации.\r\n\r\nЕще добавлю, что библиотеки в целом приятнее версионировать чем std, потому что в основном их использование локализировано. Переходить на filesystem2 или rng2 в каких-то отдельных кусочках, кажется легче и вполне может делаться по мере необходимости.\r\n\r\nВывод:\r\nДля того чтобы добавлять новые библиотеки не обязательно добавлять std2. Для избежания коллизий имен можно вполне иметь вложенные в std namespace.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/212/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/211",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/211/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/211/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/211/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/211",
    "id": 841689800,
    "node_id": "MDU6SXNzdWU4NDE2ODk4MDA=",
    "number": 211,
    "title": "Trailing comma everywhere",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T07:52:08Z",
    "updated_at": "2021-03-26T07:53:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -9\r\n_Автор идеи:_ **Anatoly Scheglov**\r\n\r\nДобавить trailing comma везде где это только можно, в т.ч. в mem-initializer-list\r\n\r\nМотивирующий пример:\r\n```cpp\r\nFoo::Foo(Bar bar)\r\n  : a_(bar.a),\r\n    b_(bar.b),\r\n    ...\r\n    m_(bar.m),\r\n#if FEATURE_ENABLED\r\n    n_(bar.n),\r\n    x_(bar.x)\r\n#else\r\n    n_(bar.n)\r\n#endif\r\n{}\r\n```\r\nc trailing comma было бы проще -\r\n```cpp\r\n    n_(bar.n),\r\n#if FEATURE_ENABLED\r\n    x_(bar.x),\r\n#endif\r\n{}\r\n```\r\nТо же самое нужно и в parameter-declaration-list и в других списках.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/211/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/211/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/210",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/210/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/210/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/210/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/210",
    "id": 841679214,
    "node_id": "MDU6SXNzdWU4NDE2NzkyMTQ=",
    "number": 210,
    "title": "Пре-аллоцированный конструктор для контейнеров",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T07:37:03Z",
    "updated_at": "2021-03-26T07:38:23Z",
    "closed_at": "2021-03-26T07:38:16Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -5\r\n_Автор идеи:_ **Лягуха Пепе**\r\n\r\nзаменить std::string s;\r\ns.reserve(500);\r\n\r\nна какую-нибудь 1 строку.\r\n\r\nКонструктор, конструирующий N элементов не подходит (мне часто не надо их создавать прям сразу).\r\n\r\nА вот пре-аллоцировать 1 строчкой бы хотелось.\r\n\r\n \r\n\r\nНапример std::string(std::reserve(N)), или std::string(std::reserve, N);",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/210/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/210/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/209",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/209/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/209/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/209/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/209",
    "id": 841678281,
    "node_id": "MDU6SXNzdWU4NDE2NzgyODE=",
    "number": 209,
    "title": "Добавить Policy Based Data Structures",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-26T07:35:44Z",
    "updated_at": "2021-03-26T07:36:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +15, -1\r\n_Автор идеи:_ **adamant**\r\n\r\nДобавить в стандарт PBDS из SGI STL.\r\n\r\nПо мотивам #166.\r\n\r\n \r\n\r\nВ SGI STL была проделана масштабная работа по описанию и реализации Policy Based Data Structures. Было бы здорово иметь эту вещь в стандарте. \r\n\r\n \r\n\r\n[Мануал](https://gcc.gnu.org/onlinedocs/libstdc++/manual/policy_data_structures.html)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/209/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/209/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/208",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/208/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/208/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/208/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/208",
    "id": 841676323,
    "node_id": "MDU6SXNzdWU4NDE2NzYzMjM=",
    "number": 208,
    "title": "Стандартизировать способ определения размера выделенной памяти.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-26T07:33:07Z",
    "updated_at": "2022-01-27T07:18:58Z",
    "closed_at": "2022-01-27T07:18:46Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -3\r\n_Автор идеи:_ **Дмитрий**\r\n\r\nВ c++ нет стандартного способа определить размер выделенной под массив памяти. Предлагаю исправить это.\r\n\r\nДля Win32 есть _msize:\r\n```\r\nsize_t _msize(void *block);\r\nReturns the size of a heap block.\r\n_msize returns the size of the allocated heap block whose address is block. The block must have been allocated with malloc, calloc, or realloc. The returned size can be larger than the number of bytes originally requested when the block was allocated.\r\n```\r\nОднако стандартного кросплатформенного способа определить размер выделенной под массив памяти нет. Тем не менее, данная величина сохраняется, обычно в 32/64 битах непосредственно перед выделенным блоком, и могла бы использоваться и для иных целей, помимо выполнения delete[]. Предлагаю исправить данную негибкость языка.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/208/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/208/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/207",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/207/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/207/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/207/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/207",
    "id": 839940970,
    "node_id": "MDU6SXNzdWU4Mzk5NDA5NzA=",
    "number": 207,
    "title": "Добавить поддержку упакованных исходных файлов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T17:08:26Z",
    "updated_at": "2021-03-24T17:09:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -11\r\n_Автор идеи:_ **Сергей Ковалёв**\r\n\r\nТак что бы можно было использовать некоторые файлы прямо из архива не распаковывая их\r\n\r\nДобавить поддержку архивов и сжатых файлов компилятору и линковщику, что бы было можно использовать файлы прямо из архива не распаковывая их:\r\n\r\ninclude.zip (внутри тысячи файлов)\r\n\r\nsrc.xz\r\n\r\nlib.tar.bz\r\n\r\nsome.hpp.gz (отдельно ужатый файл)\r\n\r\nЭто позволит уменьшить занимаемые размеры и увеличить скорость работы с библиотеками",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/207/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/207/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/206",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/206/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/206/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/206/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/206",
    "id": 839939281,
    "node_id": "MDU6SXNzdWU4Mzk5MzkyODE=",
    "number": 206,
    "title": "Callable noexcept'ness conversion",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T17:06:20Z",
    "updated_at": "2021-03-24T17:06:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **Antervis**\r\n\r\nДобавить type_traits и функции для преобразования noexcept'ness Callable объектов и их типов\r\n\r\nВ с++17 noexcept - часть типа Callable объекта. Соответственно, возможны ошибки компиляции или более медленные fallback'и (например, в STL) если в функцию, требующую Res(Args...)noexcept пытаться передать Res(Args...). Предлагаю добавить:\r\n\r\n**type_traits:**\r\n\r\n*    add_noexcept, add_noexcept_t - возвращает тип с измененной сигнатурой вызова*\r\n*    remove_noexcept, remove_noexcept_t - по аналогии\r\n\r\n**conversion functions:**\r\n\r\n*    assume_noexcept(Callable f) -> NoexceptCallable - создает обертку над f, с noexcept-версиями operator(). Если f кидает исключение, будет вызван std::terminate.\r\n*    ignore_noexcept(NoexceptCallable f) -> Callable - снимает noexcept'ness с вызова.\r\n*    handle_noexcept(Callable f, ExceptionHandler ...handlers) -> NoexceptCallable - создает обертку над f, с noexcept-версиями operator(). Если f кидает исключение, оно будет поймано и обработано через ExceptionHandler подходящего типа (сигнатура ExceptionHandler - void(Type&&) для catch (Type&&), или void() для catch (...)). Если f кидает исключение другого типа, вызывается std::terminate\r\n\r\nconstexpr /*implementation-defined*/ all_overloads = /*implementation-defined*/; - флаг для указания в качестве шаблонных параметров вышеназванных функций, см. ниже* Для объектов без перегруженного operator(), дополнительные шаблонные параметры указывать не нужно. Иначе, необходимо:\r\n\r\nлибо указать ...Args, с которыми вызывается operator(Args...), и результатом будет объект/тип объекта, одна из перегрузок operator() которого поменяет noexcept'ness\r\n\r\nлибо передать в шаблон all_overloads - вернет объект/тип объекта, все перегрузки operator() которого поменяют noexcept'ness\r\n\r\n \r\n\r\nВроде как всё это реализуемо в рамках c++17. Разве что all_overloads версии через шаблонную рекурсию",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/206/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/206/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/205",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/205/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/205/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/205/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/205",
    "id": 839931784,
    "node_id": "MDU6SXNzdWU4Mzk5MzE3ODQ=",
    "number": 205,
    "title": "Null-coalescing оператор ?? и Null-conditional оператор ?->",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T16:57:39Z",
    "updated_at": "2021-03-24T16:59:06Z",
    "closed_at": "2021-03-24T16:58:55Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -11\r\n_Автор идеи:_ **x4mmm**\r\n\r\nБинарный оператор ?? возвращает левый аргумент, если он не nullptr и правый в остальных случаях.\r\nОператор ?-> производит обращение к члену класса указателя, если указатель не nullptr, иначе отменяет текущий оператор (statement).\r\n\r\nNull-coalescing позволяет, например, такую контрукцию\r\n```\r\nabstract class SomeProlificInterface {public: abstract void SomeSuspiciosCall()}\r\n\r\nclass AllowedInterface1: SomeProlificInterface {...}\r\n\r\nclass AllowedInterface2: SomeProlificInterface {...}\r\n\r\nclass DisallowedInterface1: SomeProlificInterface {...}\r\n\r\nclass DisallowedInterface2: SomeProlificInterface {...}\r\n\r\n \r\n\r\nauto o = AquireSomeProlificInterface();\r\n\r\n(dynamic_cast<AllowedInterface1>(o)??dynamic_cast<AllowedInterface2>(o))?->SomeSuspiciosCall();\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/205/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/205/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/204",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/204/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/204/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/204/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/204",
    "id": 839927387,
    "node_id": "MDU6SXNzdWU4Mzk5MjczODc=",
    "number": 204,
    "title": "Читаемый синтаксис для назначения назначения адресов.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T16:52:36Z",
    "updated_at": "2021-03-24T16:56:22Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -7\r\n_Автор идеи:_ **avraliov.andrey**\r\n\r\nИзучая язык Ada захотелось такую же, человеческую возможность использовать читаемый и дубовый способ назначения адресного пространства идентификаторам. Без всяких reinterpret_cast. Очень не хватает в программировании embedded приложений.\r\n\r\nВ ada:\r\n```\r\nvar: mod2*32;\r\n\r\nfor var'address use to_adress (16#405338#)\r\n```\r\nХотелось бы в С++ что то в этом роде:\r\n```\r\nstd::uint32_t var;\r\n\r\nfor var using address(405338);\r\n```\r\nДа, понимаю что нужно добавить новое ключевое слово в язык. Может кто предложит идею в более простой реализации. Только, думаю не стоит говорить что reinterpret_cast<>()... это вполне замечательный вариант. Да он работает, но читаемость кода заметно ухудшается со всеми вытекающими.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/204/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/204/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/203",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/203/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/203/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/203/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/203",
    "id": 839926039,
    "node_id": "MDU6SXNzdWU4Mzk5MjYwMzk=",
    "number": 203,
    "title": "Позволить конструкцию вида while !( условие ) { }",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T16:51:03Z",
    "updated_at": "2021-03-24T16:51:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -15\r\n_Автор идеи:_ **Павел Ольховиков**\r\n\r\n\r\n\r\nОтрицание в условии цикла while перед первой открывающейся скобкой позволит писать более наглядный код\r\n\r\n\r\nКогда имеется несколько причин прервать цикл, куда удобнее использовать понятие не \"выполнять пока (условие истинно)\", а \"остановить как только (условие истинно)\". И, благодаря закону общей инверсии, сделать это нетрудно, достаточно лишь все условие взять в скобки и произвести над ним операцию отрицания:\r\n\r\n**Пример 1.** Существующее решение.\r\n\r\nДанный пример читается как \"остановить цикл как только условие1 и условие2 истинны\". Запись в более традиционной форме выглядела бы как:\r\n```cpp\r\nwhile ( !( условие1 && условие2 ) )  {\r\n    // тело цикла\r\n}\r\n```\r\nЦикл прекратит выполнение, как только внутреннее условие истинно.\r\n\r\n**Пример 2.** Чуть более традиционная запись.\r\n```cpp\r\nwhile (  !условие1 || !условие2  )  {\r\n    // тело цикла\r\n}\r\n```\r\nВоспринимается это несколько труднее: \"выполнять, пока условие1 или условие2 не станет ложно\".\r\n\r\nТоже самое справедливо и для более сложных внутренних условий:\r\n\r\n**Пример 3.** Сложное условие.\r\n```cpp\r\nwhile ( !(условие5 || (условие1 && условие2 ) || (условие3 && условие4) ) ) { }\r\n```\r\nЧитается несколько проще, чем если бы мы записали более традиционно \"Выполнять пока очень_сложное_условие(см. пример ниже)\"\r\n\r\nОднако, такой подход имеет недостатки, заметные уже из примера:\r\n\r\n*    он не достаточно нагляден;\r\n*    появляются лишние скобки, затрудняющие восприятие выражения целиком;\r\n*    в длинных условиях не вполне ясно, как далеко простирается отрицание.\r\n\r\nВвод отрицания перед условием позволил бы синтаксически подчеркнуть принцип работы цикла и облегчить его восприятие:\r\n\r\nПример предложенного синтаксиса:\r\n```cpp\r\nwhile !(условие5 || (условие1 && условие2 ) || (условие3 && условие4) ) { }\r\n```\r\nТрадиционная запись:\r\n```cpp\r\nwhile ( !условие1 && (!условие2 || !условие3) && (!условие4 || !условие5 ) ) { }\r\n```\r\nПреимущества предложенного синтаксиса перед примером 3:\r\n\r\n*    нет сомнений, что такое отрицание, идущее сразу после слова while, простирается на все условие;\r\n*    сразу видно, что нужно читать цикл как \"остановить как только условие истинно\", а не \"выполнять пока\";\r\n*    отсутствие лишних скобок в целом улучшает визуальное восприятие.\r\n\r\nПреимущества перед традиционной записью:\r\n\r\n*    мы в принципе можем записать такое условие без калькулятора логических выражений;\r\n*    мы даже способны его прочитать, и это даже не составит труда, если условия будут короткими переменными или фунциями : )\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/203/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/203/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/202",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/202/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/202/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/202/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/202",
    "id": 839897786,
    "node_id": "MDU6SXNzdWU4Mzk4OTc3ODY=",
    "number": 202,
    "title": "variadic template фиксированного типа",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T16:21:15Z",
    "updated_at": "2021-03-24T16:45:33Z",
    "closed_at": "2021-03-24T16:45:23Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -3\r\n_Автор идеи:_ **Antervis**\r\n\r\nразрешить конструкцию типа void func(MyType ...args) { ... };\r\n\r\nДобавить возможность писать variadic template функции, принимающие variadic pack фиксированного типа.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/202/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/202/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/201",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/201/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/201/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/201/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/201",
    "id": 839896657,
    "node_id": "MDU6SXNzdWU4Mzk4OTY2NTc=",
    "number": 201,
    "title": "Унарные и бинарные операторы.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T16:20:03Z",
    "updated_at": "2021-03-24T16:20:31Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -12\r\n_Автор идеи:_ **post-increment**\r\n\r\nВ С++ присутствуют операторы, которые используются, как унарные и как бинарные (+, *, &).\r\nИдея состоит в том, чтобы расширить использование некоторых операторов:\r\n* символы бинарных операторов разрешить использовать как унарные (префиксные) операторы\r\n* символы унарных операторов разрешить использовать как бинарные операторы \r\n\r\nВ текущей реализации С++ мы можем писать следующие выражения\r\n```cpp\r\nint* pi = initialize_me();\r\nint i = 0,j = 1,k = 2;\r\ni = j+k;\r\ni = +j;\r\ni = j*k;\r\ni = *pi;\r\ni = j* *pi;\r\n```\r\nПарсер языка не имеет сложностей с разбором такого кода.\r\nТакже мы можем писать следующие выражения\r\n```cpp\r\ni = ~j;\r\ni = j^k;\r\ni = j%k;\r\n```\r\nХотелось бы для последних операторов иметь унарные или бинарные аналоги.\r\n```cpp\r\ni = j~k;\r\ni = %j;\r\ni = ^j;\r\n```\r\nВозможно для целочисленных и иных встроенных типов это (пока что) не имеет семантического смысла.\r\nДля пользовательских типов такой подход был бы интересен.\r\n\r\nКасаемо приоритетов. Если рассмотреть таблицу\r\nhttp://ru.cppreference.com/w/cpp/language/operator_precedence,\r\nто все унарные (и предлагаемы тоже) префиксные операторы соответствуют строке 3.\r\n\r\nПриоритет бинарных операторов - вопрос обсуждаемый.\r\n\r\nС точки зрения реализации видится, что потребуется подход аналогичный для операторов +,*,&.\r\n\r\nКак я вижу, совместимость со старым кодом не нарушается. \r\n\r\nВопрос того, какие операторы расширять, обсуждаем.\r\n\r\nДобавлю, что перегрузка операторов предполагается аналогичной той, что уже есть.\r\nНапример, для свободных функций объявление такое:\r\n```cpp\r\nType1 operator^(Type2 const&);\r\nType3 operator~(Type4 const&, Type5 const&);\r\n```\r\nПрошу написать ваше видение. Интересно, какие плюсы и минусы вы видите в этой идее.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/201/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/201/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/200",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/200/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/200/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/200/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/200",
    "id": 839894947,
    "node_id": "MDU6SXNzdWU4Mzk4OTQ5NDc=",
    "number": 200,
    "title": "`var := value;` как синтаксический сахар для `auto var = value;`",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T16:18:13Z",
    "updated_at": "2022-08-11T18:48:17Z",
    "closed_at": "2022-08-11T18:48:16Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -29\r\n_Автор идеи:_ **В**\r\n\r\n`var := value;` как синтаксический сахар для `auto var = value;`\r\n\r\nидея из Go\r\n```\r\nvar := value;\r\n```\r\nкак синтаксический сахар для\r\n\r\n \r\n```cpp\r\nauto var = value;\r\n```\r\n \r\n\r\nидея из Go\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/200/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/200/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/199",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/199/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/199/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/199/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/199",
    "id": 839890287,
    "node_id": "MDU6SXNzdWU4Mzk4OTAyODc=",
    "number": 199,
    "title": "Встраивание полей структур",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T16:13:34Z",
    "updated_at": "2021-03-24T16:17:22Z",
    "closed_at": "2021-03-24T16:17:13Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -4\r\n_Автор идеи:_ **Дмитрий**\r\n\r\nДобавить возможность встраивать структуры для оптимизации размещения полей в памяти\r\n\r\nCтруктура данных Object в данном примере (на x64) занимает 32 байта:\r\n```cpp\r\nstruct Container {\r\n    void *data;     // 8\r\n    uint16_t size;  // 8, из которых используется 2\r\n};\r\n \r\nstruct Object {\r\n    uint64_t id;     // 8\r\n    Container list;  // 16, из которых используется 10\r\n    uint16_t flags;  // 8, из которых используется 2\r\n};\r\n```\r\nЕё можно переписать вот так:\r\n```cpp\r\nstruct Object {\r\n    uint64_t id;    // 8\r\n    void *data;     // 8\r\n    uint16_t size;  // 2\r\n    uint8_t flags;  // 1\r\n}; \r\n```\r\nТогда её размер уменьшится на 25%, до 24 байт (а на 32 битной системе размер уменьшится еще больше - на 33%, с 24 байт до 16 байт). Но данный вариант требует ручного дублирования Container во всех структурах. Предлагаю в качестве решения обозначать структуру как встраиваемую:\r\n```cpp\r\ninline struct Container {\r\n    void *data;     // 8\r\n    uint16_t size;  // 8, из которых используется 2\r\n};\r\n \r\nstruct Object {\r\n    uint64_t id;     // 8\r\n    Container list;  // 16, из которых используется 11, свои поля + flags\r\n    uint16_t flags;\r\n};\r\n```\r\nВ данном примере сообщается, что структура Container никак не использует области памяти, к которым у неё нет явного доступа (последние 6 байт), и может быть безопасно встроена в другую структуру, которая, в свою очередь, может использовать данную память под свои поля. При этом сохраняется выравнивание полей по границе кратной своему же размеру, но уменьшается объем потребляемой памяти и, соответственно, количество промахов кэша.\r\nАльтернативный вариант:\r\n```cpp\r\nstruct Container {\r\n    void *data;     // 8\r\n    uint16_t size;  // 8, из которых используется 2\r\n};\r\n \r\nstruct Object {\r\n    uint64_t id;     // 8\r\n    inline Container list;  // 16, из которых используется 11, свои поля + flags\r\n    uint16_t flags;\r\n};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/199/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/199/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/198",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/198/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/198/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/198/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/198",
    "id": 839491736,
    "node_id": "MDU6SXNzdWU4Mzk0OTE3MzY=",
    "number": 198,
    "title": "Альтернатива спискам инициализации конструкторов",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:47:07Z",
    "updated_at": "2021-03-24T08:50:41Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -10\r\n_Автор идеи:_ **Сергей Тиунов**\r\n\r\nВозможность изменять члены-константы и члены-ссылки в теле конструктора\r\n\r\n## Мотивация\r\n\r\n\r\nСейчас часть конструирования объекта **должна** быть сделана в member initializer list'ах (далее - списки инициализации).\r\n\r\nВ частности в списке инициализации должны быть указаны:\r\n\r\n*    вызовы конструкторов родительских классов (непосредственных или виртуальных, у которых не доступен конструктор по умолчанию)\r\n*    вызовы конструкторов константных полей (у которых не доступен конструктор по умолчанию)\r\n*    инициализация ссылок\r\n\r\nВсе это неплохо работает, если нужно просто правильно передать аргументы конструктора:\r\n```cpp\r\nclass MyClass : public MyBase {\r\npublic:\r\n    MyClass(A a, B b, C& c):\r\n        MyBase(a), _b(b), _c(c) {}\r\nprivate:\r\n    const B _b;\r\n    C&      _c;\r\n};\r\n```\r\nНо если требуется сделать более сложную инициализацию, то приходится прятать конструктор в private-секцию и делать фабричный метод:\r\n```cpp\r\nstatic MyClass create(A a) {\r\n    C& c = getC(a);\r\n    B b = getB(c);\r\n    return MyClass(a, std::move(b), c);\r\n}\r\n```\r\n(здесь в качестве суррогатного примера сложной инициализации приведена зависимость аргументов - `b' получается из `c', `с' получается из `a' - на практике же инициализация может быть значительно сложнее).\r\n\r\nДругой (возможно, более простой) вариант - не использовать константы и ссылки в качестве членов класса (вместо них использовать соответственно изменяемые объекты и указатели):\r\n```cpp\r\n    MyClass(A a): MyBase(a) {\r\n        _c = &getC(a);\r\n        _b = getB(*_c);\r\n    }\r\nprivate:\r\n    B       _b;\r\n    C *     _c;\r\n```\r\nОднако в этом случае мы теряем гарантию того, что во время жизни объекта эти члены класса не изменятся - это неприятно, особенно с учетом того, что причина заключается в ограничениях конструкторов в C++.\r\n\r\n \r\n\r\n## Предложение\r\n\r\nМожно разрешить изменять const-поля в конструкторе. Если же существует путь исполнения, при котором const-поле не проинициализировано, то должна быть также указана инициализация по умолчанию - в списке инициализации, как и раньше.\r\n\r\nАналогично и со ссылками, однако для отложенной инициализации ссылок в C++ не существует синтаксиса. Можно предложить что-нибудь вроде &x = ... (т.е. сделать &x lvalue с типом decltype(x), если это выражение указано в конструкторе и x - это ссылка).\r\n\r\nВ результате, в списке инициализации можно будет указать только вызовы конструкторов классов (direct base, virtual base или delegating), а остальные члены можно проиницилизировать в теле класса:\r\n```cpp\r\nclass MyClass : public MyBase {\r\npublic:\r\n    MyClass(A a): MyBase(a) {\r\n        &_c = getC(a);\r\n        _b = getB(_c);\r\n    }\r\nprivate:\r\n    const B   _b;\r\n    C&        _c;\r\n};\r\n```\r\n## Что это даст?\r\n\r\n*    больше возможностей переместить сложную инициализацию объектов класса в конструктор класса (где им и место, на мой взгляд), и избавиться от фабричных методов (если единственной причиной их существования были ограничения конструкторов в C++)\r\n*    больше возможностей использовать константы и ссылки в качестве членов класса (и таким образом гарантировать их неизменность с момента инициализации объекта)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/198/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/198/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/197",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/197/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/197/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/197/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/197",
    "id": 839489692,
    "node_id": "MDU6SXNzdWU4Mzk0ODk2OTI=",
    "number": 197,
    "title": "Concept для контейнеров/алгоритмов.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:44:24Z",
    "updated_at": "2021-03-24T08:45:02Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -2\r\n_Автор идеи:_ **d-yaroshev**\r\n\r\n\r\nОдна из основных идей, связанных с concepts, это описывать группу требований синтаксических и семантических требований к операциям. Однако, не смотря на это у нас есть большие проблемы с тем чтобы определить концепты для алгоритмов и контейнеров, люди начинают возвращаться к простому описанию операций Movable, Copiable итд. У меня есть идея на эту тему.\r\n\r\n\r\nВ качестве точки отсчета предлагаю посмотреть на Elements Of Programming (EoP) в которой вводится несколько concepts, например регулярный тип. Похоже, что понятие регулярного типа в том же смысле, в котором оно было в EoP сейчас в целом принято сообществом.\r\nИдейно Regular означает следующее: у нас есть множество (в математическом смысле) всех возможных значений типа, и объект соответсвует одному из них. Из этого следует семантика равенства: два регулярных объекта равны, если они соотвтествуют одному и тому же значению.\r\nИногда регулярные типы еще называют value types (или говорят о value semantics).\r\n\r\nК более формальному списку требований. Тип является регулярным, если он:\r\n\r\n*    Destructible.\r\n*    DefaultConstructible. Конструктор по умолчанию создает объект в partially formed state - ему можно только присвоить новое значение или уничтожить.\r\n*    Copiable. Если объект a является копией объекта b, то они равны.\r\n*    Movable. Объект, из которого был move, находится в patially formed state. (Это не из EoP, но EoP не работает с move semantics, Sean Parent определял так и мне кажется что это разумно, в любом случае - я не об этом).\r\n*    EqualitiyComarable.\r\n\r\nSTL изначально рассчитывался на регулярные типы. unique_ptr, с точки зрения синтаксиса, не является регулярным, но очень хорошо себя чувствует с stl. Изначально у меня была идея, давайте попробуем убрать часть ограничений с Regular, которых будет достаточно для большинства операций. Введем concept Unique - Regular без копирования. Тогда Regular будет усилением Unique и часть операций будут доступны только если тип не только Unique но и Regular (подобным образом EoP опредялет операции сравнения только для TotallyOrdered типов). Есть проблемы.\r\n\r\nНасколько разумно выглядит данный код?\r\n```cpp\r\nbool operator==(const Unique& x, const Unique& y) {\r\n  return &x == &y;\r\n}\r\n```\r\nМожно даже написать интересный алгоритм:\r\n```cpp\r\n// (&v is in between begin and end pointers).\r\ntemplate <ContigiousIterator I,\r\n          Unique V>\r\n  requires std::is_same_v<ValueType<I>(), V>\r\nI find(I f, I l, const V& v) {\r\n  if (f == l) return l;\r\n  auto* f_ptr = &*f;\r\n  auto* l_ptr = f_ptr + (l - f);\r\n  if (std::less<>{}(&v, f_ptr) ||   // It's only valid to compare pointers from one array\r\n      (!std::less<>{}(&v, l_ptr))   // but std::less is defined everywhere.\r\n     return l;\r\n  return f + (&v - f_ptr);\r\n}\r\n```\r\nТе получаем поиск в векторе за константное время)\r\n\r\nКогда валиден ли данный код? Когда у нас семантически нет операции копирования. Отсутствие операции несет смысл.\r\n\r\nМожно попробовать вспомнить про nullptr, но а) - это не отвечает на фундаментальный вопрос почему так в общем случае делать нельзя для unique_ptr и б)  - для регулярных типов сравнение в partially formed state не является осмысленной операцией. Наличие специального пустого значения это опять таки другой, хотя и полезный concept.\r\n\r\nНа самом деле вопрос к данному коду заключается в следующем, хотим ли мы чтобы работало вот это:\r\n```cpp\r\ntemplate <typename T>\r\nauto find_ptr(const std::vector<std::unique_ptr<T>>& vec, T* x) {\r\n  std::unique_ptr<T> tmp {&x};\r\n  auto it = find(vec.begin(), vec.end(), tmp);\r\n  tmp.release();\r\n  return it;\r\n}\r\n```\r\n \r\n\r\n \r\n\r\nМне кажется, что не смотря на то что этот код нарушает инварианты unique_ptr, я бы ожидал такой код будет работать.\r\n\r\nВсе потому что семантически unique_ptr - это указатель и отсутствие операции копирования - это пометка когда вызывать удаление, а не его смысл. А указатель являетя регулярным типом. Что не означает, что Unique не является полезным concept и что unique_ptr в некоторых контекстах может быть так использован.\r\n\r\nВ EoP на ряду с регулярными объектами обсуждаются регулярные функции. Регулярная функция - это, грубо говоря, функция, результат которой зависит только от входных аргументов (printf не является регулярной, std::sort является, есть строгое определение). Иногда такие функции называют pure (не все согласятся про std::sort, это сейчас не столь важно). Две регулярные функции равны если для любого набора входных данных их результаты совпадают. Я говорю про регулярные функции потому что принципиально невозможно определить функцию проверки на равенство. Однако это не значит, что не существует понятия равенства. То есть копируемость std::function не страдает от того, что мы не можем определить полноценный operator==. Типы, для которых не возможно определить operator== EoP называет SemiRegular.\r\n\r\nМне кажется, что в случае с unique_ptr мы можем поступить так же - операцию копирования невозможно реализовать, но это не значит что у нее нет смысла.\r\n\r\nМожно вспомнить про другие типы, у которых нет, например, конструктора по умолчанию. Это не значит, что мы должны запрещать их складывать в вектор, это просто значит что конструктор по умолчанию \"подразумевается, но не существует\".\r\n\r\nПредлагаю расширить concept SemiRegular до: у данного типа семантически есть все операции регулярного типа, но не все их них реализованы (или даже возможно реализовать) в коде. Если у типа есть в интерфейсе данная операция, то она имеет регулярную семантику. Получается что тело такой concept должно состоять исключительно из комментария, так как у нас нет аксиом, но все равно выглядит разумно.\r\n\r\nТогда например вектор может выглядеть как-то так:\r\n```cpp\r\ntemplate <SemiRegular T, /**/>\r\nclass vector {\r\npublic:\r\n  requires DefaultConstructible<T>\r\n  vector(size_type)\r\n// ...\r\n};\r\n```\r\nАльтернативно можно было бы сказать что все маленькие ограничения на типы подразумевают SemiRegular.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/197/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/197/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/196",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/196/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/196/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/196/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/196",
    "id": 839485842,
    "node_id": "MDU6SXNzdWU4Mzk0ODU4NDI=",
    "number": 196,
    "title": "thisconst qualifier",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T08:39:12Z",
    "updated_at": "2021-03-24T08:42:29Z",
    "closed_at": "2021-03-24T08:42:23Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **Сергей Тиунов**\r\n\r\n\r\n\r\n## Мотивация\r\n\r\nРассмотрим простую структуру данных, например, массив:\r\n```cpp\r\ntemplate<typename E>\r\nclass array_t\r\n{\r\npublic:\r\n    E& operator[](size_t i) { return _elements[i]; }\r\n    const E& operator[](size_t i) const { return _elements[i]; }\r\n    ...\r\nprivate:\r\n    E *_elements;\r\n    ...\r\n};\r\n```\r\nЗдесь есть пара недостатков:\r\n\r\nНедостаток 1. Абсолютно идентичные реализации методов для const и не const, что приводит к дублированию кода со всеми вытекающими последствиями.\r\n\r\n \r\n\r\nНедостаток 2. Семантика _elements предполагает, что const-методы класса не могут менять элементы, а остальные - могут. Однако C++ не содержит средств, чтобы это выразить, поэтому компилятор не имеет возможности это проверить. В частности, ничто не помешает сделать так:\r\n```cpp\r\n    E& operator[](size_t i) const { return _elements[i]; }\r\n```\r\nВ результате клиент получит не-const ссылку на элемент и будет иметь возможность его изменить, что нарушит обычный инвариант контейнера (константность контейнера гарантирует константность его элементов).\r\n\r\n \r\n\r\n## Предложение\r\n\r\nПредлагается ввести новое ключевое слово (thisconst), которое позволит сделать так:\r\n```cpp\r\n    thisconst E& operator[](size_t i) thisconst { return _elements[i]; }\r\n    ...\r\n    thisconst E *_elements;\r\n```\r\nЗдесь thisconst использован в трех контекстах:\r\n\r\n*    Квалификатор member-функции (operator[]) - обозначает две идентичных функции для const и не const (что-то вроде шаблона функции).\r\n*    Квалификатор возвращаемого значения функции - означает, что возвращаемое значение const E&, если *this - const, и просто E& в противном случае.\r\n*    Квалификатор data member (_elements) - означает, что это указатель на const (const E *), если *this - const, и просто указатель (E *) в противном случае.\r\n\r\nВообще, thisconst может быть использован во всех контекстах, где можно использовать const И доступен this. В частности, помимо указанных применений, можно обозначить как thisconst аргументы member-функции, а также локальные переменные в ее теле.\r\n\r\nКвалификатор thisconst позволяет решить два вышеприведенных недостатка, а именно:\r\n\r\n*    скомбинировать const и non-const варианты member-функции в одном определении\r\n*    связать константность this-объекта и других доступных объектов\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/196/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/196/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/195",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/195/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/195/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/195/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/195",
    "id": 839483809,
    "node_id": "MDU6SXNzdWU4Mzk0ODM4MDk=",
    "number": 195,
    "title": "Generic functions ",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T08:36:22Z",
    "updated_at": "2021-03-24T08:37:55Z",
    "closed_at": "2021-03-24T08:37:49Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -3\r\n_Автор идеи:_ **Сергей Прейс**\r\n\r\nРазрешить писать auto в параметрах обычных функций по аналогии с тем, как это сделано для generic lambda\r\n\r\nИногда хочется написать какую-нибудь небольшую обобщенную функцию и запись через  template выглядит громоздко\r\n```cpp\r\ntemplate<typename T>\r\nT sqr(const T& v) { return v*v; }\r\n```\r\nВместо этого куда красивее было бы \r\n```cpp\r\nauto sqt(const auto& v) {return v*v;}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/195/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/195/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/194",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/194/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/194/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/194/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/194",
    "id": 839482585,
    "node_id": "MDU6SXNzdWU4Mzk0ODI1ODU=",
    "number": 194,
    "title": "ABI как часть языка",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:34:40Z",
    "updated_at": "2021-03-24T08:35:11Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -5\r\n_Автор идеи:_ **Сергей Прейс**\r\n\r\nМногие расширения С++ (OpenCL, OpenMP SIMD, OpenACC. C++AMP и т.п.) требуют различать функции с разным ABI в рамках одной программы. Реализуется это обычно с использованием прагм и проприетарных атрибутов, что ограничивает применимость С++ к таким функциям. Предлагается ввести ABI в язык чтобы разрешить перегрузку по ABI, перехват ABI как части типа в std::function и std::bind, ABI-специфичные указатели и т.п.\r\n\r\nЯ приведу примеры для OpenMP 4.0 потому как делал для него поддержку в компиляторе и знаю его проблему наиболее близко, но проблемы в С++AMP и прочих расширениях аналогичны описанным.\r\n\r\nИтак, OpenMP 4.0 позволяет описать описать функцию, совместимую по ABI с SIMD-исполнением цикла (она будет принимать сразу несколько значений параметров в SIMD-регистрах, SIMD-обрабатывать их и возвращать на SIMD регистре).\r\n```cpp\r\n#pragma omp declare simd simdlen(4)\r\n#pragma omp declare simd simdlen(8)\r\ndouble mul(double x, double y);\r\n```\r\nТеперь функция сможет обрабатывать 4 или 8 значений параллельно (будет сделано несколько версий) и ее можно использовать в цикле\r\n```cpp\r\n#pragma omp simd\r\nfor (int i = 0; i < N; i++) {\r\n    a[i] = mul(b[i], c[i]);\r\n}\r\n```\r\nОднако, если мы решим усложнить программу с использованием современного C++ мы быстро столкнемся с проблемами. '#omp declare simd' - это не часть типа и потому:\r\n\r\n- Попытка завернуть функцию в std::function утратит ABI сразу\r\n\r\n- Взятие адреса и передача в другую функцию - тоже (нет возможности описать тип функции и фунционального указателся с учетом ABI)\r\n\r\n- std::bind тоже не будет работать - она деконструирует и реконструирует тип, ABI потеряется.\r\n\r\nТо есть даже имея политику исполнения SIMD (unseq) мы не сможем передать в алгоритм\r\n```cpp\r\nstd::transform(unseq, b, b+N, c, a, mul);\r\n```\r\nфункцию совместимую с этой политикой по ABI. Если нам повезет mul проинлайнится мы получим нужный эффект, иначе - увы. БОльшая часть расширений такого рода полностью опираются на инлайнинг и ограничивают использование C++ конструкций с аннотированными функциями.\r\n\r\nПредлагается ввести понятие ABI в систему типов как дополнительный аттрибут со значениями либо поддержанными компилятором либо возвращающими ошибку.\r\n\r\nЧто-то вроде\r\n```cpp\r\ndouble mul(double x, double y);\r\ndouble mul(double x, double y) abi(simd4);\r\ndouble mul(double x, double y) abi(simd8);\r\n```\r\nили даже\r\n```cpp\r\ntemplate<abi_tag a = default>\r\ndouble mul(double x, double y) abi(a);\r\n```\r\nCоответственно abi будет частью функционального типа и будет применимо в т.ч. к указателям. Также abi должно стать частью execution policy. Тогда станет возможно, например, исполнять алгоритмы на сопроцессорах, GPU и т.п. даже если ядро алгоритма не инлайнится в алгоритм.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/194/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/194/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/193",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/193/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/193/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/193/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/193",
    "id": 839481419,
    "node_id": "MDU6SXNzdWU4Mzk0ODE0MTk=",
    "number": 193,
    "title": "Класс для работы с открытым файловым дескриптором",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:32:58Z",
    "updated_at": "2021-03-24T08:33:18Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +12, -1\r\n_Автор идеи:_ **Арсений Смалюк**\r\n\r\nСоздать класс, хранящий файловый дескриптор и позволяющий получать атрибуты файла (аналогично fstat из POSIX) и читать/писать в файл, не открывая его заново.\r\n\r\nВ различных языках есть классы, представляющие собой открытый файловый дескриптор.\r\nЭто позволяет получать информацию о файле и читать/писать в файл, не открывая его заново. Таким образом можно избавиться от ошибок состояния гонки вокруг файла.\r\n\r\nСоздать класс (std::file), который хранит внутри себя файловый дескриптор и позволяет получать различные атрибуты открытого файла, например его тип, размер или права доступа.\r\nДля работы с открытым файлом добавить возможность передавать std::file в конструктор fstream или directory_iterator.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/193/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/193/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/192",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/192/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/192/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/192/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/192",
    "id": 839480533,
    "node_id": "MDU6SXNzdWU4Mzk0ODA1MzM=",
    "number": 192,
    "title": "Расширить конструкторы std::function для bound аргументов функции",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:31:41Z",
    "updated_at": "2021-03-24T08:32:11Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -2\r\n_Автор идеи:_ **Antervis**\r\n\r\nstd::function func(&foo, args...); как эквивалент нынешнему std::function func(std::bind(&foo,args...));\r\n\r\nИдея: поменять конструкторы (5) и (10) [std::function::function (cppreference)](http://en.cppreference.com/w/cpp/utility/functional/function/function) c:\r\n```cpp\r\ntemplate< class F >\r\nfunction( F f );\r\n\r\ntemplate< class F, class Alloc >\r\nfunction( std::allocator_arg_t, const Alloc& alloc, F f );\r\n```\r\nна:\r\n```cpp\r\ntemplate< class F, class ...Args >\r\nfunction( F f, Args &&...args );\r\n\r\ntemplate< class F, class Alloc, class ...Args >\r\nfunction( std::allocator_arg_t, const Alloc& alloc, F f, Args &&...args );\r\n\r\n// possible implementation:\r\n\r\n// declared and implemented as before\r\ntemplate< class F >\r\nfunction( F f );\r\n\r\ntemplate< class F, class Alloc >\r\nfunction( std::allocator_arg_t, const Alloc& alloc, F f );\r\n\r\n// overriden for more than 1 argument\r\ntemplate< class F, class ...Args >\r\nfunction( F &&f, Args &&...args ) {\r\n    return function(bind(forward<F>(f), forward<Args>(args)...));\r\n}\r\n\r\ntemplate< class F, class ...Args >\r\nfunction( std::allocator_arg_t, const Alloc& alloc, F &&f, Args &&...args ) {\r\n    return function( allocator_arg, alloc, bind(forward<F>(f), forward<Args>(args)...));\r\n}\r\n```\r\nПо факту, это синтаксический сахар, который позволит в некоторых контекстах, принимающих std::function, опустить std::bind:\r\n```cpp\r\nvoid putToQueue(std::function<void()> f);\r\n\r\n// До:\r\nputToQueue(std::bind(&func, arg1, arg2));\r\n// После:\r\nputToQueue({&func, arg1, arg2});\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/192/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/192/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/191",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/191/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/191/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/191/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/191",
    "id": 839479042,
    "node_id": "MDU6SXNzdWU4Mzk0NzkwNDI=",
    "number": 191,
    "title": "Дополнить wide_int стандартными функциями",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:29:33Z",
    "updated_at": "2021-03-24T08:29:59Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -3\r\n_Автор идеи:_ **dix75**\r\n\r\nДобавить новый proposal и/или дополнить существующий proposal стандартными функциями \r\n\r\nСуществует[ proposal wide_int Template Class](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0539r0.html) расширяющий стандартный ряд типов добавляя типы больших чисел.\r\n\r\nВ связи с этим особо актуально становится наличие сопутствующих математических функций, возможно constexpr , таких как:\r\n\r\n*    std::abs\r\n*    std::sin\r\n*    std::cos\r\n*    std::pow\r\n*    и др.\r\n\r\nА также весьма полезным будет добавление следующей шаблонной структуры\r\n```cpp\r\ntemplate< class T >\r\nstruct is_wide_int final\r\n     : std::integral_constant<\r\n         bool,\r\n         std::is_same<std::int128_t, typename std::remove_cv<T>::type>::value   ||\r\n         std::is_same<std::int256_t, typename std::remove_cv<T>::type>::value   ||\r\n         std::is_same<std::int512_t, typename std::remove_cv<T>::type>::value   ||\r\n         std::is_same<std::uint128_t, typename std::remove_cv<T>::type>::value  ||\r\n         std::is_same<std::uint256_t, typename std::remove_cv<T>::type>::value  ||\r\n         std::is_same<std::uint512_t, typename std::remove_cv<T>::type>::value\r\n     > {};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/191/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/191/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/190",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/190/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/190/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/190/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/190",
    "id": 839477132,
    "node_id": "MDU6SXNzdWU4Mzk0NzcxMzI=",
    "number": 190,
    "title": "Разрешить использовать designated initializer из С99",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:26:58Z",
    "updated_at": "2021-04-06T19:05:47Z",
    "closed_at": "2021-03-24T08:28:06Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +34, -0\r\n_Автор идеи:_ **amomum**\r\n\r\nЭто удобный способ инициализировать структуры и массивы, который уже есть в С99:\r\n```cpp\r\nPerson p = { .age = 18, .height=10, .weight = 5 };\r\nint a[6] = { [4] = 29, [2] = 15 };\r\n```\r\n\r\nDesignated initializer - это конструкции такого вида:\r\n```cpp\r\nstruct Person\r\n{  \r\n    int height;\r\n    int weight;\r\n    int age;\r\n};\r\n\r\nint main()\r\n{\r\n    Person p = { .age = 18, .height=10, .weight = 5 };\r\n}\r\n```\r\nПричины за:\r\n\r\n*    Это есть в С99\r\n*    Явное указение имен полей, независящее от их порядка - в отличии от допустимого сейчас Person p = {1, 2, 3}\r\n*    Позволит имитировать именованые параметры у функций: foo( (Person){.age = 9, .height=10} );\r\n*    Не нужно писать конструктор для POD-структуры\r\n*    Удобная инициализация массивов структур\r\n*    Уже поддерживается gcc и clang\r\n\r\nПричины против:\r\n\r\n*    Уже есть конструкторы\r\n*    Неожиданный порядок выполнения кода в инициализаторе (например)\r\n*    Усложнение синтаксиса\r\n*    Неявная инициализация нулем не упомянутых в инициализаторе полей\r\n*    Вероятно, еще что-то",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/190/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/189",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/189/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/189/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/189/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/189",
    "id": 839475801,
    "node_id": "MDU6SXNzdWU4Mzk0NzU4MDE=",
    "number": 189,
    "title": "Лямбда функции с использованием плейсходера",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:25:05Z",
    "updated_at": "2021-03-24T08:25:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -7\r\n_Автор идеи:_ **danich**\r\n\r\nВ книге Стандарты кодирования на С++ (Sutter, Alexandrescu) существует пример кода:\r\n```cpp\r\nvector::iterator i = find_if( v.begin(), v.end(), _1 > x && _1 < y);\r\n```\r\nСейчас это можно сделать через , кмк было бы хорошо иметь подобную возможность в stl.\r\n```cpp\r\nstd::vector<int> v;\r\nint x = 0;\r\nint y = 10;\r\n\r\nusing namespace boost::lambda;\r\n\r\nstd::vector<int>::iterator i = find_if( v.begin(), v.end(), [=](int a) { return a > x && a < y; });\r\n```\r\nподобную запись можно переписать заменив тип аргумента лямбда функции на auto, а раз тип аргумента известен, то в некоторых ситуациях можно было бы опустить его вообще.\r\n\r\nЗапись предложенная Александреску, конечно не стала бы полноценной заменой, но вполне могла бы быть интересной синтаксической фичей для лямбда функций.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/189/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/188",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/188/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/188/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/188/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/188",
    "id": 839474015,
    "node_id": "MDU6SXNzdWU4Mzk0NzQwMTU=",
    "number": 188,
    "title": "Разрешить конструктор std::string от пустого char*",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T08:22:29Z",
    "updated_at": "2021-03-24T08:24:04Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -10\r\n_Автор идеи:_ **avataka**\r\n\r\nТ.к. контейнеры в STL, задумывались для безопасного и удобного доступа к данным, мне кажется есть смысл разрешить данный случай конструктора. Чтобы не делать отдельную функцию проверки на случай если на вход пришла пустая строка из какой-то C-style библиотеки.\r\n\r\nХотелось бы чтобы данный код не приводил к ошибке. Аналогично и для всех символьных типов и соотвествующим им строками (wchar_t, char16_t, char32_t):\r\n```cpp\r\nchar* c_str = nullptr;\r\nstd::string cpp_str(c_str);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/188/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/188/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/187",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/187/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/187/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/187/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/187",
    "id": 839473099,
    "node_id": "MDU6SXNzdWU4Mzk0NzMwOTk=",
    "number": 187,
    "title": "Продление жизни rvalue до конца блока через (void)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:21:14Z",
    "updated_at": "2021-03-24T08:21:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -7\r\n_Автор идеи:_ **Antervis**\r\n\r\n\r\n(void) foo(); как аналог auto __temp = foo(); (void)__temp;\r\n\r\nЧтобы временный объект дожил до конца блока, необходимо поместить его в какую-либо переменную:\r\n```cpp\r\n// Удаление объекта при выходе из scope\r\nauto temp = unique_ptr(ptr,deleter);\r\n```\r\nПосле чего большинство компиляторов ругнутся на неиспользуемую переменную temp, соответственно добавляем\r\n```cpp\r\n(void)temp;\r\n```\r\nПри этом, переменная temp всё еще будет видима, хотя её использование дальше по тексту не подразумевается. Также могут быть проблемы при написании макросов (например, того же scoped-exit) - \"переменная с таким именем уже существует\".\r\n\r\nПредлагаемый вариант:\r\n```cpp\r\n(void) foo();\r\n```\r\n \r\n\r\nНасколько я знаю, на данный момент стандарт не запрещает использование подобного синтаксиса, однако он не имеет смысла и поэтому влияние изменения на существующий код крайне маловероятно.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/187/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/187/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/186",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/186/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/186/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/186/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/186",
    "id": 839471029,
    "node_id": "MDU6SXNzdWU4Mzk0NzEwMjk=",
    "number": 186,
    "title": "Порядок следования байтов std::basic_ios",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T08:18:15Z",
    "updated_at": "2021-03-24T08:20:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **zhuebok**\r\n\r\nНужно меньше телодвижений для работы с ненативным порядком следования байтов\r\n\r\nПредлагаю добавить возможность установки порядка следобания байтов для std::ios_base. Неплохо было бы, конечно же, сделать возможность применения в качестве флага порядка байтов шаблонного параметра чем-то вроде такого (особо не думал по этому поводу, конечно же, не хватает методов для перехода из одного порядка следования байт в другой). \r\n```cpp\r\nnamespace std {\r\n\r\nenum byte_order {\r\n  native = ?,\r\n  little_endian = 1,\r\n  big_endian = 2,\r\n  ...\r\n};\r\n\r\ntemplate<byte_order ByteOrder>\r\nclass byte_order_traits;\r\n\r\ntemplate<>\r\nclass byte_order_traits<little_endian> {\r\npublic:\r\n  template<typename T>\r\n  constexpr static T convert_from_system(T &&value);\r\n\r\n  template<typename T>\r\n  constexpr static T convert_to_system(T &&value);\r\n  ...\r\n};\r\n\r\n...\r\n}\r\n```\r\nИ соответственно, добавить дополнительный шаблонный параметр для std::basic_ios:\r\n```cpp\r\ntemplate<typename CharType, typename Traits = char_traits<CharType>, typename ByteOrderTraits = byte_order_traits<system_byte_order>>\r\n```\r\nclass basic_ios : public std::ios_base;\r\n\r\nКонечно же, можно использовать Boost.Endian, однако хотелось бы такой поддержки из коробки.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/186/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/186/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/185",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/185/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/185/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/185/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/185",
    "id": 839469881,
    "node_id": "MDU6SXNzdWU4Mzk0Njk4ODE=",
    "number": 185,
    "title": "Сокращенная запись lambda функций",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:16:39Z",
    "updated_at": "2021-03-24T08:17:01Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -12\r\n_Автор идеи:_ **Алексей Егоров**\r\n\r\nВ С# пишут очень коротко \"x => x\", да и в других языках вроде rust не длинно получается. Хочется аналогичной короткой записи и в c++ для тривиальных функций.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/185/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/185/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/184",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/184/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/184/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/184/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/184",
    "id": 839468336,
    "node_id": "MDU6SXNzdWU4Mzk0NjgzMzY=",
    "number": 184,
    "title": "std::is_complete",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:14:31Z",
    "updated_at": "2021-03-27T18:58:22Z",
    "closed_at": "2021-03-24T08:15:51Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -0\r\n_Автор идеи:_ **Александр**\r\n\r\ncompile-time проверка завершенности типа.\r\n\r\nБывает необходимо проверить завершенность типа, переданного в шаблон.\r\n```cpp\r\nstruct A;//incomplete type\r\n\r\nstruct B {}//complete type\r\n\r\n//...\r\n\r\ntemplate<typename T>\r\nvoid foo()\r\n{\r\n   static_assert (std::is_complete<T>::value, \"T must be complete\");\r\n   //...\r\n}\r\n\r\n\r\ntemplate<typename T>\r\nvoid bar()\r\n{\r\n   if constexpr (std::is_complete_v<T>) {\r\n      //...\r\n   } else {\r\n      //...\r\n   }\r\n   //...\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/184/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/184/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/183",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/183/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/183/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/183/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/183",
    "id": 839467435,
    "node_id": "MDU6SXNzdWU4Mzk0Njc0MzU=",
    "number": 183,
    "title": "Типы с фиксированной точкой (fixed-point types)",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:13:12Z",
    "updated_at": "2021-03-24T08:13:37Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +20, -3\r\n_Автор идеи:_ **mezastel**\r\n\r\nТипы с плавающей точкой нужны для того, чтобы 0.1+0.2 наконец-то было равно 0.3. FP типы нужны для корпоративных финансов (не путать с фин.мат.-ом), компьютерных игр, а еще они нужны для юнит-тестирования по вполне понятным причинам.\r\n\r\nЗнаете когда вы изучаете новый язык, вроде С++, и вам показывают template <typename T> class Rational { T numerator, denominator; } и потом там всякие операции? Ну на самом деле это все есть в CAS системах. Серьезно, format rat в MATLAB -- это как раз оно.\r\n\r\nНо мы не о дробях а о детерминизме в вычислениях. Например, в работе с FP (floating point), в итеративных алгоритмах компиляторы ведут себя по-разному, и в результате точность сравнений нужно подкручивать, потому что MSVC и Intel C++ порой дают разные результаты.\r\n\r\nОбычно FixP (fixed point) - это просто пара интов, например struct FP64 { int whole, fractional; }. Мы все плодим такой самопал, но веселье начинается тогда, когда тебе нужны например конверсионные операции. Также, как вы понимаете, этот подход негикий, т.к. по идее нужно иметь что-то вроде fixed_t<I,F> который поддерживает абсолютно все операции: арифметику, сдвиги, конверсию в/из FP. И еще поддержку SIMD и подобных вещей.\r\n\r\nИ конечно хочется как минимум <cmath> для FixP чтобы не заниматься самопалом. Понятно что есть некоторые последствия у этого т.к. в отличии от FP процессоры не оптимизируют подобные операции так что, возможно имеет смысл делать конверсию в FP и назад?\r\n\r\nЕще одна побочная цель - это объяснить людям зачем FixP вообще нужно. Есть впечатление, что за пределами accounting'а и игр никому оно не надо.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/183/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/183/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/182",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/182/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/182/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/182/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/182",
    "id": 839466545,
    "node_id": "MDU6SXNzdWU4Mzk0NjY1NDU=",
    "number": 182,
    "title": "Дополнительные форматы чисел с плавающей точкой",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T08:11:52Z",
    "updated_at": "2022-08-11T11:57:48Z",
    "closed_at": "2022-08-11T11:57:37Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -4\r\n_Автор идеи:_ **eabesea**\r\n\r\nЧисла четверной и половинной точности применяются хоть и не так часто, как double и float, но все-таки довольно полезны. В gcc есть __float128 и __fp16 (правда, только для ARM).\r\n\r\nЧисла четверной и половинной точности уже поддерживаются некоторыми компиляторами (например __float128 и __fp16 в gcc). Существуют также софтверные библиотеки для поддержки расширенных типов: например Berkeley SoftFloat или half.  Использование библитек для чисел произвольной точности ради 128-биных чисел с плавающей точкой кажется оверкиллом.\r\n\r\nПовышенная (четверная или даже восьмерная) точность нередко нужна в научных рассчетах (например, в физике), в то время как числа половинной точности могут улучшить производительность, даже если хардверной поддержки нет, и в последнее время часто используются, например, в нейронных сетях.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/182/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/182/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/181",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/181/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/181/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/181/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/181",
    "id": 839465512,
    "node_id": "MDU6SXNzdWU4Mzk0NjU1MTI=",
    "number": 181,
    "title": "Оператор |>",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:10:24Z",
    "updated_at": "2021-03-24T08:11:02Z",
    "closed_at": "2021-03-24T08:10:54Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -11\r\n_Автор идеи:_ **Diivon**\r\n\r\nДобавление оператора . являющимся точкой следования\r\n\r\nОсобо про него ничего и не скажешь наверное, но я считаю это довольно приятной фичей для добавления в следующий стандарт.\r\n\r\nСмысл в том, что при объединении вызовов методов в \"цепочку\" (chaining methods) порядок вычисления аргументов для этих методов не определён, если при вычислении аргументов для такого участка кода должны происходить побочные эффекты, то соответственно порядок выполнения этих эффектов также не определён\r\n\r\nНапример:\r\n```cpp\r\nauto getForeachFunction(){\r\n    std::cout << \"getForeach called, \";\r\n    return [](auto const & i ){std::cout << i << ' ';};\r\n}\r\nauto getFoldFunction(){\r\n    std::cout << \"getFold called, \";\r\n    return [](auto & acc, auto const & i ){acc += i;};\r\n}\r\nauto getExecFunction(){\r\n    std::cout << \"getExec called, \";\r\n    return [](){std::cout << '|' << std::endl;};\r\n}\r\n```\r\nберем эти функции и применяем соответственно к нашему велосипеду\r\n```cpp\r\nstd::vector<int> v = {1,2,3,4,5,6,7,8,9};\r\niterateOver(v)\r\n    .foreach(getForeachFunction())//apply function to every element in collection\r\n    .exec(getExecFunction())     //just call function, no changes in collection\r\n    .fold(getFoldFunction())    //accumulate this colection in single value\r\n    .print()                   //and do something with this value\r\n```\r\nИз данных двух кусков кода можно понять что порядок вывода строк \"get... called\" не определен, это легко проверить и удостовериться, что это действительно так.\r\n\r\n![image](https://user-images.githubusercontent.com/1700098/112276170-7cfc7b00-8c91-11eb-826b-bf54c1c375a4.png)\r\n\r\nОднако все мы понимаем, что вместо вывода в стандартный поток в соответствующих функциях могут быть вещи куда более серьёзные.\r\n\r\nИдея заключается в том, чтобы добавить в язык c++ такой оператор, при помощи которого можно обращаться к членам объекта или ссылки, и при этом данный оператор являлся бы точкой следования, например |> (хочу F# в мой C++).\r\n\r\nТ.е. чтобы напирмер код выглядел так:\r\n```cpp\r\nstd::vector<int> v = {1,2,3,4,5,6,7,8,9};\r\niterateOver(v)\r\n    |>foreach(getForeachFunction())//apply function to every element in collection\r\n    |>exec(getExecFunction())     //just call function, no changes in collection\r\n    |>fold(getFoldFunction())    //accumulate this colection in single value\r\n    |>print()                   //and do something with this value\r\n```\r\nИ при использовании такого синтаксиса стандарт бы совершенно точно гарантировал порядок вычисления аргументов для методов, да это ограничивает полёт фантазии компилятора в плане оптимизаций, но никто же не запрещает комбинировать . и |>\r\n\r\nИли например код использования разного рода фабрик\r\n```cpp\r\nMainFabric::getObject<ObjectType>(getParam1(), getParam2(), getParam3()).getComponent<ComponentName>(getGetComponentSetting()).doStuffWith(MainFabric::getAnotherComponent<AnotherComponentName>(getGetComponentSetting()));\r\n```\r\nпобочные эффекты getParam1, getParam2, getParam3, getGetComponentSettings, getGetComponentSettings ровно как в примере выше могут выполняться в любом порядке\r\n```cpp\r\nMainFabric::getObject<ObjectType>(getParam1(), getParam2(), getParam3())|>getComponent<ComponentName>(getGetComponentSetting())|>doStuffWith(MainFabric::getAnotherComponent<AnotherComponentName>(getGetComponentSetting()));\r\n```\r\n\r\nНо в данном коде абсолютно точно понятно, что 2-ой вызов getGetComponentSettings будет выполнен после 1-го вызова getGetComponentSettings, и тот в свою очередь будет вызван после череды вызовов getParam1,2,3.\r\n\r\nЯ прекрасно понимаю, что могу сохранять результат выполнения каждой функции в отдельную переменную, и вызывать от неё следующие методы, однако это просто эстетически некрасиво.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/181/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/181/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/180",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/180/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/180/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/180/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/180",
    "id": 839463441,
    "node_id": "MDU6SXNzdWU4Mzk0NjM0NDE=",
    "number": 180,
    "title": "Изолированный блок",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:07:24Z",
    "updated_at": "2021-03-24T08:08:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -14\r\n_Автор идеи:_ **Сергей Ковалёв**\r\n\r\nЯ бы добавить конструкцию языка которая ограничивает видимость в блоке. Конструкция хоть и вспомогательная, но как строительные леса иногда полезная. Особенно где есть вложенные циклы и процветает copy&paste и другие чудеса.\r\n\r\n```cpp\r\nint cg=0, g2=3;\r\nvoid fn() {\r\n  int ci,cl;\r\n  c1=1; cl=2;\r\n  box(c1,g2) {\r\n    c1=10; // ok\r\n    g2=4; // ok\r\n    cl=2; // compile-error undefined in block\r\n    cg=0; // compile-error undefined in block\r\n  }\r\n}\r\n\r\n#include <stdio.h>\r\nint fn2(int x) box(g2) {\r\n  printf(\"\\n\"); // compile-error undefined in block\r\n  return x+g2;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/180/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/180/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/179",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/179/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/179/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/179/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/179",
    "id": 839462078,
    "node_id": "MDU6SXNzdWU4Mzk0NjIwNzg=",
    "number": 179,
    "title": "Изменение видимости перечисления при \"opaque enum declaration\"",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:05:28Z",
    "updated_at": "2021-03-24T08:06:27Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -7\r\n_Автор идеи:_ **develoit**\r\n\r\nИзменить видимость предекларированного перечисления (enum class/struct) в классе на видимость секции определения.\r\n```cpp\r\nclass foo\r\n{\r\n    enum class some_enumerable_type : std::size_t;\r\n    some_enumerable_type value_;\r\n\r\npublic:\r\n\r\n    enum class some_enumerable_type : std::size_t\r\n    {\r\n        identifier0,\r\n        identifier1,\r\n        identifier2,\r\n//        ...\r\n        identifierN\r\n    };\r\n\r\n    foo() noexcept : value_{some_enumerable_type::identifier0} {}\r\n    foo(some_enumerable_type value) noexcept : value_{value} {}\r\n};\r\n\r\nint main()\r\n{\r\n    auto value = foo::some_enumerable_type::identifier1;\r\n    std::cout << static_cast<std::size_t>(value) << std::endl;\r\n}\r\n```\r\n\r\nДанный пример не сработает. Конечно, можно перенести объявление переменной после определения перечисления, но! тогда какой смысл в возможности предекларации перечеслений (особенно с явным указанием базового типа)?\r\nМожет имеет смысл исправить такое поведение?\r\n\r\nДа, и еще) может и static_cast для enum`ов ликвидировать в случаях когда требуемый тип совпадает с базовым?\r\n```cpp\r\nenum class color : std::size_t { red, green, blue };\r\n\r\nstd::size_t c1 = static_cast<std::size_t>(color::green); //ok\r\nstd::size_t c2 = color::red; //error\r\n\r\n//или\r\n\r\nstd::size_t blend(std::size_t c1, std::size_t c2, ...) { ... }\r\n\r\nauto bc1 = blend(\r\n    static_cast<std::size_t>(color::red),\r\n    static_cast<std::size_t>(color::green)); //ok\r\nauto bc2 = blend(color::red, color::blue); //error\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/179/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/179/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/178",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/178/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/178/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/178/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/178",
    "id": 839461014,
    "node_id": "MDU6SXNzdWU4Mzk0NjEwMTQ=",
    "number": 178,
    "title": "getter of pointer to nested exception from exception_ptr to containing object",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T08:04:00Z",
    "updated_at": "2021-03-24T08:04:19Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -0\r\n_Автор идеи:_ **Antervis**\r\n\r\nДобавить функцию-геттер вида exception_ptr nested_exception_of(exception_ptr eptr); возвращающую исключение, вложенное в исключение по указателю eptr\r\n\r\nНа данный момент единственный способ получить вложенное исключение - std::rethrow_if_nested. У этого подхода есть два недостатка:\r\n\r\n1. Обработка вложенных исключений в одном try-catch блоке возможно только при использовании рекурсии\r\n\r\n2. Нет возможности напрямую поднять вложенное исключение, используя std::exception_ptr.\r\n\r\n \r\n\r\nЖелаемого функционала можно добиться примерно следующим образом:\r\n```cpp\r\nstd::exception_ptr nested_exception_of(std::exception_ptr eptr) {\r\n    try {\r\n        std::rethrow_exception(eptr);\r\n    } catch (std::exception &e) {\r\n        try {\r\n            std::rethrow_if_nested(e);\r\n            return std::exception_ptr();\r\n        } catch (...) {\r\n            return std::current_exception();\r\n        }\r\n    }\r\n}\r\n```\r\nНедостатки:\r\n\r\n1. на обработку каждого исключения понадобится три try-catch блока\r\n\r\n2. необходимо явно указать все (хотя бы) базовые типы для исключений в приложении\r\n\r\n3. такой подход не поддерживает объекты исключений, не являющиеся ни полиморфными, ни наследниками от std::nested_exception\r\n\r\n \r\n\r\nЧто это даст:\r\n\r\nВ стандартной библиотеке появится возможность обрабатывать вложенные исключения не рекурсивно, а в цикле (в дополнение можно будет легко написать forward iterator/range для вложенных исключений). Примерно следующим образом:\r\n```cpp\r\ntry {\r\n    try {\r\n        new int[100000][10000];\r\n    } catch (...) {\r\n        std::throw_with_nested(std::runtime_error(\"test error\"));\r\n    }\r\n} catch (...) {\r\n    for (auto e = std::current_exception(); e; e = nested_exception_of(e)) {\r\n        try {\r\n            std::rethrow_exception(e);\r\n        } catch (std::runtime_error &e) {\r\n            std::cout << \"runtime error: \" << e.what() << std::endl;\r\n        } catch (std::bad_alloc &e) {\r\n            std::cout << \"bad alloc: \" << e.what() << std::endl;\r\n        }\r\n    }\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/178/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/178/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/177",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/177/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/177/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/177/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/177",
    "id": 839419898,
    "node_id": "MDU6SXNzdWU4Mzk0MTk4OTg=",
    "number": 177,
    "title": "Токенизатор в string надо бы",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-24T07:02:50Z",
    "updated_at": "2023-10-23T07:34:19Z",
    "closed_at": "2023-10-23T07:33:58Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +18, -4\r\n_Автор идеи:_ **Pavel**\r\n\r\nПростая задача - разбить std:string (или char*) на контейнер со std:string по заданному разделителю. Например на входе \"11:4:5:77:989\" на выходе контейнер с \"11\",\"4\",\"5\",\"77\",\"989\".\r\n\r\n11 строк кода всегда с собой таскать что ли? Ну для полноты картины можно специфицировать для использования с разными контейнерами и т.д. (можно заняться, если надо). Ну ведь часто надо же и везде приходится либо так либо дремучий и деструктивный strtok использовать. В бусте есть токенизатор, но он сложный какой-то. Реализация влоб для демонстрации:\r\n```cpp\r\nvector<string> splitLine( const char *str, char c )\r\n{\r\n\tvector<string> result;\r\n\tdo\r\n\t{\r\n\t\tconst char *begin = str;\r\n\t\twhile ( *str != c && *str )\r\n\t\t{\r\n\t\t\tstr++;\r\n\t\t}\r\n\t\tresult.push_back( string( begin, str ));\r\n\t} while ( 0 != *str++ );\r\n\treturn result;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/177/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/177/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/176",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/176/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/176/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/176/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/176",
    "id": 839419052,
    "node_id": "MDU6SXNzdWU4Mzk0MTkwNTI=",
    "number": 176,
    "title": "Одна функция для получения случайных чисел.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-24T07:01:29Z",
    "updated_at": "2021-03-24T07:02:00Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -6\r\n_Автор идеи:_ **Лягуха Пепе**\r\n\r\nСейчас, чтобы получить случайное число в некоем промежутке, надо написать неочивдную портянку: http://www.cppsamples.com/common-tasks/roll-a-die.html\r\nПредложение добавить обертку в виде функции Random(T min, T max), заодно работающую для всех числовых и вещественных типов. Примерная реализация ниже.\r\n\r\n```cpp\r\n#include <random>\r\n#include <limits>\r\n\r\nnamespace Starl1ght {\r\n\tnamespace Internal {\r\n\t\ttemplate<typename ENGINE>\r\n\t\tENGINE& GetEngine() {\r\n\t\t\tstatic std::random_device random_device;\r\n\t\t\tstatic ENGINE engine{ random_device() };\r\n\t\t\treturn engine;\r\n\t\t}\r\n\t}\r\n\r\n\ttemplate <typename T, typename U>\r\n\tT Random(const T& from, const U& to) {\r\n\t\tstatic_assert(std::is_same<T, U>::value, \"Random() called with different types\");\r\n\t\treturn T{};\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\ttypename std::enable_if<!std::is_integral<T>::value && !std::is_floating_point<T>::value, T>::type\r\n\tRandom(const T& from = std::numeric_limits<T>::lowest(), const T& to = std::numeric_limits<T>::max()) {\r\n\t\tstatic_assert(std::is_same<T, void>::value, \"Random() called with non-number type\");\r\n\t\treturn T{};\r\n\t}\r\n\r\n\ttemplate <typename T, typename ENGINE = std::mt19937>\r\n\ttypename std::enable_if<std::is_integral<T>::value, T>::type\r\n\tRandom(const T& from = std::numeric_limits<T>::min(), const T& to = std::numeric_limits<T>::max()) {\r\n\t\treturn std::uniform_int_distribution<T>{ from, to }(Internal::GetEngine<ENGINE>());\r\n\t}\r\n\t\r\n\ttemplate <typename T, typename ENGINE = std::mt19937>\r\n\ttypename std::enable_if<std::is_floating_point<T>::value, T>::type\r\n\tRandom(const T& from, const T& to) {\r\n\t\treturn std::uniform_real_distribution<T>{ from, to }(Internal::GetEngine<ENGINE>());\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tauto f = Starl1ght::Random(3.f, 5.f);\r\n\treturn Starl1ght::Random(1, 5);\r\n}\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/176/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/176/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/175",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/175/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/175/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/175/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/175",
    "id": 838935957,
    "node_id": "MDU6SXNzdWU4Mzg5MzU5NTc=",
    "number": 175,
    "title": "адаптер std::as_const",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T17:04:26Z",
    "updated_at": "2021-03-23T17:05:09Z",
    "closed_at": "2021-03-23T17:05:09Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -4\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nдля удобного каста объекта из T&/T&& в const T&\r\nудобно, если хочется для lvalue/rvalue вызвать методы, имеющие и const и & перегрузки\r\n\r\nреализцаия\r\n```cpp\r\ntemplate<class T>\r\nconst T& as_const(T&& v) {\r\n    return val;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/175/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/175/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/174",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/174/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/174/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/174/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/174",
    "id": 838934157,
    "node_id": "MDU6SXNzdWU4Mzg5MzQxNTc=",
    "number": 174,
    "title": "const перегрузки для operator[] в std::map/std::unordered_map",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T17:02:24Z",
    "updated_at": "2021-03-23T17:03:21Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -9\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nповедение простое - должны действовать аналогично at(TKey) const\r\nв частности std::out_of_range при отстутствии элемента в контейнере",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/174/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/174/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/173",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/173/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/173/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/173/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/173",
    "id": 838932191,
    "node_id": "MDU6SXNzdWU4Mzg5MzIxOTE=",
    "number": 173,
    "title": "Итератор по чанкам std::deque",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-23T17:00:03Z",
    "updated_at": "2021-03-27T12:08:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -3\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nstd::deque отличный контейнер : у него не инвалидится итераторы, в него удобно делать push_back. Но его данные не лежат непрерывно в памяти. Часто std::deque используется для агрегации данных (через push_back) , а затем данные копируются в vector. Это копирование даже для pod типов не может использовать векторизацию (например через memcpy), так как в логике инкримента итераторов не просто ptr++. Предлагается добавить возможность итерироваться по чанкам, в рамках которых данные лежат непрерывным куском.\r\n\r\nЭто может выглядить примерно так.\r\n```cpp\r\nvoid iterate_simple(std::deque<int>& in, std::vector<int>& out) {\r\n    out.reserve(in.size());\r\n    for(int& x : in) {\r\n        out.push_back(x);\r\n    }\r\n}\r\n\r\nvoid iterate_new(std::deque<int>& in, std::vector<int>& out) {\r\n    out.reserve(in.szie());\r\n    for(const auto& c : d.chunks()) {\r\n        //example of iterations on elements:\r\n        for(int& x : c) {\r\n           out.push_back(x);\r\n        }\r\n    }\r\n}\r\n\r\nvoid copy_with_memcpy(std::deque<int>& in, std::vector<int>& out) {\r\n    out.resize(in.szie());\r\n    for(const auto& c : d.chunks()) {\r\n        memcpy(out.begin() + c.begin_index(), c.begin(), sizeof(int) * c.size());\r\n    }\r\n}\r\n```\r\nТакже предлагается добавить специализацию для преобразования из deque в вектор, использующую итерирование по чанкам.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/173/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/173/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/172",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/172/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/172/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/172/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/172",
    "id": 838929771,
    "node_id": "MDU6SXNzdWU4Mzg5Mjk3NzE=",
    "number": 172,
    "title": "Конструктор для контейнеров (прежде всего std::vector) для указания начального capacity",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T16:57:19Z",
    "updated_at": "2021-03-23T16:58:37Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -7\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nСтандартным является код: std::vector data; data.reserve(some_value); /*for with push_back/* .\r\nПредлагается убрать уродливую двухстрочную инициализацию, и разрешить код вида std::vector data(std::reserve(10));\r\n\r\nИмплиментация кажется очень простой, достаточно типа\r\n```cpp\r\nstruct container_init_capacity_holder {\r\n     size_t val;\r\n}\r\n```\r\nи одной специализации конструктора.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/172/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/171",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/171/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/171/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/171/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/171",
    "id": 838928115,
    "node_id": "MDU6SXNzdWU4Mzg5MjgxMTU=",
    "number": 171,
    "title": "Явная инициализация мусором",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-23T16:55:30Z",
    "updated_at": "2023-10-23T07:37:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -7\r\n_Автор идеи:_ **ilnurkh**\r\n\r\nВозможность не задавать инициализирующий значения является постоянным источником ошибок. Более того, в ряде случаев не возможность явного указания отсутствия начального значения является причиной ненужных действий (например при необходимости создать std::vector с заданным количеством элементов а затем перезаписать все его значения).\r\nПредлагаю для начала разрешить код вида: int var = std::uninitialized(); .\r\nА также дать возможность писать подобное std::vector vector_with_trash(100, std::unitialized_constructor);\r\n\r\nВ более радикальной формулировке предлагается запретить создавать переменные и поля без начальных значений. Отказ от явной инициализации должен быть обозначен явным std::uninitialized\r\n\r\nОбращаю внимание, что нельзя просто писать std::vector vector_with_trash(100, std::uninitialized<int>()); потому что такой код должен создать вектор со 100 одинаковыми значениями (пусть и мусорными).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/171/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/171/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/170",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/170/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/170/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/170/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/170",
    "id": 838922785,
    "node_id": "MDU6SXNzdWU4Mzg5MjI3ODU=",
    "number": 170,
    "title": "Идеи про оператор = после определения методов классов.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-23T16:49:29Z",
    "updated_at": "2021-03-23T16:54:09Z",
    "closed_at": "2021-03-23T16:52:41Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -6\r\n_Автор идеи:_ **int33h-tm**\r\n\r\nРасширить возможности использования оператора = после определения методов класса.\r\n\r\nПредложение 1: автоопределение методов.\r\n\r\nПредлагаю сделать возможность сказать компилятору, чтобы какой-то метод он определил на основе уже имеющихся...\r\nДопустим что для некоторого класса мы реализовали оператор ==, а теперь хотим определить оператор !=. В большинстве случаев реализация будет примерно следующей:\r\n\r\n \r\n```cpp\r\nclass Type{\r\n    ...\r\npublic:\r\n    ...\r\n    friend bool operator == (const Type& left, const Type& right);\r\n    friend bool operator != (const Type& left, const Type& right);\r\n    ...\r\n};\r\n\r\nbool operator == (const Type& left, const Type& right) {\r\n\r\n...\r\n\r\n}\r\n\r\nbool operator != (const Type& left, const Type& right) {return !(left == right);}\r\n```\r\nПонятно, что второй оператор компилятор может сгенерировать и сам, как он это делает с конструктором и оператором копирования по умолчанию. Поэтому можно сказать ему например такую фразу:\r\n```cpp\r\nclass Type{\r\n    ...\r\npublic:\r\n    ...\r\n    friend bool operator == (const Type& left, const Type& right);\r\n    friend bool operator != (const Type& left, const Type& right) = auto;\r\n    ...\r\n};\r\n```\r\nИ оставить генерацию кода на компиляторе...\r\nP.S. Также, возможно, стоит запретить генерацию методов по умолчанию и заставлять програмистов прописовать их таким образом, чтобы \"вскрыть\" неявное...\r\nP.P.S. Еще парочку примеров на идею:\r\n```cpp\r\nclass Type{\r\n    ...\r\npublic:\r\n    ...\r\n    void __copy__(const Type& another); //специальный метод копирования класса\r\n    //занимается только копированием внутренних полей класса\r\n    Type(const Type& another) = auto; //используем __сopy__\r\n    const Type& operator=(const Type& another) = auto; //используем __copy__\r\n    ...\r\n    friend bool operator<(const Type& left, const Type& right);\r\n    friend bool operator<=(const Type& left, const Type& right) = auto; \r\n    //return (left < right)||(left == right);\r\n    friend bool operator>(const Type& right, const Type& right) = auto;\r\n    //return !((left < right)||(left == right));\r\n    friend bool operator>=(const Type& right, const Type& right) = auto;\r\n    //return !(left < right);\r\n    ...\r\n};\r\n\r\n//Компилятор должен контролировать возвращаемое значение и передаваемые аргументы для auto методов.\r\n//В случае несовпадения с шаблоном auto, выдавать соответсвующую ошибку с предлагаемым решением.\r\n```\r\n\r\nПредложение 2: механизм связываний\r\n\r\nТот же самый оператор позволяет заменить и inline функции:\r\n```cpp\r\nclass Type{\r\n    ...\r\npublic:\r\n    ...\r\n    void do_something(int a, int b);\r\n    void do_something2(int a) = do_something(a, 5); \r\n    //подстановка вместо do_something2(c);\r\n    //do_something(c, 5);\r\n    ...\r\n}\r\n\r\n//если требуется больше одной инструкции, то все они помещаются в {}.\r\n//void do_something2(int a) = {do_something(a, 5); do_something(5, a);}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/170/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/170/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/169",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/169/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/169/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/169/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/169",
    "id": 838920570,
    "node_id": "MDU6SXNzdWU4Mzg5MjA1NzA=",
    "number": 169,
    "title": "Функциональные объекты.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T16:46:58Z",
    "updated_at": "2021-03-23T16:48:00Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -6\r\n_Автор идеи:_ **int33h-tm**\r\n\r\nДобавить в язык С++ удобные средства для работы с функциями, генераторы, над-функции(инвертированные подпрограммы)\r\n\r\nПредложение1: функциональные объекты.\r\n\r\nВ языке С, как и в C++ можно определять указатели на функции, но присвоить одному типу указателя другой невозможно, а самое главное - нельзя получить адрес \"сырой функции\" в памяти никакими средствами языков(поправьте если я не прав). Так вот, было бы неплохо добавить в эти языки такие возможности, например, вот так:\r\n```cpp\r\n//Cырые функции\r\n\r\nint sumi(int a, int b){\r\n    return a + b;\r\n}\r\n\r\nfloat sumf(float a, float b){\r\n    return a + b;\r\n}\r\n\r\nint main(){\r\n    raw_function f() = &sumi; //получение адреса вызова для asm команды call\r\n    int a = 5, b = 8;\r\n    a = f(a, b); //переход по адресу функции\r\n    f = &sumf;\r\n    float c = 0.5, b = 1.2;\r\n    c = f(c, b);\r\n    return 0;\r\n}\r\n\r\n//общий алгоритм анализа:\r\nraw_function f(); //не происходит никаких проверок\r\nraw_function f(void, void); //+ контроль числа аргументов\r\nraw_function f(std::string, void) //+ проверка первого типа\r\nraw_function f(std::string, void) -> std::string; //+ проверка возвращаемого значения\r\n//void указывает на вариативность присвоения, т.е. вместо void-а может фигурировать любой тип.\r\n//все проверки делаются на этапе компиляции.\r\n//в случае перегруженных функций надо указывать после имени ее параметры - &sum(int a, int b)\r\n\r\n//Объект - функция\r\n\r\n...\r\n\r\nint main(){\r\n    function f = &sumi;\r\n    ...\r\n}\r\n\r\n//общий алгоритм анализа:\r\n//на этапе компиляции для каждой функции которая присваивается f генерится специальный проверяющий метод.\r\n//данный метод занимается жесткой проверкой передаваемых аргуметнов на этапе выполнения, например, с помощью typeid().\r\n//в случае несовпадения бросается исключение...\r\n//если проверка пройдена, делается переход на код функции без всяких дополнительных проверок.\r\n//при присвоении в f записывается указатель на проверяющий метод.\r\n```\r\n\r\nПредложение2: генераторы.\r\n\r\nВремя добавить в С++ немножечко python-а.\r\n```cpp\r\ngenerator natural_numbers(int start_from = 1) -> int{\r\n    int curr = start_from;\r\n    while(true){\r\n        return curr;\r\n        ++curr;\r\n    }\r\n}\r\n```\r\nГенераторы - особый объект который похож на функцию, при этом ею не являясь.\r\n```cpp\r\n//Использование\r\n\r\nint main(){\r\n    generator g = natural_numbers(); //объявление с инициализацией\r\n    int a = g(); //получение первого значения\r\n}\r\n```\r\nКлючевое слово static накладывает на генератор следующие ограничения:\r\n\r\n*    генератор выделяется до начала работы программы, поэтому не может иметь аргументов.\r\n*    генератор не может вызывать себя рекурсивно.\r\n*    генератор должен быть определен в месте объявления, чтобы исключить случай взаимосвязанных генераторов.\r\n*    все объекты использующие генератор будут разделять его.\r\n*    вызов генератора по имени теперь будет возвращать значение вместо инициализации [b = natural_numbers2();]\r\n\r\nP.S. Ограничения static для генераторов можно реализовать и в текущем стандарте с помощью статических переменных.\r\n\r\nПредложение3: Над-функции.\r\n\r\nPre.S. В текущем стандарте этот механизм реализуется с помощью специальных классов и то не полно.\r\n\r\nПодпрограммы в языке С++ мы умеем вызывать, а что если мы хотим наоборот вставить нашу подпрограмму в некий объемлющий код, как например в циклах for и while. Например, вот так:\r\n```cpp\r\nint main(){\r\n    int a;\r\n    open(\"input.txt\"){\r\n        fscanf(\"%d\", &a);\r\n        printf(\"%d\", a);\r\n    }\r\n    return 0;\r\n}\r\n```\r\nЧтож, теперь попробуем представить как должна выглядеть собственно наша над-функция:\r\n```cpp\r\nover_function open_read(char* name){\r\n    FILE* f = fopen(name, \"r\");\r\n    code;\r\n    fclose(f);\r\n}\r\n\r\n//умышленно не делаю никакик проверок, чтобы не загромаждать код.\r\n//строка code; - обозначение места вставки внутреннего кода.\r\n```\r\nОтлично. Но как быть с if-конструкцией? Ведь у нее два участка кода. Тоже легко:\r\n```cpp\r\n//рассмотрим более сложный оператор if из python-a\r\n\r\n//cначала определяем\r\ncomplex over_function:\r\n    if (bool) -> [elif (bool)] [else];\r\n    elif (bool) -> [elif (bool)] [else];\r\n\r\n//после if-a может идти либо elif, либо else.\r\n//после elif-а может идти либо elif, либо else.\r\n//квадратные скобки обозначают необязательность дальнейших операторов.(подробнее в форме Бэкуса—Наура)\r\n\r\n//теперь реализуем\r\n//Реализация не очень приятная из-за использования ассемблерных вставок, так что опустим\r\nover_function if(bool cond){\r\n    ...\r\n}\r\n\r\nover_function elif(bool cond){\r\n    ...\r\n}\r\n\r\nover_function else(){\r\n    ...\r\n}\r\n```\r\nОстается только одна проблема: что делать, когда у над-функции больше одного аргумента... С одной строны, аргументы мы обязаны принимать через [;], а с другой стороны над-функция очень похожа на обычную функцию, поэтому логично принимать аргуметы через [,]. Тут я не знаю, что выбрать.\r\n```cpp\r\nopen(\"input.txt\", \"r\") {...} //либо так\r\nopen(\"input.txt\"; \"r\") {...} //либо так \r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/169/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/169/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/168",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/168/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/168/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/168/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/168",
    "id": 838918379,
    "node_id": "MDU6SXNzdWU4Mzg5MTgzNzk=",
    "number": 168,
    "title": "Copy-on-write std::basic_string",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T16:44:33Z",
    "updated_at": "2021-04-07T08:49:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -16\r\n_Автор идеи:_ **Олег Ляттэ**\r\n\r\nСейчас, насколько я знаю, реализации строк через COW препятствуют некоторые требования к интерфейсу строк. В частности, чтобы получение неконстантного итератора или референса на символ не инвалидировало другие итераторы и референсы. И отмена такого требования может привести к определённым проблемам (все мы натыкались на обращение по инвалидному итератору - неприятная штука). Однако, возможно, стоит попытаться как-то приемлемо разрулить эту проблему.\r\n\r\n \r\nВедь сколько пользы принесёт COW string!\r\n\r\n1. Станут не нужны всякие string_ref и string_view. Эффективные референсы на подстроки можно будет реализовать прямо в substr()\r\n\r\n2. Более экономномное использование памяти. Дополнительная память не выделяется, если одна и та же строка должна храниться в нескольких местах.\r\n\r\n3. Следствие из предыдущего пункта: если забыл сделать строке std::move - не беда, копирование строк станет очень дешёвым.\r\n\r\n4. Можно будет конструировать полнофункциональные std::string из строковых литератов без аллоцирования памяти.\r\n\r\nВозможно, и другие плюшки.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/168/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/168/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/167",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/167/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/167/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/167/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/167",
    "id": 838913811,
    "node_id": "MDU6SXNzdWU4Mzg5MTM4MTE=",
    "number": 167,
    "title": "Прозрачные компараторы std::less/std::greater для std::basic_string",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T16:39:14Z",
    "updated_at": "2021-03-23T16:43:32Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -2\r\n_Автор идеи:_ **mrgordonfreman**\r\n\r\n\r\nДобавить особые специализации компараторов (std::less, std::greater и т.д.) для std::basic_string, чтобы избавиться от создания временных объектов при работе с ассоциативными контейнерами (std::set, std::map), в которых ключом является стандартная строка.\r\n\r\nРассмотрим пример (clang 4.0, libc++ из trunk)\r\n```cpp\r\nstd::map<std::string, int> m;\r\nm[\"test\"] = 1;\r\nm.find(\"test\"); // вызывается конструктор ключа, т.е. строки\r\nstd::string_view sv = \"test\";\r\nm.find(sv); // не компилируется, у строки explicit конструктор по view\r\n```\r\nВ C++14 в контейнеры std::map и std::set были добавлены функции вида\r\n```cpp\r\ntemplate< class K > iterator find( const K& x );\r\ntemplate< class K > const_iterator find( const K& x ) const;\r\n```\r\nОни основываются на перегрузках оператора () у компаратора (который по умолчанию std::less) и не создают инстанс ключа. Но чтобы этот механизм заработал, компаратор должен обладать следующим свойством - выражение Compare::is_transparent должно быть корректным и обозначать тип (любой). Таким образом, библиотека предлагает написать свой компаратор и передать его через шаблонные параметры контейнера.\r\n\r\nТип std::basic_string наряду с целыми числами - основа любой программы на C++. Именно строки и числа чаще всего используются в качестве ключей в ассоциативных контейнерах. Но в текущей ситуации приходится постоянно помнить о том, что нужно прописать свой компаратор в очередной map или set (который все равно работает аналогично std::less). \r\n\r\nПредлагается передать эту ответственность стандартной библиотеке. Специализацию std::less для строки можно реализовать примерно так\r\n```cpp\r\nnamespace std\r\n{\r\n\r\ntemplate<class CharT>\r\nstruct less<std::basic_string<\r\n    CharT, std::char_traits<CharT>, std::allocator<CharT>>>\r\n{\r\n    using str_type = std::basic_string<\r\n        CharT, std::char_traits<CharT>, std::allocator<CharT>>;\r\n    \r\n    using is_transparent = void; // Enable comparison with the view\r\n    \r\n    template<class T>\r\n    bool operator ()(str_type const& lhs, T&& rhs) const {\r\n        return lhs < rhs;\r\n    }\r\n    \r\n    template<class T>\r\n    bool operator ()(T&& lhs, str_type const& rhs,\r\n        typename std::enable_if<!std::is_same_v<str_type,\r\n            typename std::decay<T>::type>>::type* = nullptr) const {\r\n        return lhs < rhs;\r\n    }\r\n};\r\n\r\n}\r\n```\r\nТеперь со строками все будет работать как надо по умолчанию.\r\n```cpp\r\nm.find(\"test\"); // строка не создается\r\n// std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()<char const (&) [5]>(...)\r\nstd::string_view sv = \"test\";\r\nm.find(sv); // компилируется, строка не создается\r\n// std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::operator()<std::basic_string_view<char, std::char_traits<char> > const&>(...)\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/167/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/167/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/166",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/166/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/166/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/166/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/166",
    "id": 838912302,
    "node_id": "MDU6SXNzdWU4Mzg5MTIzMDI=",
    "number": 166,
    "title": "order_of_key и find_by_order для set/map/multiset/multimap",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T16:37:25Z",
    "updated_at": "2021-03-23T16:37:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -0\r\n_Автор идеи:_ **Тимофей Чернов**\r\n\r\norder_of_key - количество элементов, меньше заданного, find_by_order - найти элемент с заданным количеством элементов меньше него для set/map/multiset/multimap\r\n\r\nСейчас в map/set и подобных структурах данных, основанных на сбалансированных деревьях, есть функции lower_bound и upper_bound, выполняющие поиск за O(logN). Однако, функций нахождения количества элементов заданного и ей обратной - нет, поэтому приходится писать тяжеловесные структуры данных вроде деревьев отрезков или собственных сбалансированных деревьев, тогда как для добавления этой функциональности в уже существующие структуры нужно всего лишь хранить размер поддерева.\r\n\r\nФункция find_by_order, кстати говоря, является аналогом nth_element. \r\n\r\nСтоит отметить, что данная функциональность реализована в GCC, выглядит это так:\r\n```cpp\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\n#include <iostream>\r\n\r\ntemplate<typename T>\r\nusing ordered_set = __gnu_pbds::tree<\r\n  T,\r\n  __gnu_pbds::null_type,\r\n  std::less<T>,\r\n  __gnu_pbds::rb_tree_tag,\r\n  __gnu_pbds::tree_order_statistics_node_update>;\r\n\r\nint main() {\r\n  ordered_set<int> s;\r\n  s.insert(1);\r\n  s.insert(3);\r\n  s.insert(5);\r\n  s.insert(7);\r\n  s.insert(9);\r\n\r\n  // prints 2 - number of elements strictly less than 5\r\n  std::cout << s.order_of_key(5) << std::endl;\r\n  \r\n  // prints 9 - 4'th element in sorted order\r\n  std::cout << *s.find_by_order(4) << std::endl;\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/166/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/166/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/165",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/165/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/165/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/165/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/165",
    "id": 838909515,
    "node_id": "MDU6SXNzdWU4Mzg5MDk1MTU=",
    "number": 165,
    "title": "Форматированный std::to_string()",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      },
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-23T16:34:06Z",
    "updated_at": "2021-03-23T16:36:13Z",
    "closed_at": "2021-03-23T16:36:13Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -1\r\n_Автор идеи:_ **Тимофей Чернов**\r\n\r\nНе хватает функциональности форматирования строки при использовании std::to_string(numeric_value).\r\n\r\nПримером форматирования могут быть манипуляторы <iomanip> - если хочется зафиксировать ширину числа (setfill/setw), точность (setprecision) или основание системы счисления (base).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/165/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/165/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/164",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/164/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/164/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/164/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/164",
    "id": 838903819,
    "node_id": "MDU6SXNzdWU4Mzg5MDM4MTk=",
    "number": 164,
    "title": "Стандарт описания зависимостей для языка C++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-23T16:28:18Z",
    "updated_at": "2023-10-23T08:19:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -1\r\n_Автор идеи:_ **Павел Филонов**\r\n\r\nЕсли вместе со стандартом языка будет представлен и формат для описания зависимостей\r\nсборки, то это потенциально мотивирует различные менеджеры зависимостей\r\nподдержать этот формат, по аналогии с тем, как разработчики компиляторов реализуют\r\nстандарт языка.\r\n\r\nНа данный момент разработчики привыкли к ситуации, что формат описания зависимостей не является частью языка и его стандарта.\r\n\r\n\r\nЭто приводит к тому, что каждый менеджер зависимостей придумывает свой собственный формат. И, на первый взгляд, это не имеет отношение к стандарту языка.\r\n\r\n \r\nНо, если задуматься, то формат описания зависимостей - это просто формальныеправила, которые определяют синтаксис и семантику, а реализация отдается уже на откуп производителям.\r\n\r\n\r\n\r\nУ нас уже есть пример такого подхода - стандарт языка C++. Имеется формальное описание, а разработчики компиляторов уже предлагают свои реализации. Именно такой подход позволяет собирать код, написанный на одном языке, разными компиляторами (с оговорками).\r\n\r\n \r\n\r\nЕсли вместе со стандартом языка будет представлен и стандарт для описания зависимостей сборки, то это потенциально мотивирует различные менеджеры зависимостей поддержать этот формат, по аналогии с тем, как разработчики компиляторов реализуют стандарт языка.\r\n\r\n \r\n\r\nИз ближайших аналогов подобного описания можно привести в качестве примеров:\r\n\r\n*    conanfile.txt\r\n*    .nuspec\r\n*    PEP400\r\n*    Cargo\r\n\r\n \r\n\r\nСписок открытых вопросов:\r\n\r\n*    Нужно ли такое описание стандарте? (здесь поможет голосование)\r\n*    Какие схемы версионирования нужно поддерживать?\r\n*    Какой должен быть синтаксис описания зависимостей?\r\n*    Какие ограничения на версии можно накладывать?\r\n\r\n \r\n\r\nОтветы на все эти вопросы требуют детальной проработки материала. Если ответ на\r\n\r\n1-й вопрос будет положительным, то можно будет приступить к остальным.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/164/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/164/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/163",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/163/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/163/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/163/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/163",
    "id": 838902515,
    "node_id": "MDU6SXNzdWU4Mzg5MDI1MTU=",
    "number": 163,
    "title": "constexpr operator",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T16:26:46Z",
    "updated_at": "2021-03-23T16:27:06Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -3\r\n_Автор идеи:_ **Antervis**\r\n\r\nОператор constexpr( statement ) -> decltype(statement) - попытаться вычислить не объявленное явно как constexpr выражение в compile-time\r\n\r\nОператор constexpr( statement ) -> decltype( statement )  - попытаться вычислить не объявленное явно как constexpr выражение в compile-time, либо выдать ошибку компиляции\r\n\r\nДопустим, мы имеем простую функцию, не объявленную как constexpr:\r\n```cpp\r\nfloat foo(float x, float y) {\r\n    return x*y;\r\n}\r\n```\r\nИдея в том, чтобы иметь возможность вызвать её в constexpr-контексте (или выдать ошибку, если это невозможно):\r\n```cpp\r\nconstexpr float val1 = constexpr(foo(3,5)); // OK\r\n\r\nint i;\r\ncin >> i;\r\nconstexpr float val2 = constexpr(foo(4,i)); // fail: i is not compile-time constant\r\n\r\nfloat bar();\r\nconstexpr float val3 = constexpr(foo(7,bar())); // fail: bar is declared, but not defined\r\n\r\nfloat baz() { return 15.2; } // note: baz() is not marked as constexpr\r\nconstexpr float val4 = constexpr(foo(2,baz())); // OK, same as constexpr(foo(2,constexpr(baz())))\r\n```\r\nДля этого необходимо:\r\n\r\n*    все операторы внутри statement полностью определены\r\n*    все операторы внутри statement удовлетворяют требованиям constexpr-функций, за исключением спецификатора constexpr\r\n*    все аргументы функций внутри statement либо являются compile-time константами, либо рекурсивно вычислимы через constexpr(...)\r\n\r\nКак это должно работать:\r\n\r\n*    все операторы внутри statement рекурсивно проверяются на вычислимость во время компиляции. То есть они должны либо соответствовать требованиям constexpr-функций (так же, как если бы они были явно помечены constexpr), либо быть контекстуально вычислимы (например, на основе контрактов).\r\n*    все негативные ветки if statement-ов подавляются (так, словно вместо if используется if constexpr)\r\n*    все аргументы функций проверяются на вычислимость на этапе компиляции\r\n*    вычисляется statement\r\n\r\nЧто это дает:\r\n\r\n*    возможность более оптимальной работы со старым кодом\r\n*    явное вычисление constexpr-значений\r\n*    возможность вычисления значений на основе контекстуальной информации\r\n*    возможность дополнительных оптимизаций\r\n\r\nПример к п.4.: например:\r\n```cpp\r\nstring str = \"short str\";\r\n```\r\nзная в compile-time, что Small String Optimization потенциально позволяет создать std::string из const char* длиной не более 11 символов как constexpr-значение. Но в языке нет возможности проверить аргумент runtime функции на этапе компиляции. Используя оператор constexpr() таким образом:\r\n```cpp\r\nauto str = constexpr(string(\"short str\"));\r\n```\r\nдлина строки будет проверена на этапе компиляции, ветка с выделением памяти будет подавлена, конструктор std::string(const char *) окажется вычислимым на этапе компиляции",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/163/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/163/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/162",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/162/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/162/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/162/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/162",
    "id": 838877228,
    "node_id": "MDU6SXNzdWU4Mzg4NzcyMjg=",
    "number": 162,
    "title": "Жалобы на ranges.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T15:59:52Z",
    "updated_at": "2021-03-23T16:00:47Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **d-yaroshev**\r\n\r\nУ range есть проблема с прокси итераторами. Решение Eric Niebler хоть и работает, выглядит ну очень сложным и ведет к еще большему набору странностей в С++. Ranges должны вести к чистому коду, очень хотелось бы этого избежать. \r\n\r\nЯ не уверен в том, что у меня на 100% актуальные данные\r\nПроблема 1: auto.\r\n\r\nа)\r\n```cpp\r\nfor (auto x : range)\r\n```\r\n - сейчас означает создать копию объекта из range. В range-v3 оно начинает иметь семантику auto&, но не всегда, а только для прокси итераторов. В шаблонном контексте вообще прийдется отказыватся от auto и использовать\r\n```cpp\r\nfor (typename Range::value_type x : range)\r\n```\r\n, что менее приятно. Вообще auto в циклах становится плохой практикой.\r\n\r\nб) Вместо auto& прийдется использовать auto&&, которое раньше было зарезвировано исключительно для магов. При условии что ranges должны делать код проще, не кажется что это здорово.\r\n\r\nв)\r\n\r\nЯ не уверен что будет работать structure binding:\r\n\r\n ```cpp\r\ntemplate <typename Pairs>\r\nvoid update_first(Pairs pairs) {\r\n  for (auto& [first, second] : range_of_pairs)\r\n    update(first);\r\n}\r\n```\r\nЯ не могу сказать, что очень понимаю как оно устроено, но вызов этой функции с zip_view кажется сомнительным. (мб опять нужен auto&&)\r\n\r\nПроблема 2: предикаты.\r\n\r\nВсе на 100% должно быть шаблонным, иначе получаются непонятные ошибки компиляции.\r\nНапример вот это не компилируется. \r\n```cpp\r\nstruct map_less {\r\n  template <typename T>\r\n  bool operator()(const T& x, const T& y) const {\r\n    return x.first < y.first;\r\n  }\r\n};\r\n\r\nint main() {\r\n  std::vector<int> keys = {1, 3, 2};\r\n  std::vector<std::string> values = {\"a\", \"c\", \"b\"};\r\n  sort(view::zip(keys, values), map_less{});\r\n}\r\n```\r\nДаже можно разобраться почему но от этого не сильно приятнее.\r\n\r\n\r\nВ целом - все это не страшно, можно отслеживать и опытные разработчики на С++ со всем справятся. Просто грустно что библиотека, которая главным образом должна делать код проще требует очередное know-how. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/162/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/162/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/161",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/161/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/161/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/161/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/161",
    "id": 838839755,
    "node_id": "MDU6SXNzdWU4Mzg4Mzk3NTU=",
    "number": 161,
    "title": "Разрешить шаблонные локальные классы",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T15:20:42Z",
    "updated_at": "2021-03-23T15:23:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -0\r\n_Автор идеи:_ **Сергей Садовников**\r\n\r\nПо состоянию на текущий момент стандарт позволяет объявлять полиморфные лямбда-функции (которые, согласно стандарту же) генерируются с шаблонным оператором вызова функции. Также стандарт разрешать использовать локальные классы в качестве параметров шаблонов. Также в стандарт включен std::variant<>. Но очень сложно собрать всё это вместе. Например, можно написать:\r\n```cpp\r\n#include <iostream>\r\n#include <variant>\r\n#include <string>\r\n\r\nusing TestType = std::variant<int, std::string>;\r\n\r\nint main()\r\n{\r\n    TestType v1{1};\r\n    TestType v2{\"Hello World!\"};\r\n    \r\n    auto visitor = [](auto&& val) {std::cout << val << std::endl;};\r\n    \r\n    std::visit(visitor, v1);\r\n    std::visit(visitor, v2);\r\n}\r\n```\r\nЧто выведет ожидаемое:\r\n```\r\n1\r\nHello World!\r\n```\r\nНо, при желании кастомизировать обработку для конкретного типа, нельзя написать:\r\n```cpp\r\n#include <iostream>\r\n#include <variant>\r\n#include <string>\r\n\r\nusing TestType = std::variant<int, double, std::string>;\r\n\r\nint main()\r\n{\r\n    TestType v1{1};\r\n    TestType v2{0.123};\r\n    TestType v3{\"Hello World!\"};\r\n    \r\n    auto visitor = [](auto&& val) {std::cout << val << std::endl;};\r\n    struct Visitor\r\n    {\r\n        template<typename T>\r\n        void operator()(T&& val) {std::cout << val << std::endl;}\r\n        \r\n        void operator()(const std::string& val) {std::cout << \"String: \" << val << std::endl;}\r\n    };\r\n    \r\n    std::visit(Visitor(), v1);\r\n    std::visit(Visitor(), v2);\r\n    std::visit(Visitor(), v3);\r\n}\r\n```\r\nЧто на текущий момент по меньшей мере странно. Поэтому предлагается снять этот существующий де-юре, но не де-факто, запрет. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/161/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/161/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/160",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/160/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/160/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/160/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/160",
    "id": 838837612,
    "node_id": "MDU6SXNzdWU4Mzg4Mzc2MTI=",
    "number": 160,
    "title": "memory_alias",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T15:18:36Z",
    "updated_at": "2021-03-23T15:19:14Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -2\r\n_Автор идеи:_ **h4tred**\r\n\r\nДать возможность делать алиас/приводить блок памяти одного типа к другому, т.е. дать понять компилятору не применять правила Strict Aliasing в данном случае.\r\n\r\nОсобенно актуально при работе с данными по сети, когда пакет может быть определён только какой-то информации в начале (или на основании каких-то других признаков). Обычно вычитывается всё сразу в буффер char/uint8_t (дабы уменьшить количества копирований), а потом уже части этого буффера отображать в структуры.\r\n\r\nПроблемы: как-то нужно решать вопрос с невыровненными данными.\r\n\r\nСсылка в тему: http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\r\n\r\nПримеры, когда может пригодиться:\r\n\r\n1) сеть, позволит вычитывать данные из ядерных буфферов максимально большими блоками, разбирать уже по ходу\r\n\r\n2) USB: на многих устройствах есть ограничения на выравнивание и кратность размера блока для чтения из железа, поэтому, обычно, заводят один буффера с правильными __attribute__((align(x))), куда читают данные из DATA фазы Setup запроса. Но сами данные могут быть определены на основании другой информации из запроса: Target/Index/Value и так далее.\r\n\r\nНасколько я понимаю, в современных реалиях нет официального способа так делать, хотя вариант c union работает на всех (? - не уверен) компиляторах - их тоже люди делают.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/160/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/160/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/159",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/159/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/159/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/159/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/159",
    "id": 838831434,
    "node_id": "MDU6SXNzdWU4Mzg4MzE0MzQ=",
    "number": 159,
    "title": "Forbid conversion from std::basic_string to std::basic_string_view",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-23T15:12:21Z",
    "updated_at": "2021-03-23T15:17:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **tenzink**\r\n\r\nConversion from std::string to std::string_view may lead to hard-to-detect runtime errors.\r\n\r\nConsider the following code. This code may look safe, and may not be spotted by the reader:\r\n```cpp\r\nstd::string readSetting(const std::string& fileName);\r\n\r\nstd::string_view getName()\r\n{\r\n  std::string path = \"settings.ini\";\r\n  auto name = readSetting(path);\r\n  return name;\r\n}\r\n```\r\nIn fact, returned string_view points to the internals of already destroyed string.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/159/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/158",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/158/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/158/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/158/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/158",
    "id": 838015242,
    "node_id": "MDU6SXNzdWU4MzgwMTUyNDI=",
    "number": 158,
    "title": "operator[] для tuple",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-22T18:52:44Z",
    "updated_at": "2021-03-22T18:53:38Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -0\r\n_Автор идеи:_ **riad**\r\n\r\n`get<index>(t)` выглядит не красиво, `t[0] `-- красиво, но пока сложно получить\r\nНо, можно добиться `t[0_i]`, \r\nесли сделать чтобы N_i возвращал тип, в котором зашито N (например `std::integral_constant<size_t, N>`), и добавить `tuple::operator[этот тип]`\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/158/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/157",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/157/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/157/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/157/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/157",
    "id": 838013487,
    "node_id": "MDU6SXNzdWU4MzgwMTM0ODc=",
    "number": 157,
    "title": "Краткая форма тела метода",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-22T18:50:11Z",
    "updated_at": "2022-08-12T06:12:26Z",
    "closed_at": "2022-08-12T06:12:26Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -10\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ некоторых языках позволено записывать тело методы в краткой форме. \r\n```cpp\r\nint length(const std::string& s) {\r\n    return s.size();\r\n}\r\n```\r\nВместо традиционой формы, можно писать вот так.\r\n```cpp\r\nint length(const std::string& s) = s.size();\r\n```\r\nТакже можно будет лаконично писать методы с switch expression.\r\n```cpp\r\nint day_of_week(int day) = switch (day) {\r\n    case MONDAY, FRIDAY, SUNDAY -> 6;\r\n    case TUESDAY                -> 7;\r\n    case THURSDAY, SATURDAY     -> 8;\r\n    case WEDNESDAY              -> 9;\r\n};\r\n```\r\nБыло б классно иметь такую форму записи методов и в С++ языке.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/157/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/156",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/156/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/156/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/156/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/156",
    "id": 838012475,
    "node_id": "MDU6SXNzdWU4MzgwMTI0NzU=",
    "number": 156,
    "title": "Сделать std::make_unique и std::make_shared более SFINAE-friendly",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-22T18:48:43Z",
    "updated_at": "2021-03-22T18:49:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Олег Фатхиев**\r\n\r\nПрямо сейчас в функции:\r\n```cpp\r\ntemplate <class T, class... Args>\r\nunique_ptr<T> make_unique(Args&&... args);\r\n```\r\nНет проверки `std::is_constructible_v<T, Args&&...>` во время overload resolution.\r\nЭто ведет к тому, что многие редакторы не могут найти ошибку, когда в make_unique были переданны аргументы, от которых объект типа T не может сконструироваться. Ошибка возникает лишь позже, во время компиляции, с довольно таки непонятным описанием.\r\n\r\nТакже это не даёт использовать функцию make_unique в SFINAE контексте.\r\n\r\nПредлагается добавить следующее требование для make_unique:\r\n```cpp\r\ntemplate <class T, class... Args>\r\nunique_ptr<T> make_unique(Args&&... args) requires (std::is_constructible<T, Args&&...>);\r\n```\r\nТо же касается функций: std::make_unique_default_init; std::make_shared; std::make_shared_default_init; конструктора std::pair, первым аргументом которого является std::piecewise_construct_t.\r\n\r\nВ качестве примера конструктора, где подобное ограничение учли, является конструктор std::variant, от std::in_place_type_t, std::in_place_index_t и конструктор от 1 любого шаблонного параметра: https://en.cppreference.com/w/cpp/utility/variant/variant\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/156/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/156/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/155",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/155/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/155/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/155/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/155",
    "id": 838009621,
    "node_id": "MDU6SXNzdWU4MzgwMDk2MjE=",
    "number": 155,
    "title": "Ограничение набора типов variadic pack'a",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-22T18:44:38Z",
    "updated_at": "2022-01-27T07:31:55Z",
    "closed_at": "2022-01-27T07:31:45Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -0\r\n_Автор идеи:_ **Antervis**\r\n\r\nОчень простой пример, демонстрирующий проблему: допустим, нам нужно что-то вроде функции, принимающей variadic pack int'ов:\r\n```cpp\r\nvoid foo(int... args) {\r\nРеализовать такую функцию можно двумя способами, через requires/концепты:\r\n\r\ntemplate <Same<int> ...Args>\r\nvoid foo(Args... args) {\r\nлибо через static_cast:\r\n\r\nvoid foo(auto ...args) {\r\n    __foo_impl(static_cast<int>(args)...);\r\n}\r\n```\r\nПервый вариант не поддерживает неявные преобразования, т.е. требует явно приводить типы передаваемых аргументов. Второй вариант отключает возможность перегружать foo другими variadic версиями.\r\n\r\n \r\n\r\nИдея: ввести возможность ограничения списка типов, принимаемых variadic pack'ом:\r\n```cpp\r\nvoid foo(auto ...(int) args);\r\n```\r\nФункция будет участвовать в перегрузке если все её аргументы могут быть неявно приведены к одному из перечисленных в ограничителе типам. Например, так можно будет объявить функцию объединения строк с преаллокацией:\r\n```cpp\r\ntemplate <typename ...(std::string_view, Same<char>) Args>\r\nauto join(Args args) {\r\n// или\r\nauto join(auto ...(std::string_view, Same<char>) args) {\r\n// принимает типы, приводящиеся к string_view или удовлетворяющие концепту Same<char>\r\n```\r\nТакже это позволит удобно реализовывать перегрузки variadic-pack функций",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/155/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/155/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/154",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/154/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/154/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/154/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/154",
    "id": 838001534,
    "node_id": "MDU6SXNzdWU4MzgwMDE1MzQ=",
    "number": 154,
    "title": "Именованные аргументы функций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-22T18:33:43Z",
    "updated_at": "2021-03-22T18:35:45Z",
    "closed_at": "2021-03-22T18:35:45Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +16, -1\r\n_Автор идеи:_ **NeoProgramming**\r\n\r\nЗнаю, что в C++20 наконец-то переехала замечательная фича из Си \"designated initialization\". А может быть, заодно с помощью такого же синтаксиса сделать наконец и именованные аргументы функций?\r\n\r\n```cpp\r\n// функция\r\nvoid foo(int x, int y, int z) {}\r\n// вызов\r\nfoo(.z=10, .y=20, .x=30);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/154/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/154/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/153",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/153/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/153/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/153/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/153",
    "id": 837998666,
    "node_id": "MDU6SXNzdWU4Mzc5OTg2NjY=",
    "number": 153,
    "title": "Расширить синтаксис break в циклах для выхода из глубокой вложенности",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-22T18:29:43Z",
    "updated_at": "2021-03-22T18:32:02Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -10\r\n_Автор идеи:_ **Игорь Савенков**\r\n\r\nДобавить возможность указывать количество циклов из которых нужно выйти\r\n\r\nНапример:\r\n```cpp\r\nfor (int i =0; i < 10; i++)\r\n{\r\n    for (int j = 0; j < 10; j++)\r\n    {\r\n        if (some1)\r\n            break 2;\r\n    }\r\n}\r\n// <- continue from here\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/153/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/153/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/152",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/152/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/152/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/152/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/152",
    "id": 837997870,
    "node_id": "MDU6SXNzdWU4Mzc5OTc4NzA=",
    "number": 152,
    "title": "C++ switch выражения",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-22T18:28:36Z",
    "updated_at": "2021-03-26T17:20:43Z",
    "closed_at": "2021-03-26T17:20:32Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +16, -6\r\n_Автор идеи:_ **Игорь Шаповал**\r\n\r\nВ С++ имеется switch statement. Во многих языках имеется также switch expression. Выражения позволяет возращать с switch значения, в ветке указывать несколько значений, а также отсутствует проблема с fallthrough.\r\n\r\nДля сравнения для того чтобы возратить значения с switch statement нужно написать.\r\n```cpp\r\nint numLetters;\r\nswitch (day) {\r\n    case MONDAY:\r\n    case FRIDAY:\r\n    case SUNDAY:\r\n        numLetters = 6;\r\n        break;\r\n    case TUESDAY:\r\n        numLetters = 7;\r\n        break;\r\n    case THURSDAY:\r\n    case SATURDAY:\r\n        numLetters = 8;\r\n        break;\r\n    case WEDNESDAY:\r\n        numLetters = 9;\r\n        break;\r\n    default:\r\n        throw new IllegalStateException(\"Wat: \" + day);\r\n}\r\n```\r\nА чтобы возратить значения с switch expression.\r\n```cpp\r\nint numLetters = switch (day) {\r\n    case MONDAY, FRIDAY, SUNDAY -> 6;\r\n    case TUESDAY                -> 7;\r\n    case THURSDAY, SATURDAY     -> 8;\r\n    case WEDNESDAY              -> 9;\r\n};\r\n```\r\nТакже обе формы полезны в дальнейшем продвижении pattern matching в язык С++.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/152/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/152/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/151",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/151/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/151/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/151/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/151",
    "id": 837977871,
    "node_id": "MDU6SXNzdWU4Mzc5Nzc4NzE=",
    "number": 151,
    "title": "Добавить в (unordered_)(multi)set operator[]",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-22T18:01:54Z",
    "updated_at": "2021-03-22T18:07:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -5\r\n_Автор идеи:_ **Nate Reinar Windwood**\r\n\r\nУдобная и логичная альтернатива contains/count.\r\nКак минимум, для unordered вариантов, поскольку математически это в чистом виде отображение Key -> bool / size_t.\r\nI. e. unordered_set ≡ unordered_map; unordered_multiset ≡ unordered_map.\r\nДля unsorted фиг знает, там все-таки еще порядок есть... С другой стороны, все равно удобно будет.\r\n\r\n```cpp\r\nset::operator[](const Key &) -> bool;\r\n\r\nmultiset::operator[](const Key &) -> sise_t;\r\n\r\nunordered_set::operator[](const Key &) -> bool;\r\n\r\nunordered_multiset::operator[](const Key &) -> size_t;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/151/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/151/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/150",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/150/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/150/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/150/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/150",
    "id": 837976799,
    "node_id": "MDU6SXNzdWU4Mzc5NzY3OTk=",
    "number": 150,
    "title": "Функциональный switch",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-22T18:00:24Z",
    "updated_at": "2021-03-26T17:21:07Z",
    "closed_at": "2021-03-26T17:20:59Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +25, -1\r\n_Автор идеи:_ **valera_ee**\r\n\r\nВо многих языка оператор switch умеет сравнивать не только целочисленные значения, но и строки, и много чего ещё. Возникает вопрос, почему у нас самый ущербный по функциональности этот оператор. Почему не сделать так, что бы можно было задавать произвольный тип для которого определён оператор сравнения или можно было бы указать функцию, которая будет сравнивать входное значение с case-ами?\r\n\r\nПример со строками:\r\n\r\n```cpp\r\nconstexpr std::string_view str_case1 {\"state 1\"};\r\nconstexpr std::string_view str_case2 {\"state 2\"};\r\nconstexpr std::string_view str_case3 {\"state 3\"};\r\n\r\nstd::string any_text {\"tate 2\"};\r\n\r\nswitch (any_text)\r\n{\r\n    case str_case1:\r\n        std::cout << \"state 1\";\r\n        break;\r\n\r\n    case str_case2:\r\n        std::cout << \"state 2\";\r\n        break;\r\n\r\n    default:\r\n        std::cout << \"default state\";\r\n        break;\r\n}\r\n```\r\nИли вариант с заданной функцией сравнения:\r\n\r\n \r\n```cpp\r\nstatic const Regression regression_case1(Regression::Linear);\r\nstatic const Regression regression_case2(Regression::Cubic);\r\nstatic const Regression regression_case3(Regression::Logarithmic);\r\n\r\nbool regression_cmp(const Regression &a, const Regression &b);\r\n\r\nRegression m_regression = optimalRegression({2, 5, 7, 8}, {3, 7, 8, 9});\r\n\r\nswitch (m_regression; regression_cmp)\r\n{\r\n    case regression_case1:\r\n        std::cout << \"optimal linear regression\";\r\n        break;\r\n\r\n    case regression_case2:\r\n        std::cout << \"optimal cubic regression\";\r\n        break;\r\n\r\n    default:\r\n        std::cout << \"optimal logarithmic regression\";\r\n        break;\r\n}\r\n```\r\nНе могу судить о потери производительности, но функциональность оператора возрастёт.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/150/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/150/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/149",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/149/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/149/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/149/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/149",
    "id": 837973010,
    "node_id": "MDU6SXNzdWU4Mzc5NzMwMTA=",
    "number": 149,
    "title": "Глупые lambdas",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-22T17:55:25Z",
    "updated_at": "2021-03-22T17:56:04Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -6\r\n_Автор идеи:_ **Владислав Петров**\r\n\r\nПредлагаю 'умолчательный' захват (используемых конечно) по const &\r\n\r\nЕсли lambda не захватила символ, то компилятор ругается.\r\n\r\nХотя точно знает что она использует. [<used> const &] (void) { // ничего не меняю; }",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/149/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/149/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/148",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/148/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/148/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/148/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/148",
    "id": 836831454,
    "node_id": "MDU6SXNzdWU4MzY4MzE0NTQ=",
    "number": 148,
    "title": "шаблоны по квалификаторам this",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-20T15:08:34Z",
    "updated_at": "2022-02-19T10:49:04Z",
    "closed_at": "2022-02-19T10:49:04Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +4, -5\r\n_Aвтор идеи:_ **ilnurkh**\r\n\r\nВозможность написать метод, который инстанцируется в две реализации: константный и не константый (возможно ещё и &&).\r\nПолезно при различных saveload описаниях, которые приходится делать либо с макросами, либо с дублированием кода\r\n\r\n```cpp\r\nstruct SaveLoadableType {\r\n    int a;\r\n    int b;\r\n    int c;\r\n\r\n    template<class IoClass, trait Qualifier>\r\n    void SaveLoad(IoClass& io) Qualifier {\r\n        io.AddField(a);\r\n        io.AddField(b);\r\n        io.AddField(c);\r\n    }\r\n}\r\n\r\nstruct TObjStreamSaver {\r\n    template<class T>\r\n    AddField(const T& val) {\r\n        cout << val << \" \";\r\n    }\r\n}\r\n\r\nstruct TObjStreamLoader {\r\n    template<class T>\r\n    AddField(T& val) {\r\n        cin >> val;\r\n    }\r\n}\r\n\r\nint main() {\r\n    SaveLoadableType object;\r\n\r\n    {\r\n        const auto& ref = object;\r\n        TObjStreamSaver saver;\r\n        ref.SaveLoad(saver); //called const specialization: void SaveLoadableType::SaveLoad(TObjStreamSaver & io) const\r\n    }\r\n    \r\n    {\r\n        auto& ref = object;\r\n        TObjStreamLoader loader;\r\n        ref.SaveLoad(loader); //called non-const specialization: void SaveLoadableType::SaveLoad(TObjStreamLoader& io) const\r\n    }\r\n}\r\n```\r\n \r\n\r\nКонечно, введение нового ключевого слова очень спорно. В качестве алтернативы я бы предложил\r\n```cpp\r\nstruct SaveLoadableType {\r\n    int a;\r\n    int b;\r\n    int c;\r\n\r\n    template<class IoClass, class SelfClass>\r\n    void SaveLoad(IoClass& io) SelfClass {\r\n        io.AddField(a);\r\n        io.AddField(b);\r\n        io.AddField(c);\r\n    }\r\n}\r\n```\r\nКонечно, должно быть автоматическое выведение квалификатора.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/148/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/148/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/147",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/147/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/147/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/147/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/147",
    "id": 836829665,
    "node_id": "MDU6SXNzdWU4MzY4Mjk2NjU=",
    "number": 147,
    "title": "strong typedef",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T15:00:01Z",
    "updated_at": "2021-04-06T19:04:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +42, -4\r\n_Aвтор идеи:_ **ya.imdex**\r\n\r\nДобавить возможность создания нового типа на основе существующего\r\n\r\nРассмотрим простой пример:\r\n```cpp\r\nusing UserId = int;\r\nusing RoleId = int;\r\n\r\noption<User> findUserById(UserId id);\r\noption<Role> findRoleById(RoleId id);\r\n\r\nauto userId = UserId(0);\r\nauto roleId = RoleId(1);\r\n\r\nfindUserById(roleId); // oops\r\nfindRoleById(userId); // oops\r\n```\r\nКод прекрасно скомпилируется, а хотелось бы использовать все преимущества статической типизации. Конечно можно создавать новый класс для каждого типа *Id, но это требует написания конструктора, операторов сравнения и т.д. Было бы неплохо иметь возможность объявить новый тип, обладающий всеми свойствами исходного типа, а не простой псевдоним.\r\n```cpp\r\nusing UserId = new int;\r\nusing RoleId = new int;\r\n\r\noption<User> findUserById(UserId id);\r\n\r\nfindUserById(RoleId(1)); // compile error\r\nfindUserById(0); // compile error\r\nfindUserById(UserId(0)); // Ok\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/147/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/147/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/146",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/146/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/146/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/146/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/146",
    "id": 836815167,
    "node_id": "MDU6SXNzdWU4MzY4MTUxNjc=",
    "number": 146,
    "title": "Стандартные адаптеры для использования reverse_iterator в range for.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T13:56:52Z",
    "updated_at": "2021-03-20T13:57:59Z",
    "closed_at": "2021-03-20T13:57:59Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +7, -0\r\n_Aвтор идеи:_ **Сергей Прейс**\r\n\r\nХотелось бы иметь возможность написать что-то вроде\r\n```cpp\r\nvector MyVector;\r\nfor (auto cur : reverse(MyVector)) {} for (auto cur : MyVector.reverse()) {}\r\n```\r\nили чтобы пробежать по вектору в обратную сторону.\r\n\r\nРяд коллекций поддерживает reverse_iterator и const_reverse_iterator через rbegin()/rend(), crbegin()/crend(), но они не могут быть использованы в range-циклах, что обидно. Понятно, что можно написать обычный цикл, использовать алгоритм или сделать собственный адаптер, но отсутствие стандартной возможности выглядит какой-то недоделкой.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/146/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/146/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/145",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/145/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/145/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/145/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/145",
    "id": 836814421,
    "node_id": "MDU6SXNzdWU4MzY4MTQ0MjE=",
    "number": 145,
    "title": "Потокобезопасные контейнеры",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T13:53:20Z",
    "updated_at": "2021-03-20T13:55:33Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +19, -3\r\n_Aвтор идеи:_ **maksimus1210**\r\n\r\nПри передаче данных из одного потока в другой часто используются очередь или кольцевой буфер (кторый отсутствует в STL), но потокобезопасность приходится городить самостоятельно.\r\n\r\nВ качестве примера можно привести приём данных по сети и передачу их в другой поток на обработку, кольцевого буфера в STL и так НЕТУ, так ещё из того, что есть в чистом виде непригодны для этого, нужно писать потокобезопасную надстройку над контейнером или вообще писать с нуля.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/145/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/145/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/144",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/144/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/144/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/144/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/144",
    "id": 836806608,
    "node_id": "MDU6SXNzdWU4MzY4MDY2MDg=",
    "number": 144,
    "title": "Тесты на \"не компилируемость\"",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T13:23:21Z",
    "updated_at": "2021-03-20T13:25:01Z",
    "closed_at": "2021-03-20T13:24:46Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +3, -4\r\n_Aвтор идеи:_ **ilnurkh**\r\n\r\nИметь возможность объявлять, что некоторый код обязан быть не валидным. Нужно чтобы писать negative тесты на compile-time вычисления.\r\nНапример, сейчас нет сколь нибудь удобной возможность написать тест, что шаблонный аргумент не может быть некоторым типом. Есть возможность поставить static_assert, но нет возможности сделаться автотесты проверяющие его работоспособность.\r\nРасширяя идею хочется иметь стандартные коды ошибок компиляции.\r\n\r\nПример\r\n```cpp\r\n#pragma negative start\r\nvoid test_cant_do_this(){\r\n SomeTypeOnlyForUnsignedTypes<into> var;\r\n}\r\n//дополнительно указывает какого типа должна быть ошибка компиляции\r\n#pragma negative catch static_assert_err\r\n\r\n#pragma negative end\r\n```\r\nКроме этого можно проверять что нельзя вызвать метод (типы ошибок : private, isNotCallable , неоднозначный вызов, нет подходящей перегрузки), что идентификатор не определен, что метод или класс является абстрактным. Еще можно было бы и про \"неразрешенный символ\", но это уже линковка.\r\n\r\nПроверка условий должна проходить при включени флага компиляции, должна быть возможность от компилятора запросить отчет обо всех негативных тестах, для последующей интеграции с ci системами.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/144/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/144/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/143",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/143/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/143/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/143/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/143",
    "id": 836806171,
    "node_id": "MDU6SXNzdWU4MzY4MDYxNzE=",
    "number": 143,
    "title": "Реализация FFT И DFT",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T13:20:49Z",
    "updated_at": "2021-03-20T13:21:15Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +12, -5\r\n_Aвтор идеи:_ **maksimus1210**\r\n\r\nАлгоритмы FFT и DFT используются повсеместно в обработке сигналов, изображений, в 3D графике, при сжатии аудиоданных. Но всё время приходиться пользоваться сторонними библиотеками и как правило написанных на языке СИ. К этим алгоритмам также хотелось бы получить и дискретно косинусное преобразование, преобразование Лапласа, вейвлет преобразование. Особенно ощущается нехватка этих алгоритмов при кроссплатформенном программировании.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/143/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/143/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/142",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/142/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/142/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/142/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/142",
    "id": 836804780,
    "node_id": "MDU6SXNzdWU4MzY4MDQ3ODA=",
    "number": 142,
    "title": "Type Trait std::is_relocatable",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T13:12:54Z",
    "updated_at": "2021-03-20T13:16:30Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +8, -2\r\n_Aвтор идеи:_ **Andrey Davydov**\r\n\r\nВ библиотеке folly (https://github.com/facebook/folly/blob/master/folly/docs/Traits.md) определен type trait IsRelocatable сигнализирующий, что соответствующий тип может быть перемещен с помощью memcpy + забывание старого объекта (т.е. для него не должен вызываться деструктор). Такое свойство полезно было бы, во-первых, стандартизировать, а во-вторых, использовать в стандартных контейнерах и алгоритмах.\r\n\r\n## Мотивация\r\n\r\nrelocatable это естественное обобщение стандартного свойства trivially copyable. С одной стороны оно дает простор для оптимизаций, к примеру, позволяет свести такую операцию как realloc вектора из n элементов к одному memcpy вместо n вызовов move_if_noexcept + n вызовов деструктуров для перемещенных/скопированных элементов. С другой стороны множество relocatable типов значительно шире множества trivially copyable. Рассмотрим некоторые типы стандартной библиотеки, которые не являются trivially copyable но при этом являются relocatable.\r\n\r\n*    shared_ptr: при побитовом копировании и невыполнении деструктора для старого экземпляра shared_ptr, значение счетчика ссылок, очевидно, не изменяется, что эквивалетно перемещению для shared_ptr.\r\n*    unique_ptr<T, D>, если D -- relocatable (std::default_delete, являясь trivial copyable, является и relocatable). Если побитово скопировать pointer и deleter (в предположении, что для него это валидно) и не вызывать деструктор, то новый экземпляр, останется единственным владельцем указателя.\r\n*    string и все стандартные контейнеры, по крайнер мере при использовании std::allocator (ровно те же рассуждения, что и для unique_ptr).\r\n*    optional<T>, variant<Ts...>, если T и Ts... -- relocatable.\r\n\r\n## Формализация\r\n\r\nПредалаю определить понятие relocatable types в [basic.types] p9 (где-то рядом с trivially copyable types) и relocatable class в [class] (где-то рядом с trivially copyable class).\r\n\r\nTrivially copyable types, relocatable class types, arrays of such types and cv-qualified versions of these types are collectively called relocatable types.\r\n\r\nКласс является relocatable если он или явно помечен как relocatable или все базовые классы и все нестатические члены данных являются relocatable, и класс имеет non-virtual, non-deleted не user-defined деструктор. Есть вопрос как лучше определить \"явно помечен как relocatable\", потому что, насколько я понимаю, пока что единственным прецендентом определить не выводимое компилятором свойство класса было ключевое слова final. Как вариант, можно ввести специальный класс std::relocatable_marker и проверять является ли он непосредственной базой нашего типа. Плюс, может быть полезной метафункция std::conditional_relocatable_marker<bool>. К примеру, определение unique_ptr может выглядеть следующим образом:\r\n```cpp\r\nnamespace std {\r\n\r\ntemplate<bool>\r\nstruct conditional_relocatable_marker;\r\n\r\ntemplate<>\r\nstruct conditional_relocatable_marker<true>\r\n{\r\n  using type = relocatable_marker;\r\n};\r\n\r\ntemplate<>\r\nstruct conditional_relocatable_marker<false>\r\n{\r\n  struct dummy {};\r\n\r\n  using type = dummy;\r\n};\r\n\r\ntemplate<class T, class D>\r\nclass unique_ptr : typename conditional_relocatable_marker<is_relocatable_v<D>>::type\r\n{\r\n  // ...\r\n};\r\n\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/142/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/142/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/141",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/141/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/141/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/141/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/141",
    "id": 836800622,
    "node_id": "MDU6SXNzdWU4MzY4MDA2MjI=",
    "number": 141,
    "title": "for constexpr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-20T12:50:22Z",
    "updated_at": "2021-04-06T19:05:20Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +36, -0\r\n_Aвтор идеи:_ **Сергей Тиунов**\r\n\r\n## Мотивация\r\n\r\nБывают ситуации, когда было бы удобно организовать код в виде простого цикла (с известными пределами), но это сделать невозможно, потому что счетчик должен быть compile-time константой, например, он используется в виде параметра шаблона:\r\n```cpp\r\nfor (int i = 0; i < 3; i++) {\r\n  some_template_function<i>(); // compilation error: \r\n  // variable with non-static storage duration cannot be used as a non-type argument\r\n}\r\n```\r\nПримеры, когда нужно или желательно, чтобы счетчик цикла был compile-time константой:\r\n\r\n*    использование в constexpr выражениях\r\n*    использование в if-constexpr условиях\r\n*    использование в качестве параметра шаблона\r\n*    использование в качестве аргумента intrinsic-функции, которая требует immediate value (например, packed shuffle в x86)\r\n*    либо мы просто хотим указать компилятору, чтобы цикл был развернут\r\n\r\nДля того чтобы добиться подобного поведения в текущей версии С++, можно:\r\n\r\n*    использовать рекурсивные шаблоны или макросы - это не очень удачное решение, они нарушают локальность кода, т.е. их придется где-то определить, придумать им имя, а также они вызывают трудности при отладке, и вероятно не будут повторно использованы.\r\n*    variadic шаблоны или макросы - имеют те же недостатки.\r\n*    вручную развернуть (unroll) цикл - также не очень удачное решение, т.к. приводит к дублированию кода, проблемы которого широко известны.\r\n*    ???\r\n\r\n## Предложение\r\n\r\nВместо этого предлагается цикл с семантикой явного разворачивания: т.е. он записывается как цикл, но все управляющие конструкции (init statement, condition, iteration expression) вычисляются в compile-time. Тогда их можно использовать в качестве compile-time констант в constexpr выражениях, if-constexpr условиях, параметрах шаблонов и подобных контекстах. По аналогии с if-constexpr это могло бы выглядеть так:\r\n```cpp\r\nfor constexpr (int i = 0; i < 3; i++) {\r\n  some_template_function<i>(); // i is constexpr - okay, should compile\r\n}\r\n```\r\nЭта конструкция заставляет компилятор развернуть цикл (а для этого также необходимо, чтобы значения счетчика были известны во время компиляции), либо сгенерировать ошибку компиляции, если это сделать невозможно. Тогда вышеприведенный код скомпилируется как следующий фрагмент:\r\n```cpp\r\nsome_template_function<0>();\r\nsome_template_function<1>();\r\nsome_template_function<2>();\r\n```\r\n... однако в отличие от него не содержит дублирования кода.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/141/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/141/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/140",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/140/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/140/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/140/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/140",
    "id": 836769916,
    "node_id": "MDU6SXNzdWU4MzY3Njk5MTY=",
    "number": 140,
    "title": "Standard intrinsic functions",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T10:01:13Z",
    "updated_at": "2021-04-06T19:13:55Z",
    "closed_at": "2021-03-20T10:02:08Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +22, -0\r\n_Aвтор идеи:_ **Сергей Тиунов**\r\n\r\nДобавить в стандартную библиотеку функции типа bit scan forward/reverse, rotate left/right, pop count и подобные\r\n\r\n## Мотивация\r\n\r\nВ целочисленных приложениях (обработка видео, звука и других числовых данных) периодически возникают ситуации, когда удобная инструкция есть в целевом процессоре, но является нестандартной для языка. Современные компиляторы имеют для таких ситуаций встроенные intrinsic-функции, однако во всех компиляторах они называются по-разному, и иногда даже имеют разную семантику.\r\n\r\n## Пример\r\n\r\nНапример, если нужно определить двоичный логарифм числа, то на x86 есть инструкции BSR (давно) и LZCNT (недавно), а на ARM есть инструкция CLZ (ARMv5+). Соответствующие intrinsic-функции в разных компиляторах:\r\n```cpp\r\nunsigned char _BitScanReverse(unsigned long * Index, unsigned long Mask); // MSVC x86 and ARM, Intel C Compiler\r\nunsigned int _arm_clz(unsigned int _Rm); // MSVC ARM\r\nunsigned int __lzcnt(unsigned int); // MSVC x86\r\nint __builtin_clz (unsigned int x); // GCC and clang - on any supported processor (?)\r\nint __builtin_ffs (unsigned int x); // GCC and clang - on any supported processor (?)\r\nunsigned int __clz(uint32_t x); // ARM C Language Extensions (ACLE) - supported by GCC (clang?)\r\n```\r\nЭти функции имеют не только разные сигнатуры, но и разную семантику:\r\n\r\n*    BSR - Bit Scan Reverse - это индекс старшего значащего бита (если операнд 0, то результат не определен)\r\n*    FFS - Find First Set: FFS(x) = x ? 1 + BSR(x) : 0\r\n*    CLZ - Count Leading Zeros - это количество старших нулей: CLZ(x) = 8*sizeof(x) - FFS(x)\r\n\r\nВ результате приходится писать собственные функции-обертки с портянкой #ifdef:\r\n```cpp\r\ninline int32_t bit_scan_reverse(int32_t x) {\r\n#if defined(_MSC_VER)\r\n    unsigned long result;\r\n    BitScanReverse(&result, x);\r\n    return result;\r\n#elif defined(__GNUC__) || defined(__clang__)\r\n    return 31 - __builtin_clz(x);\r\n#endif\r\n}\r\n```\r\nТакже известен подводный камень на x86: функция __lzcnt честно компилируется MSVC в инструкцию LZCNT, но если она не поддерживается вашим Intel'ом (а поддерживается она сравнительно недавно), то он вместо CLZ сделает BSR и получит совершенно противоположный результат.\r\n\r\n## Предложение\r\n\r\nПредлагается включить в стандартную библиотеку следующие распространенные операции с фиксированным интерфейсом и хорошо определенным поведением:\r\n\r\n*    bit scan reverse/forward\r\n*    bit rotate left/right\r\n*    byte swap\r\n*    pop count (количество установленных бит)\r\n*    parallel bit extract/deposit (получение/установка бит, заданных маской)\r\n*    ??? (ваши предложения)\r\n\r\n... с соответствующими перегрузками для доступных целочисленных типов.\r\n\r\nТакие инструкции как BSR или PDEP/PEXT сложно заменить алгоритмически - если они требуются в вычислениях нужен двоичный логарифм, то скорее всего его придется искать. С другой стороны эти инструкции не настолько просты, чтобы компилятор мог распознать и заменить их. Поэтому стандартная библиотека - это хорошее место для этих функций.\r\n\r\nВозможно, будучи в стандартной библиотеке, эти функции не только помогут решать вышеприведенные задачи, но и будут способствовать появлению новых эффективных алгоритмов и реализаций известных функций. Например, задача преобразования числа в строку может быть решена более эффективно, если известен порядок числа, т.е. количество десятичных знаков.\r\n\r\n## Ссылки\r\n\r\n[MSVC Compiler intrinsics](https://docs.microsoft.com/en-us/cpp/intrinsics/compiler-intrinsics?redirectedfrom=MSDN&view=msvc-160)\r\n\r\n[GCC built-in functions](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)\r\n\r\n[x86 BMI instructions](https://en.wikipedia.org/wiki/Bit_manipulation_instruction_set)\r\n\r\n[Intel Intrinsics Guide](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#)\r\n\r\n[ARM C Language Extensions](https://developer.arm.com/documentation/ihi0053/c/)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/140/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/140/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/139",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/139/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/139/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/139/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/139",
    "id": 836768693,
    "node_id": "MDU6SXNzdWU4MzY3Njg2OTM=",
    "number": 139,
    "title": "std::visit for std::tuple",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-20T09:54:13Z",
    "updated_at": "2021-03-20T12:56:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +8, -1\r\n_Aвтор идеи:_ **mrgordonfreman**\r\n\r\nСудя по запросам в гугле, проблема обхода std::tuple многих беспокоит.\r\n\r\nДля себя я решил её так\r\n```cpp\r\ntemplate<typename Visitor, typename... Args>\r\nvoid visit(std::tuple<Args...> const& t, Visitor&& vis)\r\n{\r\n    (..., vis(std::get<Args>(t)));\r\n}\r\n\r\ntemplate<typename Visitor, typename... Args>\r\nvoid visit(std::tuple<Args...>& t, Visitor&& vis)\r\n{\r\n    (..., vis(std::get<Args>(t)));\r\n}\r\n\r\nauto t = std::make_tuple(100, \"500\", '!');\r\nvisit(t, [](auto&& x) {\r\n    std::cout << x;\r\n});\r\n```\r\nХочется иметь такие функции в стандартной библиотеке и не создавать велосипедов",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/139/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/139/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/138",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/138/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/138/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/138/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/138",
    "id": 836753422,
    "node_id": "MDU6SXNzdWU4MzY3NTM0MjI=",
    "number": 138,
    "title": "Allow to handle literal zero in a special way",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-20T08:24:51Z",
    "updated_at": "2021-03-20T08:26:20Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -7\r\n_Aвтор идеи:_ **mikhail.matrosov**\r\n\r\n## -- Introduction --\r\n\r\nLiteral zero is a special constant in C++. It is not only an integer value of zero, but it also represents a null pointer and can be freely converted to any other numeric type without warnings. However, there is currently no way to recognize literal zero as an argument for a function, which might come convenient in some cases.\r\n\r\n## -- Problem statement --\r\n\r\nConsider a class that represents a type-safe length:\r\n```cpp\r\nclass Length\r\n{\r\npublic:\r\n  static Length meters(double x) { return Length(x); }\r\n  static Length millimeters(double x) { return Length(x / 1000); }\r\n\r\n  friend bool operator<(const Length& lhs, const Length& rhs)\r\n  {\r\n    return lhs.d_meters < rhs.d_meters;\r\n  }\r\n\r\nprivate:\r\n  explicit Length(double meters) : d_meters(meters) {}\r\n\r\n  double d_meters;\r\n};\r\n```\r\nWe can construct length given a number and a dimension (meters or millimeters in this example). We can compare two lengths, but not a length and a scalar:\r\n```cpp\r\n  auto a = Length::meters(5);\r\n  auto b = Length::millimeters(500);\r\n  std::cout << (a < b) << std::endl;  // Properly compiles: compare two lengths\r\n//  std::cout << (a < 5) << std::endl;  // Properly does not compile: cannot compare length and a scalar\r\n```\r\nThis is great, but there is one special case of a scalar - zero. And it seems quite natural to comapre a length with zero without specifying its dimension! Consider:\r\n```cpp\r\n  std::cout << (a < 0) << std::endl;  // Should compile: compare length with zero\r\n```\r\nOne way to allow such comparison is to exploit the fact that literal zero can be implicitly converted to a pointer. Or to nullptr_t. We can add a constructor to Length class to do this:\r\n```cpp\r\n  Length(std::nullptr_t) : d_meters(0) {}\r\n```\r\nThis trick allows us to construct Length from literal zero, and since constructor is implicit, it also allows us to compare Length with literal zero.\r\n\r\nThis method has drawbacks though. First, it also makes the following line legal, which makes no sense:\r\n```cpp\r\n  std::cout << (a < nullptr) << std::endl;  // Improperly compiles: makes no sense to compare length with nullptr\r\n```\r\nSecond, it confuses static analyzers, which are aware of the fact that nullptr_t stands for pointers, and you should use nullptr instead of zero.\r\n\r\nThird, it also confuses reader, since nullptr_t relates to pointers and is not expected in a class representing a physical entity.\r\n\r\nSee demo here: https://ideone.com/VW05Eh\r\n\r\n## -- Proposed solution --\r\n\r\nIntroduce new utility type std::literal_zero_t, which might be constructed only from literal zero. Given this type, we can replace constructor accepting std::nullptr_t with constructor accepting std::literal_zero_t in a previous example. This will solve all the listed problems.\r\n```cpp\r\n  Length(std::literal_zero_t) : d_meters(0) {}\r\n```\r\n## -- Links --\r\n\r\nhttp://stackoverflow.com/q/19014421/261217",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/138/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/138/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/137",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/137/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/137/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/137/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/137",
    "id": 836210138,
    "node_id": "MDU6SXNzdWU4MzYyMTAxMzg=",
    "number": 137,
    "title": "helper class",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-19T17:16:21Z",
    "updated_at": "2021-03-19T17:22:08Z",
    "closed_at": "2021-03-19T17:22:01Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +5, -12\r\n_Aвтор идеи:_ **В**\r\n\r\nВвести helper class.\r\n\r\nФактически это синтаксический сахар, но с его наличием не нужно заниматься:\r\n- адаптеростроением на макросах,\r\n- наследованием от std-классов для их расширения своими методами (тем более, что это не всегда можно делать),\r\n- и т.п.\r\n\r\nУказанный в примере синтаксис (`: helper for T`) можно пересмотреть и обсудить.\r\nHelper class не могут иметь конструкторов, деструкторов, нестатичных данных (статичные по идее можно). Это просто расширение класса своими методами.\r\n\r\nДля производительности это нужно именно как часть Core Language, а не расширением библиотек на макросах и прочими способами.\r\n\r\nПодобные вещи есть в Java, .NET, Delphi. И это очень удобно.\r\n```cpp\r\n#include <string>\r\n\r\nclass my_string_helper : helper for std::string\r\n{\r\npublic:\r\n    std::vector<string> split(char separator)\r\n    {\r\n        // ...\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    std::string s{ \"Hello, world!\" };\r\n    auto splitted = s.split(' ');\r\n\r\n    // ...\r\n\r\n    return 0;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/137/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/137/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/136",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/136/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/136/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/136/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/136",
    "id": 836201313,
    "node_id": "MDU6SXNzdWU4MzYyMDEzMTM=",
    "number": 136,
    "title": "Добавить operator[] для initializer_list",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Neargye",
        "id": 7997966,
        "node_id": "MDQ6VXNlcjc5OTc5NjY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Neargye",
        "html_url": "https://github.com/Neargye",
        "followers_url": "https://api.github.com/users/Neargye/followers",
        "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
        "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
        "organizations_url": "https://api.github.com/users/Neargye/orgs",
        "repos_url": "https://api.github.com/users/Neargye/repos",
        "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Neargye/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-19T17:04:23Z",
    "updated_at": "2021-03-19T17:11:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +11, -1\r\n_Aвтор идеи:_ **dix75**\r\n\r\nОчень странно, что функция-член size() есть, а получить по индексу значение невозможно\r\n\r\nНа текущий момент в реализации initializer_list отсутсвует operator[] или иная функция-член для получения значения по индексу.\r\n\r\nБыло бы разумно, добавить такую необходимость.\r\n\r\np.s.\r\n\r\n1. Обход листа циклом for each иногда не является достаточным решением.\r\n\r\n2. Использование других контейнеров для выполнения функций initializer_list является не правильным решением, но в случае пунка 1 необходимым, на текуший момент.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/136/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/136/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/135",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/135/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/135/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/135/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/135",
    "id": 835953427,
    "node_id": "MDU6SXNzdWU4MzU5NTM0Mjc=",
    "number": 135,
    "title": "Named Aggregate initialization",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-19T12:47:50Z",
    "updated_at": "2021-03-19T12:53:29Z",
    "closed_at": "2021-03-19T12:53:14Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +6, -3\r\n_Aвтор идеи:_ **dix75**\r\n\r\nРасширить инициализацию путем именования только необходимых данных-член\r\n\r\nНа текущий момент имеем.\r\n```cpp\r\nstruct user\r\n{\r\n    uint32_t id_{};\r\n    std::string name_= \"Ivan\";\r\n    std::string surname_= \"Sidorov\";\r\n};\r\n\r\nuser u1{10, \"Alice\", \"Si\"};\r\n```\r\nУлучшить предлагаю так:\r\n \r\n```cpp\r\nstruct user\r\n{\r\n    uint32_t id_{};\r\n    std::string name_= \"Ivan\";\r\n    std::string surname_= \"Sidorov\";\r\n};\r\n\r\nuser u0;\r\nuser u1{id_ = 10, name_ =  \"Alice\", surname_ = \"Si\"};\r\nuser u2{id_ = 10};\r\nuser u3{surname_ = \"Si\"};\r\n```\r\np.s. Затруднений в реализации не вижу, может быть они есть, хотелось бы узнать.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/135/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/135/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/134",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/134/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/134/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/134/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/134",
    "id": 835951356,
    "node_id": "MDU6SXNzdWU4MzU5NTEzNTY=",
    "number": 134,
    "title": "std::bitset to any integral conversion",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-19T12:45:49Z",
    "updated_at": "2021-03-19T12:46:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +16, -0\r\n_Aвтор идеи:_ **mrgordonfreman**\r\n\r\nТекущей реализации std::bitset не достает гибкости в преобразовании к целым числам.\r\n\r\nПример типичного использования.\r\n\r\nПри объявлении bitset знаем точное число бит.\r\n```cpp\r\nstd::bitset<16> flags;\r\n```\r\nЗдесь тоже знаем точное число бит.\r\n```cpp\r\nuint16_t flags_register;\r\n```\r\nА дальше получаем проблемный код.\r\n```cpp\r\nflags_register = flags.to_ulong();\r\n```\r\nРазмер unsigned long может быть 4 или 8 байт на разных платформах. Но нам не нужно ни 4, ни 8 байт, а только 2. Более того, to_ulong() может кидать исключения, но мы точно знаем, что исключений не будет.\r\n\r\nНо код работает, и вроде бы ничего страшного. Потом решили запускать компилятор с флагом -Wconversion и получаем предупреждение\r\n```\r\nWarning: conversion to ‘uint16_t {aka short unsigned int}’ from ‘long unsigned int’ may alter its value [-Wconversion]\r\nflags_register = flags.to_ulong();\r\n                 ~~~~~~~~~~~~~~^~\r\n```\r\nТогда в коде придется использовать сужающее преобразование\r\n```cpp\r\nflags_register = static_cast<uint16_t>(flags.to_ulong());\r\n```\r\nПроблему решит добавление следующего метода\r\n```cpp\r\n#include <type_traits>\r\n\r\ntemplate<std::size_t N>\r\nclass bitset\r\n{\r\n    // ...\r\n    template<typename T>\r\n    T as_integral() const noexcept\r\n    {\r\n        static_assert(std::is_integral<T>::value && N <= sizeof(T) * 8);\r\n        //...\r\n    }\r\n    // ...\r\n};\r\n```\r\nТакже станет невозможным преобразовать bitset в число с меньшим количеством бит, и узнаем это на этапе компиляции\r\n```cpp\r\nstd::bitset<16> bs;\r\nbs.as_integral<uint16_t>();\r\nbs.as_integral<uint8_t>(); // COMPILATION ERROR HERE!\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/134/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/134/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/133",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/133/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/133/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/133/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/133",
    "id": 835945887,
    "node_id": "MDU6SXNzdWU4MzU5NDU4ODc=",
    "number": 133,
    "title": "Дата и время",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-19T12:40:00Z",
    "updated_at": "2021-04-06T19:11:07Z",
    "closed_at": "2021-03-19T12:44:04Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +24, -0\r\n_Aвтор идеи:_ **UltraCoder**\r\n\r\nВ C++11 добавили заголовочный файл , несколько упрощающий работу со временем. Однако, понятия \"даты\" или \"времени дня\" до сих пор нет, хотя эти типы, на мой взгляд, относятся к более-менее фундаментальным, и могут потребоваться в самых разных проектах.\r\n\r\nПримером реализации может служить библиотека Boost.DateTime (хотя она кажется несколько усложненной и \"раздутой\").\r\n\r\nМне удалось найти два предложения в стандарт по этой проблеме:\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1900.pdf\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0355r2.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/133/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/133/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/132",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/132/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/132/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/132/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/132",
    "id": 835942494,
    "node_id": "MDU6SXNzdWU4MzU5NDI0OTQ=",
    "number": 132,
    "title": "namespace private типы",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-19T12:36:48Z",
    "updated_at": "2021-04-06T19:07:26Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +31, -1\r\n_Aвтор идеи:_ **ya.imdex**\r\n\r\nДобавить возможность помечать типы как приватные для пространства имен, в котором они определены.\r\n```cpp\r\nnamespace example {\r\n    private class Private {};\r\n\r\n    class Public {\r\n        Private field; // Ок, так как тип Public в том же неймспейсе, что и Private\r\n    };\r\n}\r\n\r\nnamespace other {\r\n    class Foo {\r\n        example::Private field; // Ошибка компиляции\r\n\r\n        example::Public field; // Ок\r\n    };\r\n}\r\n```\r\nТип помеченный как private может быть использован только в рамках своего пространства имен. Вложенным пространствам имен можно также разрешить использовать этот тип или, как вариант, использовать для таких случаев protected.\r\n\r\nСейчас это делается вспомогательным неймспейсом detail, который никак не защищает от использования извне и засоряет подсказки автодополнения.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/132/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/132/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/131",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/131/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/131/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/131/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/131",
    "id": 834492973,
    "node_id": "MDU6SXNzdWU4MzQ0OTI5NzM=",
    "number": 131,
    "title": "Добавить operator bool() для контейнеров и строк",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-18T07:44:50Z",
    "updated_at": "2022-08-11T18:47:40Z",
    "closed_at": "2022-08-11T18:47:39Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +7, -23\r\n_Aвтор идеи:_ **Клеванец Игорь**\r\n\r\nТекущий стандарт описывает для каждого из контейнеров метод empty(). Его достаточно для полноценной работы.\r\n\r\nOperator bool() - это избыточный интерфейс для контейнеров, который ответит на вопрос \"Есть ли в контейнере хотя бы один элемент?\". Это позволит писать код чище. Предложение написано по мотивам книги \"Чистый код: Создание, анализ и рефакторинг\" Роберта Мартина.\r\n```cpp\r\nstd::vector<int> banned_users;\r\n//...\r\n\r\n// Сейчас можно только так\r\nif (!banned_users.empty()) {\r\n    //...\r\n}\r\n\r\n// Хочется так:\r\nif (banned_users) {\r\n     //...\r\n}\r\n```\r\nПредложение к стандарту: https://cerevra.github.io/bool/",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/131/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/131/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/130",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/130/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/130/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/130/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/130",
    "id": 834490054,
    "node_id": "MDU6SXNzdWU4MzQ0OTAwNTQ=",
    "number": 130,
    "title": "Декларация объекта с указанием неймспейса",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-18T07:40:53Z",
    "updated_at": "2021-03-18T07:43:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +17, -6\r\n_Aвтор идеи:_ **romanslonpp**\r\n\r\nВ C++17 наконец-то добавили возможность не писать так:\r\n```cpp\r\nnamespace A {\r\n  namespace B {\r\n    class C {};\r\n  }\r\n}\r\n```\r\n \r\n\r\nХочется так же иметь возможность писать так:\r\n\r\n```cpp\r\nclass A::B::C {}\r\n```\r\n \r\n\r\nПричины просты - очень часто нужно бывает что-то определить, либо засунуть в существующей неймспейс. В текущем стандарте лапши, конечно, поубавилось, но в идеале убрать её вообще.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/130/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/130/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/129",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/129/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/129/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/129/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/129",
    "id": 834483028,
    "node_id": "MDU6SXNzdWU4MzQ0ODMwMjg=",
    "number": 129,
    "title": "Разрушение информации о типе результата std::packaged_task",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-18T07:30:53Z",
    "updated_at": "2021-03-18T07:39:04Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +4, -0\r\n_Aвтор идеи:_ **Sir-VestniK**\r\n\r\nНа данный момент тип врзвращаемого значения функции лежащей в packaged_task присутствует в шаблонных параметрах данного класса. Из за чего два packaged_task с одинаковыми типами принимаемых параметров несовместимы друг с другом, если функторы в них лежащие возвращают разные типы. Это требует написание дополнительных type-erasure классов над packaged_task при реализации очередей задач и пулов потоков.\r\n\r\nПредлагаю завести частичную специализацию std::packaged_task для типа возвращаемого значения\r\n```cpp\r\nnamespace std {\r\nusing ignore_t = decltype(ignore);\r\n}\r\n```\r\n  которая оличается от общего случая следующими моментами:\r\n\r\n*    Доступен только конструктор по умолчанию создающий невалидную задачу, конструктор перемещения и конструктор от r-value задачи с произвольным типом результата\r\n```cpp\r\n    template<typename A...>\r\n    template<typename R>\r\n    std::packaged_task<std::ignore_t(A...)>::packaged_task(std::packaged_task<R(A...)>&&);​\r\n```\r\n    при этом данный конструктор бросает исключение типа std::future_error с кодом std::future_errc::broken_promise если от перемещаемой задачи не вызывался метод get_future.\r\n*    Данная специализация не предоставляет метода get_future.\r\n\r\nТаким образом данная специализация разрушает информацию о типе возвращаемого значения (или о типе std::future ассоциированного с задачей), позволяя хранить разные packaged_task'и в одной коллекции или отдавать задачи из разных источников одному и тому же исполнителю.\r\n\r\nПредлагаю данную специализацию продвигать как дополнение к Concurrency TS без которого std::future и ассоциированные с ним классы всё равно не пригодны для реального использования в боевом коде.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/129/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/129/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/128",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/128/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/128/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/128/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/128",
    "id": 834480689,
    "node_id": "MDU6SXNzdWU4MzQ0ODA2ODk=",
    "number": 128,
    "title": "safe_cast keyword",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-18T07:27:40Z",
    "updated_at": "2021-03-18T07:28:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +2, -9\r\n_Aвтор идеи:_ **dix75**\r\n\r\nВ случае успешного выполнения операция safe_cast возвращает указанное выражение как указанный тип; в противном случае вызывается исключение `std::bad_cast`.\r\n```cpp\r\n    try {\r\n        B b;\r\n        auto a = safe_cast<A*>(&b);\r\n    }\r\n    catch(std::bad_cast const& e) {\r\n        std::cout << e.what() << std::endl;\r\n    }\r\n```\r\np.s. В случаи невозможности кастования ссылок для dynamic_cast вызывается исключения std::bad_cast, хотелось бы расширить и на указатели.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/128/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/128/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/127",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/127/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/127/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/127/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/127",
    "id": 834478300,
    "node_id": "MDU6SXNzdWU4MzQ0NzgzMDA=",
    "number": 127,
    "title": "try-catch-finally блок",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-18T07:24:15Z",
    "updated_at": "2021-03-18T07:26:25Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +4, -13\r\n_Aвтор идеи:_ **dix75**\r\n\r\nДумаю объяснения излишне, но приведу два примера возможного использования\r\n\r\n1.\r\n```cpp\r\ntry {\r\n}\r\ncatch(...) {\r\n}\r\nfinally {\r\n}\r\n```\r\n \r\n\r\n2. \r\n```cpp\r\ntry {\r\n}\r\nfinally {\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/127/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/127/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/126",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/126/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/126/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/126/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/126",
    "id": 834476528,
    "node_id": "MDU6SXNzdWU4MzQ0NzY1Mjg=",
    "number": 126,
    "title": "Operator <=>",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-18T07:21:52Z",
    "updated_at": "2021-03-18T07:23:10Z",
    "closed_at": "2021-03-18T07:23:10Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +14, -2\r\n_Aвтор идеи:_ **dix75**\r\n\r\nНе увидел proposal, хотелось бы увидеть данный оператор в С++21",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/126/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/126/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/125",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/125/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/125/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/125/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/125",
    "id": 834473826,
    "node_id": "MDU6SXNzdWU4MzQ0NzM4MjY=",
    "number": 125,
    "title": "Ключевое слово для класса pinned",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-18T07:17:54Z",
    "updated_at": "2021-03-18T07:20:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -3\r\n_Aвтор идеи:_ **dix75**\r\n\r\nЧасто приходится наследоваться от базового класса без использования его семантики заменяемости(виртуальности).\r\nХотелось бы иметь ключевое слово добавляемое к классу, говорящее компилятору о том, что объект данного класса не будет использоваться(фигурировать) в контексте виртуальности(только как чистый объект) и всего его виртуальные функции теперь трактуются как встроенные (где это возможно).\r\n```cpp\r\nstruct A {\r\n    virtual void exec() = 0;\r\n    virtual void doSMT() = 0;\r\n    virtual ~A() {}\r\n};\r\n\r\nstruct B: A {\r\n    virtual void exec() override final {}\r\n};\r\n\r\nstruct C final : B  {\r\n    virtual void doSMT() override final {}\r\n    void clear() {}\r\n};\r\n\r\n\r\nint main()\r\n{\r\n    C c;\r\n    c.exec();\r\n    c.clear();\r\n}\r\n```\r\nВместо final  в классе использовать pinned (над словом можно поработать)\r\n\r\nВместо всего кода, компилятор понимал бы, что-то типа этого\r\n```cpp\r\nstruct C   {\r\n    void exec() {}\r\n    void doSMT() {}\r\n    void clear() {}\r\n};\r\n\r\nint main()\r\n{\r\n    C c;\r\n    c.exec();\r\n    c.clear();\r\n}\r\n```\r\nДаже \r\n\r\np.s.\r\n*    Ключевое слово рабочее, можно изменить\r\n*    Слово sealed не приемлемо так как имеет другой смысл (из других языков)\r\n*    Делегирование данных свойст ключевому слову final невозможно, т.к. на текщий момент, оно имеет другой смысл и расширение свойст врядли применимо\r\n*    В данном случаи не хочется платить за виртуальность, которая не нужна.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/125/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/125/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/124",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/124/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/124/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/124/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/124",
    "id": 833731571,
    "node_id": "MDU6SXNzdWU4MzM3MzE1NzE=",
    "number": 124,
    "title": "Operator ->? и operator ?? для указателей",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-17T12:45:27Z",
    "updated_at": "2021-03-17T12:52:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +9, -9\r\n_Aвтор идеи:_ **dix75**\r\n\r\nДобавить такую возможность (как в С#)\r\n\r\nИх нужно расматривать в совокупности, так примеры вырзительнее.\r\n\r\nТекущий вариант.\r\n```cpp\r\nint cool(Person* p) {\r\n    int x = 55;\r\n    if(p != nullptr && p->ptr != nullptr && p->ptr->sub != nullptr)\r\n      x = p->ptr->sub->toInt();\r\n    return x;      \r\n}\r\n```\r\nТам могло бы выглядеть упрощение.\r\n```cpp\r\nint cool(Person* p) {\r\n    return p?->ptr?->sub?->toInt() ?? 55;   \r\n}\r\n```\r\nЕще примеры\r\n```cpp\r\nauto x = ptr ?? 33;\r\nauto y = ptr ?? new Person();\r\nsAddedSyncIds?->Clear();\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/124/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/124/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/123",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/123/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/123/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/123/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/123",
    "id": 833721643,
    "node_id": "MDU6SXNzdWU4MzM3MjE2NDM=",
    "number": 123,
    "title": "Deducing function template arguments",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-17T12:32:34Z",
    "updated_at": "2021-03-17T12:38:49Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -2\r\n_Aвтор идеи:_ **ru.night.beast**\r\n\r\nИспользовать информацию из Template argument deduction for class templates для вывода типов в шаблонных функциях.\r\n\r\nВ С++17 появилась такая вещь как Template argument deduction for class templates\r\n\r\nВозможно есть смысл, используя эту информацию, попытаться разрешить автоматический вывод типов для функций вида:\r\n```cpp\r\ntemplate<typename T> void foo (Foo<T> const& x);\r\n```\r\nгде `Foo<T>` выводится из контекста:\r\n\r\n```cpp\r\ntemplate<typename T>\r\nstruct Foo\r\n{\r\n    Foo (T x) {}\r\n};\r\n\r\nint x;\r\nfoo(x); // что эквивалентно foo(Foo(x));\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/123/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/123/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/122",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/122/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/122/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/122/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/122",
    "id": 833669682,
    "node_id": "MDU6SXNzdWU4MzM2Njk2ODI=",
    "number": 122,
    "title": "Property Support",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-17T11:24:09Z",
    "updated_at": "2021-03-17T11:46:09Z",
    "closed_at": "2021-03-17T11:46:04Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -8\r\n_Aвтор идеи:_ **dix75**\r\n\r\nВариантов property множесто и во многих языках уже имеются, почему бы в  с++ не добавить.\r\nВозможно отвергли, тогда интересно почему.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/122/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/122/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/121",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/121/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/121/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/121/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/121",
    "id": 833621947,
    "node_id": "MDU6SXNzdWU4MzM2MjE5NDc=",
    "number": 121,
    "title": "Decimal Floating Point Support",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-17T10:26:44Z",
    "updated_at": "2021-03-17T10:27:17Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +10, -0\r\n_Aвтор идеи:_ **mrgordonfreman**\r\n\r\nДо сих пор нет поддержки чисел c фиксированной точностью\r\n\r\nУже давно был предложен следующий proposal\r\n\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3407.html\r\n\r\nНо в перечне нововведений в C++17 не нахожу подобного, есть какая-нибудь информация по этому поводу? Комитету не хватает рук или проблемы с реализацией есть?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/121/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/121/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/120",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/120/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/120/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/120/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/120",
    "id": 833247574,
    "node_id": "MDU6SXNzdWU4MzMyNDc1NzQ=",
    "number": 120,
    "title": "constexpr шаблонный cctype",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:35:39Z",
    "updated_at": "2021-03-16T22:38:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -1\r\n_Автор идеи:_ **Xottab_DUTY**\r\n\r\ncctype как и wctype перекочевали из стандартной библиотеки С как есть т.е. функции оперируют типом int (тогда как в С++ имеется 6 символьных типов char,wchar_t,char16_t,char32_t и char8_t ) и не могут использоваться в constexpr алгоритмах . Предлагаю это исправить с использованием шаблонов и constexpr.\r\n\r\nПртотоип может выглядеть например вот так:\r\n```cpp\r\n#include <climits>\r\n#include <type_traits>\r\n\r\n#if (__cplusplus >= 201703L) && defined(__cpp_char8_t)\r\n#  define HAS_CHAR8_T 1\r\n#endif\r\n\r\nnamespace std {\r\n\r\nstatic constexpr const unsigned int BITS = sizeof(unsigned int) * CHAR_BIT;\r\nstatic constexpr const unsigned int ALBT_SIZE = 26;\r\nstatic constexpr const unsigned int LAT_A = static_cast<unsigned int>('a');\r\nstatic constexpr const unsigned int LAT_A_C = static_cast<unsigned int>('A');\r\nstatic constexpr const unsigned int DEL_CHAR = 0x7f;\r\nstatic constexpr const unsigned int ACCENT_CHAR = static_cast<unsigned int>('^');\r\nstatic constexpr const unsigned int EM_CHAR = static_cast<unsigned int>('!');\r\nstatic constexpr const unsigned int LL_CHAR = static_cast<unsigned int>('_');\r\nstatic constexpr const unsigned int ZERRO = static_cast<unsigned int>('0');\r\nstatic constexpr const unsigned int SPACE = static_cast<unsigned int>(' ');\r\nstatic constexpr const unsigned int TAB = static_cast<unsigned int>('\\t');\r\nstatic constexpr const unsigned int WHITE_SPACES_COUNT = 5;\r\nstatic constexpr const char UPPER_LOWER_MASK = 0x5F;\r\n\r\ntemplate<typename> struct __is_char_type_helper : public false_type {};\r\ntemplate<> struct __is_char_type_helper<char> : public true_type {};\r\ntemplate<> struct __is_char_type_helper<wchar_t> : public true_type {};\r\ntemplate<> struct __is_char_type_helper<char16_t> : public true_type {};\r\ntemplate<> struct __is_char_type_helper<char32_t> : public true_type {};\r\n\r\n#ifdef HAS_CHAR8_T\r\ntemplate<> struct __is_char_type_helper<char8_t> : public true_type {};\r\n#endif\r\n\r\ntemplate<typename _Tp>\r\nstruct is_char_type : public __is_char_type_helper<typename remove_cv<_Tp>::type>::type\r\n{};\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type >\r\nconstexpr bool is_ascii(const char_t ch) noexcept\r\n{\r\n\treturn 0 == ( static_cast<unsigned int>(ch) & (~ DEL_CHAR) );\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_alpha(const char_t ch) noexcept\r\n{\r\n\treturn ( (static_cast<unsigned int>(ch) | BITS ) - LAT_A) < ALBT_SIZE;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_digit(const char_t ch) noexcept \r\n{\r\n\treturn (static_cast<unsigned int>(ch)-ZERRO) < 10;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_alnum(const char_t ch) noexcept\r\n{\r\n\treturn is_alpha(ch) || is_digit(ch);\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_space(const char_t ch) noexcept \r\n{\r\n\treturn SPACE == static_cast<unsigned int>(ch) || (static_cast<unsigned int>(ch) - TAB) < WHITE_SPACES_COUNT;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_lower(const char_t ch) noexcept \r\n{\r\n    return (static_cast<unsigned int>(ch)-LAT_A) < ALBT_SIZE;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_upper(const char_t ch) noexcept \r\n{\r\n    return (static_cast<unsigned int>(ch)-LAT_A_C) < ALBT_SIZE;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr char_t to_lower(const char_t ch) noexcept \r\n{\r\n    return is_upper( ch ) ? static_cast<char_t>(static_cast<unsigned char>(ch) | BITS) : ch;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr char_t to_upper(const char_t ch) noexcept \r\n{\r\n    return is_lower(ch) ? (ch & UPPER_LOWER_MASK) : ch;\r\n}\r\n\r\ntemplate<typename char_t> \r\nconstexpr bool is_cntrl(const char_t ch) noexcept\r\n{\r\n    return static_cast<unsigned int>(ch) < SPACE || ch == DEL_CHAR;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_blank(const char_t ch) noexcept\r\n{\r\n\treturn static_cast<unsigned int>(ch) == SPACE || static_cast<unsigned int>(ch) == TAB;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_graph(const char_t ch) noexcept\r\n{\r\n\treturn (static_cast<unsigned int>(ch)-EM_CHAR) < ACCENT_CHAR;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_print(const char_t ch) noexcept\r\n{\r\n\treturn  (static_cast<unsigned int>(ch)-SPACE) < LL_CHAR;\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_punct(const char_t ch) noexcept\r\n{\r\n\treturn is_graph(ch) && !is_alnum(ch);\r\n}\r\n\r\ntemplate<typename char_t, class = typename std::enable_if<std::is_char_type<char_t>::value>::type>\r\nconstexpr bool is_xdigit(const char_t ch)\r\n{\r\n\treturn is_digit(ch) || ((static_cast<unsigned int>(ch)|BITS)-LAT_A) < 6;\r\n}\r\n\r\n} // namespace std\r\n```\r\n[Немного тестов](https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5NwDMeFsgYisAag6yAwkrwBbQoI3YOABgCCchUpWZ1WggE8ADpgD6BYkwNHTF85YAzVQhXV2QnZUEIkUE7Y1kAEVUuE1oAdhNZABkASnUuADZuAtUsAIVMdBCwpycwhCZiAA53HN85VVLMcpZbAAkzAGVXTQGAJRaAFVVadq5ZTBZ8APbzFiZdTCimCVVBAnR1NL5/c32mAjxkVTQWfcwADydiG9Q7glURO7xgXsOFD48ACSk0GdiSgjwAC9MKgAhAvpDfpVVAC8gAqVSjMxjVzAyYaE5mc6Xa63e5PF7kj6In5/VEsD5mLI8SauQZAgBa2HBySKsiJJKur3ej2eIv2n2%2ByP%2BjNUWTMbLMvKFyDCTH2Gk0tJlDIIRggYCkTCNbQFvlVEoIYqpb0lOvpAPlitcZhGKoIFyu6s1WgdKIBBqNZlNhItntJVptVqlSMdcoS2CyI3GvJMDzSK3NZwjwup0epsbpAblZk0mmwADk2dixh6vWrkBr9X7pfGW9hDTIAKzYUPZ4m5sl262UmP%2B2UfbAAWRTOPrpJ9Le1bZLHa7YE3UjNgqHUbHhYnevlydrC%2B9Td9K7ja6DUlc/d3Df34sPq8nqm5YzGAHlz43my1I9A1kTsjRMR9w2ffMDxHItdSdQYAAUyx5DQISHJcgPfPU71USCc2gkcCzg4C5UmMweH/LDWxvSc7w4btNAIAjByI0VYPeeD21UAB1PoQWwdkUIrYZNB/ABVateW7MNCMjGDXzg5AGheCSkKQ7BcSyH9eK01xpyGABpNMHm7AAxOS/DMa1dAiC5MC1RwXHWTYjD2DwRGQD5QjwQR6kadxnDcBBMAYFwXhAVQnBEAAjBhhQCJgGEENxnNsDhjiOBIrN8Wz7OtLV3P2YgvJ81w/IC4ggpcVxQvCzBiC1FTGncqKYvi4VPLS4Kjio9o0hygd8uYQqtGKzzvNUXz/Ja6r0rqsKIq1AB3Ob3Da6K4oS65upqjKsoGoaiRGhyitAjzSqmmaqv2xaGqarQ5toAoNou9rtq60qepcPr1H8QarNOsbNAmq7ysq9aFvq5antU2QuDenkPs63bvv2v6jty/x5jwAIylUAYxPGKY8swOzRsc8aLpKsrpoq2bVLumHGua1SWg7VQUZ21Q9vSzGAeOuYFiWPHVhs8mCqp5jgtc2xXEmJwfBzcHUUZwL%2Be54Ubqh4L7thmWXI2WxiHJ1AADc3GQc2tQVpXQJAEB0qMR3nYBvhAYHMmKbO%2BxZeNm4mYIUgbmYQRYnQ3n/c2Dz0EdxYmHitwxa0fY45ASGg%2BCtmNZdkBzeSkQqewV3euVsxFJeWLUFQBg1dcDVkDwPAIELKHA7yFhUEeCQnH1d3VgATlNggxBYVQTHBSOIA8hsaOvYt6NA1uEDyYpggAP1URNT3GPIdyx04JZ9kH0rlwONZDpQNQjxIo6NmO0/j9Yk4qrNNCfjP1fm7O4dzh386F2LqXFw5dK6qGrrXeuyUnANFbspIOHdVBdx7pgPuA0iSmGHpgUexBx4zwgKqeeZF1wqTXmkTQqh8RgjyAAWmdEqNeWhVDMlZOyLk8RMGAyPsDaWZ8A5QyvmHW%2BSR%2BGPwOM/RODBk7v0/pnDWv9tBBzzgXZQwCna/2MOYcBkC66VXwMAQg8CuLtzIcg7uDxe4fAwUPEeY9ghEMvMuEhBoyG0K/L%2BJhlDaAmFytw6yvCnLR1sII0ON9eRiNsJ/BOr8U4fwkV/W6zs/7zRUUAvOyStEV2ImOXR0CGAsBELoYxkpTGr3Mag9BA9TjYNwePSqMC4FmMyqDCh9cDFGLIX4nKPDJaUyCQ/EJQchHhMjpE2OkjYmyISfIn%2BoCUlI0dqoouGTNG%2BB0TXPR/ltgSBKR8MpncLFWP%2BhYY4ticH2OQqhKed9HGAVoovXCy9mkUJaQ4zCTjsJ0SeZ2Mx9CKI8C8XxASkwhJXNEiMSS1Zuni0CX7QZF95ojPDhE4JEyQAxOkW/LUcjv77RzqkgByz1GZPWTk8UeTKoMFQCtRqezEXuCQSgyxaDrHVOVJ0VQdi8HvLnp8h5CFGSuNXrQhUjC7CUNYWyDk3IYW9JPnwtFoTr4orGWi6JL8sVxNxUkxRUM0lqNWfMrJGyoGVRELUOlbdEFmOZccmx5hOVcouTywhHz7kL0FaQkVYrXQjCBVK9hsqvb%2BO9lLAZCcY7KuEaihFGqpEyJxTMvFySlH/xLoAw1ADSXaPJVSRBRBXDUtpcQelByKksr7iczKRInXcvqf5C1EUZ4qVUEw8ys9Fz8rTYSzsdyrxHjmsK8hlDqF5CiipOVAS%2Bm%2B0NpGoZl8wmqrvuM%2BNUyk3p1mfihZHYlnpOzWs3NHFXwFtQK4JtVqEEayZUc1l1azmOs5fW%2BuxarXlI0B2le%2BQSjqU0tpXS%2BlDKDCMuOwOU6w39PhfOhlnMyXHqrps%2BuyBGTEAYGWm15S7WsodRyzoz7%2B3OJwiBX577mHgrQq8tprb0KRx3nOMY4HzBwrnefaNoyV3qoSZixNqdk26vmT2xZmaVkHuNXBikFLEOVXiqwAA1uh69trb1VNOZgkwtT7EEa%2BY84jK8mFDSSORo4rTKFaYFe2YdNykgAsY8fcNUHWPDKXSI%2B%2B0G11aumZulNerlFEv3RmnN2T4MQKk/5YAnhYEKfmjeyp/dVPnLqbyrtHqXHPJFTOejAbyxVhrOMWzzHxlseXaIzj6duPYt415/j0t9V%2BazQFw9QWJMIbNf5Z4AIouMqU7FnDWDn1JYvClojQq0s5FoeRoFWRd44nyzO0%2BSqnMqpc6urjmqePxKq7rATtWM3EqNcXcTo5JOtdcDFRQBBOv7Mw8puLNaEv2MquFpgkXmmFHXpuBpBSil6dmwqiNjnF1LdjW51bCaKsbcdlu1NO2931ZAQdo9zWQsnYeB0i71rFOr16%2Bp59%2BifidPfZRyhUAzOeos6NlpCMxu%2BrMEC/kXCenWUykkAA9Cz5BxsdlRIOOLJ0ugvAsAgE6RowBkBXyvcQdEmIRfm3IWp3DMQFDAA55sLnscrKcvAc9V6HwjIAE0xjJmVJHdMmRB6zAHJrvNiKEaMqMoqMw9vKxuhxH0VwaE77ploDwEwvvCQnKt8FuatuPhIU0K6CsrgfzmWEmYRMYITcPFoOZcwFv5ecqITfRqF3oGCCbi3I0JptzfvXg0vPzcuxQlNKoUg3AuDEnz6oMUmBvKVDr22jXnRM/h2zzPD7/lG4V/14b10a83uFHwmAMv%2BeIBh4j0JaPsf485BDnXysqAPiD7wE39vB8j4Z8wln4gOfPuwKYF2IvY%2BigT9P3Ao0Vfi/FFLwP8Kd%2BpAhkf%2BPkot/z9Gk5NX2vLgevV/JgRFWIZvVvdAXfTvTtb0I/E/F/M/CALIQvavJ/G/RAuBFAqQB/K/Z/BuEAhEYMNAr/fJJAkQP/AAuvMwEAsApvJ4Fva0KAoAjvS3LvQ/HvY/GeH/Ig40Eg6/b/TA8/CgnA/g/AxpYQ4gz/AQsguBEQ//YvQA4As/OgiApg6Atg2AtUeA7goQiACSVA6Q8Qwggw0QowjAggpA0wj/PAiwiQ/QygxQ6g2guacAhgyAjQ2tToXwA/OeHQvHQxC7cCMQiwtHLsQeU0VfIAhIfHD4NQtvIAvfXDbvVKLggIoxbAiCcwwQ1wMI7AiI7cKIrgGIwI%2BglwDwxImAlI3vdIi7EQrI2wnIsIkQgolffIYo2IsoxghIrgJI3wxcfw/yMI0whokvUI2IhwqQVoookowgLoio3o7GZIjg1IhA1wLnLsfCbIgPJ1XYvYzoSqDYo0RiZiEIkoHw/Yy4g47ZJwHYTALsE4lgM4i4q4/Yw4243ZY4pic2Z4x9V4vY94u4h4piAIX43Df4p1QEz4nsTQYgKgoAwYD4rYeY9QyozQ6org%2BuDY7ArYxonYiEyEm4oE7Ak4libYl4gk649YpE5Ar4zQJ47IikykqE%2B4kk74sEykwk6k4kuk0Exkv4zklk2kmEuEpwhEpEtw8o1ExY9ElY3vLEmkkQ3EsY84gU5kok3ZEQ0ks4/EwUjU%2B4rUpiBkxopkgkoUw0zQH4/k8E9U7kzU3kjkzkqkjYi00UvIJQxEu4yU7o5gmUrw9gvwzgtY7Eo0ZU9A1Um0s0/UyY7U8ktUqMu0%2B40wx4x0p0oU5M9k60p050mkjMzQPkk0%2BMiE9Mukt0mvOvT0iQb0hYncXUikjEi7KlGlOlQwlfOvLIZsl4eI30vo/ouAoMoXfyV9UtbAy/JQjsktFEno3sgMgYgcpsktXgsc9szsqcnsmArQhuecoczsyY5coAicxqNcuvJI%2BsuUtIxtS1UtKQtsoAiSK848tE/0zcwY89K84UmwpQ%2B8iKR8v0s8wM1Ywct85tEQz8uvb8o87sk8jchsoCi9UtawyI8Ch8qCp88WJ1WCwwqzXmM9YcrsGwlUrYh/bCwtPCxw28rgQ8rs9w6Umcl8gc0c0MmjFdXC3c7Agi8M%2BUe/JixIMZVixc7AhQiiqi38ui2CkQovEi/iulUCnUkQ4i5i0RaS0teQ%2BEyi1c1Cv8gU2C0wySxSnCotXcxC7Y0whS3iliwyxc1SwolcyczS087S88oI9/HigzAy%2BCi/HUxwqS4ClsswiiiC6iqU6cmCpyj81yvi3ykc1swiwSiKiyjy7A3Ar8lCmikKzQ%2BiwC2SqQHyjyiSuS7y/SwtPK7imyu81K4K9cjKnSqQ3K983SnU0whQuq5tUypC8qn8%2ByzvdCp9F1ceXxENBIQohgaQbsKQUgFgaQEwca1AaQUGXgfgPYUQcQDKeYWgcaggKa7cFfWTEAAAFjSAADpuwTA0hZAmhZATBuxZBB40g0huw0hGBpA9rxrdA6BfcJqtrSBZqpBxrBAQATBSBNqpBpqV84BYAYBEAUBUA7I8BpEyAKB4FYb4aQBgALrSBygGBrRiB/qIBYovrYoFBGgHBpB1rSA0BdBNhGQfwWAGASaQbxqsB%2Bc2BpEvr8BTZvI8BLZ/qGbSBHgW8RBrRSbxqAQwphbGA8BYpPBiAHBNAMBJApAyaPA9BhaV8Ag3gCBBgmxWbaBDquAmhB5B49qTqmg0hDbzbDbGBWB2B%2BB%2BAJbYp/rYA5YQBIF9hSBLZiBSaCg0htrvq%2B48A7RpBaEfxZBVBaE050JfgRBbbeB0gw7dBR5ehI7FhGphRaFdAGAoRkMCA/rlqJA6AV8RqpAxrPreafqHgmgChaECg9rVBRdrgmhDrQ6IBcBCASB8hZB6AsQYanA4ajy5BaA8h5q%2BBeANqtqcgV9QomAsBPaIAdqQBZBZAm6bq0haBB4TAuBB5ZA0g9quAnqpAXrSA3rzrDrzduwDqTA9qja9r0hTbuxS7prvrpA/qAagbx7SBwaoaKbe74byBKBv6%2B7ParhkA176BMbsbcb8bebCb1gZbxaKaqaCAaa6a2byZrbWbeb2bGCuatgvr%2BbkBBaFaybRai7H6Eopbia5asBxbla3rFbCj1bGQtbkpJBdb9bDbjaTBTaLbzara2AUAY6BByHHaoBnbXbg4PavafaJ6/bLhA6pBg7Q7w6edEhOAFrY6fahA87WHC7RrxrJqy7pAK6q6a7URkBrg17DqTBDraBghW6iAXgB6Q45bkb%2B75heisRBGx6GaZGp6Z7KBdGD7Xq6AuAm7aB9aTraAmgmhN6zbHqDHH6fqX7AbgbQaP7IaIAkBRACAYpg5EaAGUb6BKg27Pb6AVoItVb96S6EmZrpAB7VAVpCAEBVBjHq7a767VBG7ZBvHQbAnD63q9rG67qXozbO60h9ab77qH7anfqhBX7UnfbdquA9q9bjbaADquBaBt7z7Tr97unpmn7ZmFmwaMmMmkACnGo/6kaf7GoUBmA2AMhAbwHGpIGCaia4H6HyaYbEHkH6bH6mb0GFb/m8AObLhua8GHgBahbPmSHxbyHpbZb5aaHiAVb6G1aNbmGda9aDajaTazaeHB4%2BGbb1GhHJaRGIAxGa43bJHFbvbfbUB/b5HFGw6I7VHBH0hc6xB87B6qn9Gvry7K62mwk2BVAjrrHJ4W78AHGO6u6XGbnHH5hZAh6vG36fH57F7l7F6tXtWtX97%2Bn9rQmChLqd7Bmr69rjaEYDmkm5mUn37P7MnobXGEb/6e7AH85wg6hzY17XAXpXAHga6Ma4aIHKAoHH6YHib4HvnFgkHaa/nGa0GWagXGaQXsHwXeb8HCHxbYXeb4XKGkXPnaHKnGHNbtbWHsWOG8WCXCX7niWR7SWHb4AKXjYXaqWJHbnaXpGV8GW5G7gg6fwHgw6fxt8Wcn5KZBBOWVqC7eWrWjHTHdBBBzZrgvXB4bGShJWSmZXnHXX4aO69rlWSWenfa/Hbm569XgmHqm6ChB4uBuxuxaATrb29qCgmgZ3Zn/rbW1XSAlnG7lmd6r2zqgDn3ZACg9m%2BXDGjnx7AmuAwPEnn7VXen3aXmA7Jq9qgA%3D%3D) c разными компиляторами\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/120/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/120/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/119",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/119/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/119/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/119/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/119",
    "id": 833247131,
    "node_id": "MDU6SXNzdWU4MzMyNDcxMzE=",
    "number": 119,
    "title": "Шаблонный erase для ассоциативных контейнеров",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 5,
    "created_at": "2021-03-16T22:34:39Z",
    "updated_at": "2022-01-27T07:34:16Z",
    "closed_at": "2022-01-27T07:34:04Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -2\r\n_Автор идеи:_ **Yaroslav Shchukin**\r\n\r\nусловный `std::set::contains` добавили , а про `template<class K> iterator erase(const K& x)` забыли\r\n\r\n`template<class K> iterator erase(const K& x)` добавить, чтобы` std::less<>` использовать",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/119/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/119/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/118",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/118/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/118/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/118/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/118",
    "id": 833246247,
    "node_id": "MDU6SXNzdWU4MzMyNDYyNDc=",
    "number": 118,
    "title": "Притягивание области видимости",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:32:49Z",
    "updated_at": "2021-03-16T22:33:17Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -3\r\n_Автор идеи:_ **LevSch**\r\n\r\n\r\nПозволяет сделать язык более лаконичным за счёт отсутствия необходимости использования оператора расширения области видимости \"::\" в некоторых случаях.\r\n\r\nНа текущий момент называю это scope pulling.\r\n\r\nДалее пример, из которого, полагаю/надеюсь, всё будет очевидно.\r\n\r\nВ примере два варианта притягивания:\r\n\r\n1. очевидный\r\n\r\n2. указанный при описании агрумента функции\r\n\r\n ```cpp\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nnamespace myspace {\r\n\r\n  typedef std::vector<std::byte> ByteBuffer;\r\n\r\n  enum class LogType {\r\n    debug,\r\n    info,\r\n    fatal,\r\n    error,\r\n  };\r\n\r\n  void log(LogType logType,const std::string& str)\r\n  {\r\n    (void)logType;\r\n    // ...\r\n    std::cout << str << std::endl;\r\n  }\r\n\r\n  namespace app_resources {\r\n    // some generated ids (некоторые сгенерированные системой сборки идентификаторы)\r\n    namespace pictures {\r\n      static inline const int logo = 1;\r\n      static inline const int monaLisa = 2;\r\n    }\r\n    namespace binaries {\r\n      static inline const int defaultSqLite = 3;\r\n    }\r\n  }\r\n  ByteBuffer readResource(int resourceId) // current solution (текущее решение)\r\n  {\r\n    (void)resourceId;\r\n    // ...\r\n    return ByteBuffer();\r\n  }\r\n\r\n  // ByteBuffer readResource(int resourceId pullscope app_resources); // proposed solution (предлагаемое решение)\r\n\r\n\r\n\r\n  void sandbox()\r\n  {\r\n    // scope pulling (притягивание области видимости)\r\n    {\r\n      // obvious (очевидное)\r\n      {\r\n        log(LogType::debug,\"Log1\"); // current solution (текущее решение)\r\n        // log(debug,\"Log1\"); // proposed solution (предлагаемое решение)\r\n      }\r\n      // declared (указанное)\r\n      {\r\n        readResource(app_resources::pictures::monaLisa); // current solution (текущее решение)\r\n        // readResource(pictures::monaLisa); // proposed solution (предлагаемое решение)\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n  myspace::sandbox();\r\n  return 0;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/118/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/118/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/117",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/117/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/117/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/117/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/117",
    "id": 833245777,
    "node_id": "MDU6SXNzdWU4MzMyNDU3Nzc=",
    "number": 117,
    "title": "Fold expressions",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:31:48Z",
    "updated_at": "2021-03-16T22:32:07Z",
    "closed_at": "2021-03-16T22:32:07Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -0\r\n_Автор идеи:_ **Xottab_DUTY**\r\n\r\ntemplate ok, but template no, why?\r\n```cpp\r\ntemplate <int... args>\r\n\r\n(0 + ... + args...); // );\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/117/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/116",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/116/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/116/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/116/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/116",
    "id": 833244591,
    "node_id": "MDU6SXNzdWU4MzMyNDQ1OTE=",
    "number": 116,
    "title": "Унификация синтаксиса forward declaration для типов, ослабление текущих ограничений",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:29:16Z",
    "updated_at": "2021-03-16T22:30:42Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -3\r\n_Автор идеи:_ **Alexander Furmenkov**\r\n\r\nПроблемы:\r\n\r\n1. На данный момент делая forward declaration мы вынуждены угадывать обьявлен ли типо как class или struct, хотя явных причин для данного требования в контексте форварда мне обнаружить не удалось (есть ощущение рудиментарности).\r\n\r\n2. Мы не можем сделать forward declaration для typedef и using алиаса типа. Причину данного ограничения мне также не удалось обнаружить, возможно оно напрямую связано с п.1\r\n\r\n \r\n\r\nВозможное решение.\r\n\r\nДля поддержания обратной совместимости добавить возможность вроде:\r\n\r\nextern_type Type; // Универсальный forward declaration для struct/class/union и иных сущностей включая алиасы, объявляет не полный тип Type, на который разрешены ссылки и указатели. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/116/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/116/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/115",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/115/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/115/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/115/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/115",
    "id": 833243192,
    "node_id": "MDU6SXNzdWU4MzMyNDMxOTI=",
    "number": 115,
    "title": "Типобезопасный using/typedef",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-16T22:26:21Z",
    "updated_at": "2021-03-21T07:17:37Z",
    "closed_at": "2021-03-21T07:17:37Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +34, -0\r\n_Автор идеи:_ **Клеванец Игорь**\r\n\r\nТакой код сейчас компилируется.\r\n```cpp\r\n// C++17\r\nusing Uid = uint64_t;\r\nusing IpV4 = uint32_t;\r\n\r\nvoid foo(IpV4) {}\r\n\r\nint main() {\r\n    foo((int)0);\r\n    foo((Uid)0);\r\n\r\n    return 0;\r\n}\r\n```\r\nЧтобы обезопасить тип IpV4, нужно сделать класс, у которого надо определить все потребные операторы. Хочется иметь возможность сделать это проще: указать тип, от которого наследуюется поведение, но при этом не происходит неявного приведения типов - как в Golang. Сейчас using/typedef не создают новый тип, они дают ему новое имя.\r\n\r\nПримеры использования фичи (например, через ключевое слово explicit):\r\n```cpp\r\nusing explicit Comment = std::string;\r\nusing explicit Login = std::string;\r\nusing explicit Password = std::string;\r\n\r\nusing explicit Age = uint8_t;\r\n\r\nvoid foo(Comment comment) {}\r\n...\r\nfoo(Comment(\"like!\"));\r\n//foo(Login(argv[1])); // fails to compile\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/115/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/115/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/114",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/114/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/114/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/114/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/114",
    "id": 833242717,
    "node_id": "MDU6SXNzdWU4MzMyNDI3MTc=",
    "number": 114,
    "title": "Прокачанный switch()",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-16T22:25:18Z",
    "updated_at": "2021-03-26T15:21:10Z",
    "closed_at": "2021-03-26T15:21:10Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -2\r\n_Автор идеи:_ **ColumbusUtrigas**\r\n\r\nТрадиционно switch() умеет сравнивать только числа, енумы и символы. Хотелось бы стандартизировать сравнение любых типов, имеющих оператор сравнения (к примеру, было бы удобно уметь сравнивать std::string, не используя при этом тонну if-else).\r\n\r\nЗнаю, что это можно сделать и самому, написав простой враппер, но писать все время врапперы - имхо такое себе.\r\n\r\nРеализовать это как синтаксический сахар вокруг тех же пресловутых if-else (для тех типов, где оптимальнее нельзя).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/114/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/114/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/113",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/113/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/113/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/113/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/113",
    "id": 833242178,
    "node_id": "MDU6SXNzdWU4MzMyNDIxNzg=",
    "number": 113,
    "title": "SFINAE-friendly std::apply",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:24:11Z",
    "updated_at": "2021-03-16T22:24:58Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -1\r\n_Автор идеи:_ **webreh**\r\n\r\nПри использовании apply для типов из std функция std::apply может быть спокойно найдена по ADL. Поскольку у std::apply совершенно нет ничего про SFINAE, это дает ошибки компиляции вызовов apply(a, b) и полностью блокирует использование имени apply. Реализация не представляет сложности.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/113/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/113/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/112",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/112/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/112/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/112/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/112",
    "id": 833241981,
    "node_id": "MDU6SXNzdWU4MzMyNDE5ODE=",
    "number": 112,
    "title": "Aliasing в C++",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-16T22:23:45Z",
    "updated_at": "2021-03-16T22:23:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +11, -0\r\n_Автор идеи:_ **Антон Полухин** @apolukhin\r\n\r\nВ LLVM добавляют атрибутов для [разметки aliasing](https://reviews.llvm.org/D68484). Надо подумать, насколько они хорошо ложатся на классы C++, можно ли применить разметку к std::vector и std::string и улучшить их производительность. Если да - то надо подумать, как это донести до стандарта C++, если нет - понять что не работает и как улучшить атрибуты для алиасинга",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/112/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/112/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/111",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/111/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/111/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/111/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/111",
    "id": 833241365,
    "node_id": "MDU6SXNzdWU4MzMyNDEzNjU=",
    "number": 111,
    "title": "constexpr std::bitset",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Neargye",
        "id": 7997966,
        "node_id": "MDQ6VXNlcjc5OTc5NjY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Neargye",
        "html_url": "https://github.com/Neargye",
        "followers_url": "https://api.github.com/users/Neargye/followers",
        "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
        "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
        "organizations_url": "https://api.github.com/users/Neargye/orgs",
        "repos_url": "https://api.github.com/users/Neargye/repos",
        "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Neargye/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:22:32Z",
    "updated_at": "2022-08-11T11:36:00Z",
    "closed_at": "2022-08-11T11:36:00Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +14, -0\r\n_Автор идеи:_ **Daniil Goncharov** @Neargye \r\n\r\nstd::bitset уже имеет фиксированый размер, поэтому реализовать его с constexpr не выглядит сложно.\r\n\r\n1. Сделать std::bitset constexpr.\r\n\r\n2. Добавить std::initializer_list конструктор.\r\n\r\n3. std::string в C++20 теперь тоже constexpr, поэтому конструктор от std::string тоже легко сделать constexpr.\r\n\r\nЭто было бы удобно для разных constexpr функций с проверками контейнеров.\r\n\r\nНапример:\r\n```cpp\r\nconstexpr std::array<bool, sizeof...(I)> valid{{is_valid<I>()...}};\r\nconstexpr int count = ((valid[I] ? 1 : 0) + ...);\r\n\r\nstd::array<E, count> values{};\r\nfor (int i = 0, v = 0; v < count; ++i) {\r\n  if (valid[i]) {\r\n    ...\r\n  }\r\n}\r\n```\r\nМожно было бы написать как\r\n```cpp\r\nconstexpr std::bitset<sizeof...(I)> valid{{is_valid<I>()...}};\r\n\r\nstd::array<E, valid.count()> values{};\r\nfor (int i = 0, v = 0; v < count; ++i) {\r\n  if (valid[i]) {\r\n    ...\r\n  }\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/111/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/111/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/110",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/110/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/110/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/110/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/110",
    "id": 833239200,
    "node_id": "MDU6SXNzdWU4MzMyMzkyMDA=",
    "number": 110,
    "title": "Уточнить требования к аргументам стандартных type traits",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:18:08Z",
    "updated_at": "2021-03-16T22:21:26Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -0\r\n_Автор идеи:_ **Andrey**\r\n\r\nНынешние требования -- тип должен быть complete -- недостаточны в случае вложенных классов у которых есть NSDMI или чьи функции (в т.ч. конструкторы) имеют аргументы по умолчанию.\r\n\r\nРассмотрим такой пример (https://gcc.godbolt.org/z/b_gtT7):\r\n```cpp\r\nstruct A {\r\n    struct B {\r\n        int i = 0 /* <-- @1 */;\r\n    };\r\n\r\n    struct C {\r\n        C(int = 0 /* <-- @2 */);\r\n    };\r\n\r\n    static inline B b { }; // 1\r\n    static inline C c { }; // 2\r\n\r\n    static_assert(is_default_constructible_v<B>); // 3\r\n    static_assert(is_default_constructible_v<C>); // 4\r\n};\r\n// 5\r\n```\r\n\r\nВ точках 1 и 2 ошибка компиляции, потому что парсинг @1 и @2 откладывается до конца тела класса А (так как в точках @1 и @2 можно ссылаться на имена определенные в А ниже определения B). Соответственно static_assert-ы 3 и 4 падают, при этом очевидно, что is_default_constructible_v для B и С должны вычисляться в true в точке 5.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/110/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/110/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/109",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/109/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/109/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/109/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/109",
    "id": 833236941,
    "node_id": "MDU6SXNzdWU4MzMyMzY5NDE=",
    "number": 109,
    "title": "Возврат из функции объекта, созданного из конструктора по умолчанию",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-16T22:13:33Z",
    "updated_at": "2021-03-16T22:17:25Z",
    "closed_at": "2021-03-16T22:15:47Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -18\r\n_Автор идеи:_ **Alez**\r\n\r\nРазрешить использовать такую конструкцию return auto в функциях, где возможно создать объект\r\n```cpp\r\nT foo() {\r\nreturn auto; // return T();\r\n}\r\n```\r\n```cpp\r\nusing namespace std;\r\n\r\nvector<string> foo() {\r\n\r\n  return auto;  // Here will be: return vector<string>();\r\n\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/109/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/109/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/108",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/108/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/108/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/108/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/108",
    "id": 833235149,
    "node_id": "MDU6SXNzdWU4MzMyMzUxNDk=",
    "number": 108,
    "title": "Консистентное поведение return в конструкторах",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T22:10:08Z",
    "updated_at": "2021-03-16T22:11:50Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -10\r\n_Автор идеи:_ **Xottab_DUTY**\r\n\r\nФункции и методы, возвращающие void, позволяют вызвать другую void функцию в return statement'е, однако конструкторы такой функционал запрещают, что является досадной неконсистентностью.\r\n\r\nПример кода:\r\n```cpp\r\nvoid log(...) { }\r\n\r\nvoid func(const bool v)\r\n{\r\n    if(v) return log();\r\n}\r\n\r\nstruct S\r\n{\r\n    S(const bool v)\r\n    {\r\n        // works!\r\n        if(v) return;\r\n\r\n        // error: constructor 'S' must not return void expression\r\n        //if(v) return log();\r\n    }\r\n};\r\n```\r\nИз текущего стандарта http://eel.is/c++draft/class.ctor#6:\r\n\r\nA return statement in the body of a constructor shall not specify a return value.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/108/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/108/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/107",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/107/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/107/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/107/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/107",
    "id": 833229932,
    "node_id": "MDU6SXNzdWU4MzMyMjk5MzI=",
    "number": 107,
    "title": "Запрет на использование функций с передачей \"по значению\" в качестве типов параметров при объявлении функций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-16T22:00:34Z",
    "updated_at": "2021-03-16T22:07:53Z",
    "closed_at": "2021-03-16T22:07:53Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -12\r\n_Автор идеи:_ **Никита Колотов**\r\n\r\nС давних времен в С и С++ имеется специальное правило, по которому параметры функций с типом функция T на деле получают тип указатель на T: [dcl.fct] 11.3.5 Functions 5 ... After determining the type of each parameter, any parameter of type “array of T” or of function type T is adjusted to be “pointer to T”. C параметрами-функциями сложностей меньше, чем с параметрами-массивами, но они тоже зачастую приводят к различным проблемам:\r\n1. игнорирование опциональности такого параметра:\r\n```cpp\r\nvoid foo(int bar(int))\r\n{\r\n    cout << bar(2); // fail\r\n}\r\n...\r\nfoo(nullptr);\r\n```\r\n2. неочевидная невозможность задать const квалификатор для такого параметра чтобы соблюсти const-correctness:\r\n```cpp\r\nusing action_t = int (int);\r\n\r\nvoid test(action_t const action) // const is not applied to pointer\r\n{\r\n    action = 0; // wat\r\n}\r\n```\r\n3. могут иметь место расхождения между объявлениями функции  и / или ее определением, создавая неразбериху:\r\n```cpp\r\nusing action_t = int (int);\r\n\r\nvoid test(action_t action);\r\nvoid test(action_t * p_action); // same as above\r\n```\r\n4. дополнительные сложности в случае с most vexing parse:\r\n```cpp\r\nint x(int()); // парсится не как переменная x, а как объявление функции\r\n...\r\nx = 4; // компилятор сообщит об ошибке тут, а не в месте некорректного объявления x\r\n```\r\nСоответственно я предлагаю это правило заменить на прямой запрет таких действий: If function has parameter of type “function T” the program is ill-formed.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/107/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/107/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/106",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/106/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/106/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/106/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/106",
    "id": 833202189,
    "node_id": "MDU6SXNzdWU4MzMyMDIxODk=",
    "number": 106,
    "title": "Запрет на использование массивов с передачей \"по значению\" в качестве типов параметров при объявлении функций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T21:14:34Z",
    "updated_at": "2021-03-16T22:08:30Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +13, -1\r\n_Автор идеи:_ **Никита Колотов**\r\n\r\nС давних времен в С и С++ имеется специальное правило, по которому параметры функций с типом массив T на деле получают тип указатель на T: [dcl.fct] 11.3.5 Functions 5 ... After determining the type of each parameter, any parameter of type “array of T” or of function type T is adjusted to be “pointer to T”. Это правило выглядит неконсистентным даже на фоне прочих языковых неурядиц. Однако главное в том, что его использование приводит к опасному сочетанию \"подразумевания\" наличия у такого параметра свойств массива с о стороны разработчика с \"попустительством\" со стороны компилятора для которого это просто указатель. На практике это часто выливается в целый букет дефектов, как то:\r\n\r\n1 закладывание на то, что массив действительно имеет указанный размер:\r\n```cpp\r\nvoid foo(int items[10])\r\n{\r\n    for(size_t item_index{}; item_index < 10; ++item_index) // fail\r\n    {\r\n        cout << items[item_index];\r\n    }\r\n}\r\n...\r\nint items[5];\r\nfoo(items);\r\n```\r\n2 попытки получить размер массива \"как обычно\":\r\n```cpp\r\nvoid foo(int items[100])\r\n{\r\n    size_t items_count{sizeof(items) / sizeof(items[0])}; // fail\r\n    for(size_t item_index{}; item_index < items_count; ++item_index)\r\n    {\r\n        cout << items[item_index];\r\n    }\r\n}\r\n\r\n3 игнорирование опциональности такого параметра:\r\n```cpp\r\nvoid foo(int items[10])\r\n{\r\n    cout << items[0]; // fail\r\n}\r\n...\r\nfoo(nullptr);\r\n```\r\n4 промахи с вызовом перегрузок:\r\n```cpp\r\nvoid foo(int poks[10], int raks[10])\r\n{\r\n    swap(poks, raks); // oops\r\n}\r\n```\r\n5 неочевидная невозможность задать const квалификатор для такого параметра чтобы соблюсти const-correctness:\r\n```cpp\r\nvoid foo(int const items[10])\r\n{\r\n    items = nullptr; // this is fine\r\n}\r\n```\r\nВ С возникающие проблемы по большей части такие же, хотя там может добавится дополнительная головная боль с VLA и использоваться несовместимый (и бесполезный) синтаксис со `static` размером `void foo(int items[static 10])`.\r\n\r\nПри этом я затрудняюсь найти хоть какие-то полезные применения для этого правила. Мне представляется, что все возможные сценарии можно без проблем реализовать переходом на передачу массива по ссылке / по указателю, либо на передачу просто сырого указателя (+ количество элементов),  либо на передачу array_view. Соответственно я предлагаю это правило заменить на прямой запрет таких действий: If function has parameter of type “array of T” the program is ill-formed.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/106/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/106/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/105",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/105/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/105/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/105/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/105",
    "id": 833046908,
    "node_id": "MDU6SXNzdWU4MzMwNDY5MDg=",
    "number": 105,
    "title": "Пометить некоторые функции и классы стандартной библиотеки атрибутом [[nodiscard]]",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      },
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-16T17:36:36Z",
    "updated_at": "2021-03-17T09:26:52Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +7, -0\r\n_Aвтор идеи:_ **Andrey Davydov**\r\n\r\nВ С++17 появился очень полезный атрибут [[nodiscard]], но, как я понимаю, он еще не был использован ни для каких стандартных функций и классов, хотя некоторые из них стопроцентно являются nodiscard.\r\n\r\n[[nodiscard]] классы:\r\n\r\n* thread\r\n* unique_lock\r\n* lock_guard\r\n* scoped_lock\r\n\r\n[[nodiscard]] функции:\r\n\r\n* async\r\n\r\nЭти списки, наверняка, могут быть расширены.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/105/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/105/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/104",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/104/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/104/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/104/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/104",
    "id": 833043455,
    "node_id": "MDU6SXNzdWU4MzMwNDM0NTU=",
    "number": 104,
    "title": "String representation of the template argument type name in the compile time",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T17:32:24Z",
    "updated_at": "2021-03-16T17:34:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +0, -2\r\n_Aвтор идеи:_ **konyuchenko.nikita**\r\n\r\nSomething like std::type_name::value;\r\n\r\nОчень хочется получить что-нибдуь осмысленное в static_assert например.\r\n```cpp\r\ntemplate <typename T>\r\nvoid method() {\r\n  static_assert(false, std::type_name<T>::value \" is not supported\");\r\n}\r\n\r\ntemplate <>\r\nvoid method<SupportedType>() { impl; }\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/104/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/104/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/103",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/103/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/103/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/103/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/103",
    "id": 832566671,
    "node_id": "MDU6SXNzdWU4MzI1NjY2NzE=",
    "number": 103,
    "title": "Расширение лямбда-выражений, допускающее перегрузку оператора ()",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T08:56:52Z",
    "updated_at": "2021-03-16T08:58:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -9\r\n_Автор идеи:_ **pooh**\r\n\r\nВозможность вызова лямбды для различных наборов аргументов может возникнуть, когда нам в зависимости от контекста необходимо выполнить различные действия. Примерами подобных ситуаций могут служить, например:\r\n\r\n- Передача разных коллбэков для штатного продолжения и обработки ошибок в асинхронном коде\r\n\r\n- Использование различных обработчиков для возвращаемого значения и исключения в completable future\r\n\r\nПередача двух отдельных лямбд хороша до тех пор, пока им не нужно захватывать одни и те же переменные. Как только обеим лямбдам нужна одна и та же переменная, мы либо должны делать лишнее копирование, либо, если переменная move-only, искать обходные пути, которые зачастую неэффективны. Чаще всего проблема возникает именно в асинхронном коде, когда мы не можем захватывать объекты по ссылке. Возможность перегрузки оператора () устраняет эту проблему.\r\n\r\nС точки зрения синтаксиса такая конструкция может быть описана, например, так (пример полностью синтетический):\r\n```cpp\r\nauto l = [a, b = std::move(b)]\r\n[\r\n    (int x) -> auto { return a.f(x); },\r\n    (char* x) -> auto { return b.g(x); }\r\n];\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/103/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/103/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/102",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/102/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/102/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/102/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/102",
    "id": 832565085,
    "node_id": "MDU6SXNzdWU4MzI1NjUwODU=",
    "number": 102,
    "title": "Aligned memcpy(), memset(), memcmp(), etc",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T08:54:53Z",
    "updated_at": "2021-03-16T08:55:37Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +16, -1\r\n_Автор идеи:_ **claprix**\r\n\r\nhttps://godbolt.org/z/c8G8Hh\r\nВ примере видно, что если компилятору сказать о выравнивании это может давать положительный эффект на оптимизацию кода на некоторых платформах.\r\n\r\nЭта штука может быть полезна для сериализации, где происходит копированние данных между структурами C++ и массивом байтов.\r\n\r\nЕсли кто-то собирает код с -march=native, -mtune=native такое не сильно ускорит работу программы. Но если такой возможности нет, например, если раздаем бинарник людям с разными процессорами, то в этом может быть смысл.\r\n\r\nПока что совсем не представляю как это может выглядеть в C++. Может какой-нибудь std::aligned_copy() и прочее?\r\n\r\nЗаодно, если в эти функции положить ассерты на проверку выравнивания это может помочь ловить баги у себя в коде.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/102/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/102/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/101",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/101/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/101/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/101/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/101",
    "id": 832562333,
    "node_id": "MDU6SXNzdWU4MzI1NjIzMzM=",
    "number": 101,
    "title": "Формализация обменов и релокации (предварительно)",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T08:51:21Z",
    "updated_at": "2021-03-16T08:54:17Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -2\r\n_Автор идеи:_ **webreh**\r\n\r\nПредлагается добавить операцию обмена как встроенную в язык. Релокацию предлагается считать формой этой операции, при которой обмен производится с областью памяти, в которой не находится объекта.\r\n\r\nУказание = default для операции в форме relocate подразумевает и указание = default для операции обмена (пункт 3 ниже).\r\n\r\nМысли на подумать:\r\n\r\nNote. This text refers to all concepts (including Relocatable and TriviallyRelocatable) as a 'natural' type property, not as they are defined by P1144R4 or by the standard.\r\n\r\n1. swap should not be understood as a move construction, two move-assignments, and a destroy. Not every Swappable is MoveConstructible. Also, not every TriviallyRelocatable is MoveConstructible (see below).\r\n2. every Relocatable is Swappable (implement swap with 3 relocations)\r\n3. every TriviallySwappable (that is: object may be swapped by swapping its binary representation) is TriviallyRelocatable (Implement relocation as a trivial swap with zero-initialized memory and optimize the memory initalization out)\r\n4. not every Swappable is Relocatable\r\n5. under some assumptions every Destructible MoveConstructible Swappable is Relocatable (see below)\r\n\r\nConsequencies:\r\n(1) and (4) imposes both swap and relocate as basic operators and triviality as a property of that operator.\r\n\r\nBelow:\r\n\r\n1. Imagine not_null_unique_ptr<T> class that is similar to unique_ptr<T> but does not provide user-defined _Deleter and never holds the nullptr value. It can be trivially swapped (e.g. with 3 memcpy), it can be trivially relocated. It is not MoveConstructible as it can neither create a new value nor left the rhs value as nullptr.\r\n\r\n4. You can swap inner lists of callbacks_list instances. You can not relocate callback_list as you're conventionally not allowed to invalidate references to callbacks_list (callbacks_list is not Destructible).\r\n\r\n5. Here T{__movedout_tag} constructs the object exactly in a state it is left after calling a move ctor\r\n```cpp\r\nT * reallocate(T * current, size_t n, size_t new_size) {\r\n   T * x = allocate(new_size);\r\n   for (auto i : indices(n))  {\r\n       T & y = *new (x + i) T{__movedout_tag};\r\n       y <~> current[i];\r\n       current[i].~T();\r\n   }\r\n   return x;\r\n}\r\n```\r\nWe assume we can omit T y{__movedout_tag} t; followed by y.~Y() as copy/move elision does exactly the same.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/101/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/101/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/100",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/100/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/100/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/100/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/100",
    "id": 832559603,
    "node_id": "MDU6SXNzdWU4MzI1NTk2MDM=",
    "number": 100,
    "title": "Перегрузка оператора точки",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      },
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-16T08:47:49Z",
    "updated_at": "2021-03-20T07:35:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -10\r\n_Автор идеи:_ **Xottab_DUTY**\r\n\r\nНе так давно этот вопрос поднимался и были соответствующие предложения, но статус мне их неизвестен, возможно, обсуждение не заканчивалось и предложения всё ещё дорабатываются.\r\n\r\nhttp://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0060r0.html\r\n\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/100/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/100/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/99",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/99/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/99/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/99/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/99",
    "id": 832558329,
    "node_id": "MDU6SXNzdWU4MzI1NTgzMjk=",
    "number": 99,
    "title": "Разрешить задавать атрибут [[deprecated]] для функций-членов класса вне его объявления",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T08:46:01Z",
    "updated_at": "2021-03-16T08:47:16Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -5\r\n_Автор идеи:_ **Алексей Телишев**\r\n\r\nХотелось бы помечать некоторые функции классов из стронних библиотек (например, Qt) помечать как [[deprecated]] для того, чтобы их нельзя было использовать. Для обычных функций это работает  - нужно заново сделать декларацию функции, пометив ее как [[deprecated]]. Для функций-членов класса это не работает - вне класса можно писать только определение функции, а декларацию нельзя. В идеале было бы, если бы работал следующий синтаксис:\r\n```cpp\r\nstruct X\r\n{\r\n  double f (double x);\r\n};\r\n\r\n[[deprecated]] double X::f (double);\r\n```\r\nИнтересно, что в gcc такой синтаксис почти работает - он выдает предупреждение для каждого вызова такой функции, но при этом сначала выдаст ошибку \"declaration of '...' outside of class is not definition\"",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/99/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/99/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/98",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/98/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/98/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/98/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/98",
    "id": 832555314,
    "node_id": "MDU6SXNzdWU4MzI1NTUzMTQ=",
    "number": 98,
    "title": "Запрет на использование функций с передачей \"по значению\" в качестве типов параметров при объявлении функций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T08:41:54Z",
    "updated_at": "2021-03-16T08:45:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -2\r\n_Автор идеи:_ **Никита Колотов**\r\n\r\nНесоответствие объявленного типа таких параметров фактическому (например в int foo(int action()) параметр action - это указатель) затрудняет работу с ними провоцирует возникновение дефектов в программах.\r\n\r\nС давних времен в С и С++ имеется специальное правило, по которому параметры функций с типом функция T на деле получают тип указатель на T: [dcl.fct] 11.3.5 Functions 5 ... After determining the type of each parameter, any parameter of type “array of T” or of function type T is adjusted to be “pointer to T”. C параметрами-функциями сложностей меньше, чем с параметрами-массивами, но они тоже зачастую приводят к различным проблемам:\r\n1. игнорирование опциональности такого параметра:\r\n```cpp\r\nvoid foo(int bar(int))\r\n{\r\n    cout << bar(2); // fail\r\n}\r\n...\r\nfoo(nullptr);\r\n```\r\n2. неочевидная невозможность задать const квалификатор для такого параметра чтобы соблюсти const-correctness:\r\n```cpp\r\nusing action_t = int (int);\r\n\r\nvoid test(action_t const action) // const is not applied to pointer\r\n{\r\n    action = 0; // wat\r\n}\r\n```\r\n3. могут иметь место расхождения между объявлениями функции  и / или ее определением, создавая неразбериху:\r\n```cpp\r\nusing action_t = int (int);\r\n\r\nvoid test(action_t action);\r\nvoid test(action_t * p_action); // same as above\r\n```\r\n4. дополнительные сложности в случае с most vexing parse:\r\n```cpp\r\nint x(int()); // парсится не как переменная x, а как объявление функции\r\n...\r\nx = 4; // компилятор сообщит об ошибке тут, а не в месте некорректного объявления x\r\n```\r\nСоответственно я предлагаю это правило заменить на прямой запрет таких действий: If function has parameter of type “function T” the program is ill-formed.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/98/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/98/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/97",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/97/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/97/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/97/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/97",
    "id": 832535451,
    "node_id": "MDU6SXNzdWU4MzI1MzU0NTE=",
    "number": 97,
    "title": "Strict memory order check in compile time",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-16T08:14:43Z",
    "updated_at": "2021-03-16T08:43:32Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -1\r\n_Aвтор идеи:_ **konyuchenko.nikita**\r\n\r\nПроблема: \r\n```cpp\r\n#include <atomic>\r\n#include <cstdio>\r\nvoid f()\r\n{\r\n  std::atomic<int> a;\r\n  a.store(11, std::memory_order_release);\r\n  a.store(10, std::memory_order_acquire);\r\n  std::printf(\"%d\\n\", (int)a);\r\n}\r\n```\r\nДанный код компилится VC++ и GCC/Clang и дает весьма странные результаты (при этом нет варнингов).\r\n\r\nmsvc вообще делает nop в релизной сборке.\r\n\r\nНедопустимые значения memory_order должны приводить к ошибке компиляции. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/97/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/97/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/96",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/96/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/96/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/96/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/96",
    "id": 832528316,
    "node_id": "MDU6SXNzdWU4MzI1MjgzMTY=",
    "number": 96,
    "title": "Текстовое представление элементов scoped enum'а",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-16T08:04:35Z",
    "updated_at": "2021-03-16T08:08:58Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +11, -3\r\n_Aвтор идеи:_ **mrgordonfreman**\r\n\r\nНередко приходится иметь дело (особенно в задачах логирования) с представлением элементов перечисления в текстовом виде. Разработчики решают эту задачу по-разному, причем в одном проекте могут сосуществовать несколько способов. Поэтому хочется иметь одно стандартное решение на уровне языка, при этом не забывая о принципе \"you don't pay for what you don't use\".\r\n\r\nДля этого предлагаю расширить объявление scoped enum'а следующим образом:\r\n```cpp\r\nenum class color: int, char\r\n{\r\n    red,\r\n    green,\r\n    blue\r\n};\r\n\r\n//usage\r\ncolor c = color::blue;\r\nstd::cout << static_cast<int>(c) << std::endl;\r\nstd::cout << static_cast<char const*>(c) << std::endl;\r\n```\r\n```\r\n//output\r\n2\r\nblue\r\n```\r\nЕсли за типом элементов перечисления следует символьный тип (char, wchar_t), то необходимо \"включить\" возможность получения текстового представления с помощью конструкции static_cast. По умолчанию текстовое представление соответствует имени элемента в перечислении.\r\n\r\nЯвно задать текст можно следующим образом:\r\n```cpp\r\nenum class color: int, wchar_t\r\n{\r\n    red(L\"Red color\") = 100,\r\n    green,\r\n    blue(L\"Blue color\")\r\n};\r\n\r\n//usage\r\ncolor c = color::blue;\r\nstd::wcout << static_cast<int>(c) << std::endl;\r\nstd::wcout << static_cast<wchar_t const*>(c) << std::endl;\r\n```\r\n```\r\n//output\r\n102\r\nBlue color\r\n```\r\nЕсли за типом элементов перечисления не следует символьный тип, то механизм текстовых представлений для этого перечисления не используется. В этом случае попытка static_cast к указателю на строку должна порождать ошибку компиляции.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/96/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/96/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/95",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/95/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/95/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/95/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/95",
    "id": 831985576,
    "node_id": "MDU6SXNzdWU4MzE5ODU1NzY=",
    "number": 95,
    "title": "Запрет на произвольный порядок записи инициализаторов в списках инициализации в конструкторах",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T16:32:35Z",
    "updated_at": "2021-04-06T19:16:18Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +23, -3\r\n_Автор идеи:_ **Никита Колотов**\r\n\r\nСейчас в списках инициализации инициализируемые сущности могут быть записаны в любой последовательности, однако реальный порядок инициализации от этой последовательности никак не зависит, что провоцирует возникновение дефектов в программах.\r\n\r\nОчередность инициализации строго задается порядком наследования базовых классов и объявлением полей этого класса, однако , хотя интуитивно кажется определяющим.\r\n\r\n15.6.2 [class.base.init] 13 In a non-delegating constructor, initialization proceeds in the following order:\r\n(13.1) First, and only for the constructor of the most derived class (6.6.2), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where “left-to-right” is the order of appearance of the base classes in the derived class base-specifier-list.\r\n(13.2) Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list\r\n(regardless of the order of the mem-initializers).\r\n(13.3) Then, non-static data members are initialized in the order they were declared in the class definition\r\n(again regardless of the order of the mem-initializers).\r\n\r\nНа практике это может приводить ко следующим проблемам:\r\n\r\n1. Неопределенное Поведение непосредственно из-за использования неинициализированных полей:\r\n```cpp\r\nstruct foo\r\n{\r\n    foo(void)\r\n    : frob{42}\r\n    , zig{frob * 2} // frob is uninitialized at this point\r\n    {}\r\n\r\n    int zig;\r\n    int frob;\r\n};\r\n```\r\n2. промахи с порядком вызова функций с побочными эффектами, используемых при инициализации:\r\n```cpp\r\nint first(void);\r\nint second(void);\r\n\r\nstruct foo\r\n{\r\n    foo(void)\r\n    : frob{first()}\r\n    , zig{second()} // second is called prior to first\r\n    {}\r\n\r\n    int zig;\r\n    int frob;\r\n};\r\n```\r\nВ современных компиляторах уже достаточно давно реализованы диагностические сообщения на такой случай (-Wreorder). Соответственно я предлагаю добавить в стандарт требование однозначного соответствия следования инициализаторов в списке инициализации реальному порядку их вызова.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/95/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/95/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/94",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/94/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/94/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/94/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/94",
    "id": 831983293,
    "node_id": "MDU6SXNzdWU4MzE5ODMyOTM=",
    "number": 94,
    "title": "Elvis operator",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T16:29:57Z",
    "updated_at": "2021-04-06T19:07:47Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +34, -5\r\n_Автор идеи:_ **Jovibor**\r\n\r\nhttps://en.wikipedia.org/wiki/Elvis_operator\r\n\r\n```cpp\r\nauto ptr = func() ?: otherPtr;`\r\n```\r\nВместо:\r\n\r\n```cpp\r\nauto ptr = func() ? func() : otherPtr;`\r\n\r\n//или\r\n\r\nauto p = func();\r\nauto ptr = p ? p : otherPtr;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/94/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/94/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/93",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/93/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/93/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/93/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/93",
    "id": 831982383,
    "node_id": "MDU6SXNzdWU4MzE5ODIzODM=",
    "number": 93,
    "title": "Extended name lookup for methods",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T16:28:54Z",
    "updated_at": "2021-03-15T16:29:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -4\r\n_Автор идеи:_ **alex-ganyukhin**\r\n\r\nСама идея не нова, это уже есть в некоторых других языках программирования, например, C#.\r\n\r\nВ мире C++ на текущий момент времени, если есть необходимость добавить какой-либо функционал в класс, но нет доступа к исходникам, приходится использовать обычные функции, что логически не позволяет разделить функции на \"функции, расширящие функционал типа\" и \"функции, использующие объект данного типа\".\r\nНапример, std::string:\r\n    1. Функция trim(string &), убирающая все пробелы, является расширением для string, и запись string.trim() точно отражает суть\r\n    2. Функция display(string const &), отображающая строку, не является расширением и просто оперирует объектом string, и запись display(string) точно отражает суть\r\n\r\nИдея\r\nРасширить name lookup, чтобы вызовы вида \"classInstance.classMethod(args...); \" \"искались\" не только, как \"ClassType::classMethod(args...)\", но и как \"extension classMethod(ClassType <const, volatile> &, args...)\"; где extension - новое ключевое слово, говорящее, что  \"classMethod(ClassType <const, volatile> &, args...) может быть найден\" при \"classInstance.classMethod(args...); \".\r\nДетальнее - в примере.\r\n```cpp\r\nextension void trim(string & s)\r\nvoid display(string const & s);\r\n\r\n// later\r\nstd::string str { \" hello\" }:\r\n\r\nstr.trim();   // Ok, possible\r\nstr.display() // Error, not allowed, not an \"extension\"\r\n\r\ntrim(str);     // Ok, also possible\r\ndisplay(str);  // Ok, the only possible\r\n```\r\nДетали\r\n  1. \"Расширяемый\" тип данных должен быть указан первым аргументом\r\n  2. \"Расширяемый\" тип данных должен быть передан по ссылке\r\n  3. В функции-расширении доступны только публичные члены класса (альтернативно, можно дать доступ и к protected)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/93/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/93/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/92",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/92/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/92/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/92/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/92",
    "id": 831979352,
    "node_id": "MDU6SXNzdWU4MzE5NzkzNTI=",
    "number": 92,
    "title": "Запретить конструировать uniform_int_distribution<T> от одного int",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T16:25:32Z",
    "updated_at": "2021-03-15T16:25:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -2\r\n_Автор идеи:_ **riad**\r\n\r\nСейчас генерируется число от этого аргумента до numeric_limit<T>. На мой взгляд это не ожидаемое поведение (я часто так пишу ожидая, что вернётся от 0 до n, кроме того достаточно редко нужное (зачем вообще)?\r\n\r\nУтверждается, что так случилось просто потому, что аргументы раньше было два аргумента по умолчанию и так можно было обойтись одни конструктором вместо двух (но теперь их уже всё равно два)\r\n\r\n \r\n\r\nПредлагается убрать значение аргумента по умолчанию (ну и изменить описание конструктора по умолчанию)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/92/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/92/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/91",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/91/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/91/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/91/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/91",
    "id": 831932731,
    "node_id": "MDU6SXNzdWU4MzE5MzI3MzE=",
    "number": 91,
    "title": "Слайсы из Python",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-15T15:35:02Z",
    "updated_at": "2022-01-03T17:33:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +4, -5\r\n_Aвтор идеи:_ **dix75**\r\n\r\nИмпользование слайсов из питона в с++ упростило бы написание С++ кода и мне видится их использование в двух различных местах.\r\n\r\n1. В качестве оператора operator[::] для стнадартных контейнеров и для пользовательских классов.\r\n```cpp\r\nstruct Vec {\r\n   std::vector<int> vec;\r\n\r\n   auto operator[::](int start, int end, int step) noexcept {\r\n       return vec[start : end : step];\r\n   }\r\n   // or\r\n   auto operator[::](int start, int end, int step) noexcept {\r\n       std::vector<int> vec;\r\n       for(int i = start; i != end; i += step)\r\n           vec.push_back(i);\r\n        return vec;   \r\n   }\r\n};\r\n\r\n// usage\r\nint main() {\r\n   Vec vec;\r\n   //... filling vec;\r\n   for(auto i : vec[1:10:2])\r\n     std::cout << i << std::endl;\r\n   return EXIT_SUCCESS;\r\n}\r\n// or\r\nint main() {\r\n   for(auto i : [1:10:2])\r\n     std::cout << i << std::endl;\r\n   return EXIT_SUCCESS;\r\n}\r\n```\r\n2. В качестве оператора operator[::] для variadic template\r\n```cpp\r\ntemplate<class T>\r\ninline void step(T&& t) noexcept {\r\n  //\r\n}\r\n\r\ntemplate<class... Args>\r\ninline void unreverse(Args&&... args) noexcept {\r\n   //\r\n}\r\n\r\ntemplate<class... Args>\r\ninline void reverse(Args&&... args) noexcept {\r\n    // \r\n}\r\n\r\ntemplate<class... Args>\r\ninline void fun(Args&&... args) noexcept {\r\n    if constexpr(sizeof...(args) > 5)  // c++17\r\n        reverse(std::forward<Args>(args[::-1])...); \r\n    step(std::forward<Args>(args[1:5])...);\r\n}\r\n```\r\nРешить можно конечно и текущими средствами (`std::forward_as_tuple` and `std::get`), а также unpacking средствами. \r\n\r\nP.s. Предпологаю, что такое предложение уже поступало, в таком случае хотелось бы услышать почему отказали.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/91/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/91/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/90",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/90/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/90/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/90/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/90",
    "id": 831924983,
    "node_id": "MDU6SXNzdWU4MzE5MjQ5ODM=",
    "number": 90,
    "title": "Variadic templates для user defined literals",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-15T15:26:38Z",
    "updated_at": "2021-03-15T15:32:43Z",
    "closed_at": "2021-03-15T15:32:43Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -4\r\n_Aвтор идеи:_ **dix75**\r\n\r\nДобавить использование Variadic templates для пользовательских литералов.\r\n\r\nВ качестве аргумента приведу пример того, что хотел бы увидеть лично я. Создать функцию, которая принимала бы произвольное кол-во параметров. (аналог printf).\r\n```cpp\r\ntemplate<class... Args>\r\nconstexpr std::string operator \"\" _print(std::string cosnt& format, Args&&... args)  {\r\n    //...\r\n}\r\n// usage\r\nvoid main() {\r\n   std::cout << \"cool %i\\n\"_print(10);\r\n   std::cout << \"cool %i = %s\\n\"_print(10, \"strange\"s);\r\n   return EXIT_SUCCESS:\r\n}\r\n```\r\nТакже можно было бы написать свой простой json и xml writer к примеру.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/90/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/90/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/89",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/89/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/89/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/89/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/89",
    "id": 831911848,
    "node_id": "MDU6SXNzdWU4MzE5MTE4NDg=",
    "number": 89,
    "title": "Добавить определение типа для возращаемого значения",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T15:13:25Z",
    "updated_at": "2021-03-15T15:19:28Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +6, -7\r\n_Aвтор идеи:_ **dix75**\r\n\r\nДобавить конструкцию вида delctype(return) для определения возвращаемого значения функции.\r\n\r\nОснавня идея сводится к следующему иметь возможность использовать внутри функции такую консрукцию\r\n```cpp\r\ndouble fun() noecept {\r\n    using result_t = decltype(return);\r\n    result_t a {};\r\n    result_t b {};\r\n    ...\r\n    return a;\r\n}\r\n```\r\nНа текущий момент задачу можно решить так\r\n```cpp\r\ntemplate<class T>\r\nT fun() noecept {\r\n    using result_t = T;\r\n    result_t a {};\r\n    result_t b {};\r\n    ...\r\n    return a;\r\n}\r\n```\r\nЗдесь главное не сложность, а накладность вызова `fun<double>()`;\r\n\r\nP.s. Второй вариант кончено создает семейство функций вместо первого, но данный механизм будет уместен в более сложных случаях.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/89/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/89/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/88",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/88/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/88/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/88/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/88",
    "id": 831842143,
    "node_id": "MDU6SXNzdWU4MzE4NDIxNDM=",
    "number": 88,
    "title": "Возможность явного выбора конструктора в функциях типа \"make_<что-то-там>\"",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T14:01:37Z",
    "updated_at": "2021-03-15T15:12:11Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +12, -2\r\n_Aвтор идеи:_ **Дмитрий**\r\n\r\nstd::make_unique, std::make_shared, std::make_optional, std::make_from_tuple и т.д. — все эти функции принимают нечто, что потом забрасывается в конструктор типа T. И этот конструктор — T(...), и никакой другой.\r\nА что, если у T нет такого конструктора? Что, если мы хотим явно вызвать конструктор от std::initializer_list? Что, если T — тривиальный тип, который можно сконструировать только фигурными скобками: T{...}?\r\nСейчас пользователь никак не может повлиять на выбор способа инициализаии объекта.\r\n\r\nНо выход есть!\r\n\r\nВсю соль проблемы показывает функция `std::make_from_tuple`.\r\n \r\n\r\nСлучай первый: тривиальный тип.\r\n```cpp\r\nstruct trivial\r\n{\r\n    int x;\r\n    double y;\r\n};\r\n\r\nmake_from_tuple<trivial>(make_tuple(1, 3.14)); // Ошибка компиляции.\r\n```\r\nПример показывает, что данный случай просто не покрывается текущей редакцией стандартной библиотеки. Тривиальный тип создать из кортежа при помощи функции `std::make_from_tuple` невозможно.\r\n \r\nСлучай второй: наличие разных вариантов конструктора.\r\n\r\nДля простоты возьмём `std::vector`.\r\n```cpp\r\nmake_from_tuple<vector<size_t>>(make_tuple(5, 1));\r\n// Какой вектор должен быть создан?\r\n// [1, 1, 1, 1, 1] или [5, 1]?\r\n```\r\nВ текущей редакции всегда будет вызван первый вариант, то есть мы получим пять единичек.\r\n\r\nИ нет принципиальной возможности вызвать второй вариант.\r\n\r\n**Решение**\r\n\r\nСуть решения чрезвычайно проста — она состоит в использовании перегрузки по тегам.\r\n\r\nСоздаём два тега, каждый из которых будет сигнализировать о том, что нужно позвать либо круглые, либо фигурные скобки соответственно (имена черновые):\r\n```cpp\r\ntemplate <typename T>\r\nstruct parens_t {};\r\n\r\ntemplate <typename T>\r\nconstexpr auto parens = parens_t<T>{};\r\n\r\ntemplate <typename T>\r\nstruct braces_t {};\r\n\r\ntemplate <typename T>\r\nconstexpr auto braces = braces_t<T>{};\r\n```\r\nПолучаем:\r\n```cpp\r\nauto a = make_unique(parens<A>, 1, 3); // A(1, 3)\r\nauto b = make_unique(braces<A>, 1, 3); // A{1, 3}\r\n\r\nauto c = make_from_tuple(parens<A>, std::make_tuple(100, 3.14)); // A(100, 3.14)\r\nauto d = make_from_tuple(braces<A>, std::make_tuple(100, 3.14)); // A{100, 3.14}\r\n// Раньше фигурные скобки вообще нельзя было позвать. Никак. Совсем.\r\n// Теперь можно.\r\n```\r\nТакже обращаю внимание на то, что при использовании такого тега тип объекта выводится из тега, то есть его не надо указывать явно:\r\n```cpp\r\n// Раньше:\r\nauto a = make_shared<very_very_very_long_type_name>(very_very_very_long_type_name{1, 3});\r\n\r\n// Теперь:\r\nauto b = make_shared(braces<very_very_very_long_type_name>, 1, 3);\r\n```\r\nВсе старые перегрузки, естественно, остаются. Просто теперь есть возможность явного выбора способа инициализации.\r\n\r\nАналогично это будет работать и с функциями типа `emplace_back`, которые также принимают набор параметров, которые нужно передать конструктору объекта.\r\n\r\n**Пример для подражания**\r\n\r\nТакой подход для стандартной библиотеки не нов. Похожая схема применяется с тегом `std::in_place_type`, например, при конструировании класса `std::variant`. Данный тег сигнализирует о том, что нужно позвать конструктор типа. Но в нашем случае мы идём чуть дальше, и даём возможность не просто просигнализировать о том, что нужно позвать конструктор, но и сообщаем какой именно это должен быть конструктор.\r\n\r\n \r\n**Итог**\r\n\r\nДанное решение:\r\n\r\n0. Упрощает жизнь и открывает новые возможности пользователю стандартной библиотеки.\r\n1. Полностью сохраняюет обратную совместимость. Ничего старого не ломается.\r\n2. Достаточно общее. Работает как с make_shared, make_unique, make_any и иже с ними, так и с make_from_tuple.\r\n3. Органично вливается в стандартную библиотеку, удобно в использовании и (возможно, субъективно) красивое.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/88/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/88/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/87",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/87/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/87/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/87/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/87",
    "id": 831803714,
    "node_id": "MDU6SXNzdWU4MzE4MDM3MTQ=",
    "number": 87,
    "title": "Простое создание(форматирование) строк",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T13:19:16Z",
    "updated_at": "2021-03-15T13:22:48Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -4\r\n_Aвтор идеи:_ **dix75**\r\n\r\nРассмотрим пример (создание простого html):\r\n```cpp\r\ninline std::string print() noexcept {\r\n    std::stringstream s;\r\n    s << \"<html>\";\r\n    for(auto i : {\"h\", \"h1\", \"h2\", \"h3\"})\r\n        s << \"\\t<\" << i << \" name=\\\"\" << i << \"\\\">\" << i << \"</\" << i <<\">\\n\";  \r\n    s << \"</html>\";\r\n    return s.str();\r\n}\r\n```\r\nВыглядит избыточно, даже сырые строки не сильно улучшают ситуацию.\r\n\r\nМое предложение взять за основу С#, python форматирование и адаптировать для строк. Комитет трепетно относится к строкам и что-то реально добавить к строкам будет весьма затруднительно.\r\n\r\nПоэтому наиболее приемлемым вариантом будет  использование конструкции на подобие (user defined literals).\r\nПример:\r\n \r\n```cpp\r\ninline std::string print() noexcept {\r\n    std::string s(\"<html>\");\r\n    for(auto i : {\"h\", \"h1\", \"h2\", \"h3\"})\r\n         s+= ($\"\\t{i} name=\"{i}\">{i}</{i}>\\n\".format(i)); \r\n    s +=\"</html>\";\r\n    return s;\r\n}\r\n```\r\nБолее того, простые варианты вполне могут быть и constexpr и скорее всего, здесь будет возможна оптимизация.\r\n\r\nВозможны и другие варианты.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/87/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/87/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/86",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/86/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/86/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/86/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/86",
    "id": 831722799,
    "node_id": "MDU6SXNzdWU4MzE3MjI3OTk=",
    "number": 86,
    "title": "Унифицированные правила создания и управления precompiled header",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-15T11:38:30Z",
    "updated_at": "2021-03-15T11:42:24Z",
    "closed_at": "2021-03-15T11:42:24Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -5\r\n_Aвтор идеи:_ **dix75**\r\n\r\nPrecompiled header поддерживают почти все компиляторы, хотелось бы одинакового поведения и управления.\r\n\r\nХотелось бы внятного, унифицированного способа создания, управления, исключения Precompiled header в больших проектах\r\n\r\n\r\nP.S. Скорее всего, производители компилляторов не пойдут на это, но попытка не пытка.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/86/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/86/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/85",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/85/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/85/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/85/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/85",
    "id": 831702302,
    "node_id": "MDU6SXNzdWU4MzE3MDIzMDI=",
    "number": 85,
    "title": "Using для статических данных",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-15T11:12:06Z",
    "updated_at": "2021-03-15T11:18:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +1, -8\r\n_Aвтор идеи:_ **dix75**\r\n\r\nЧасто необходимо использовать статические данные в определенном классе или методе и использование полного имени иногда избыточно и не всегда красиво\r\n\r\nВ качестве примера рассмотрим std::string::npos.\r\n```cpp\r\n#define NPOS1 (std::string::npos)\r\n\r\nclass TestOutput {\r\npublic:\r\n  static const auto npos2 = std::string::npos;\r\n\r\nprivate:\r\n    static bool empty(std::string const& value) noexcept {\r\n        auto const& npos = std::string::npos;\r\n        return (value.find('{') == std::string::npos || value.find('}') == npos)\r\n            || (value.find('[') == NPOS1 || value.find(']') == npos2)\r\n        ;\r\n    }\r\n};\r\n```\r\nВ кладовой программистов  есть несколько вариантов решить данную задачу, очевидные(не все) приведены в примере.\r\n\r\nХотелось бы более простого решения.\r\n```cpp\r\nclass TestOutput {\r\npublic:\r\n  using variable npos = std::string::npos;\r\n\r\nprivate:\r\n    static bool empty(std::string const& value) noexcept {\r\n        return (value.find('{') == npos || value.find('}') == npos)\r\n            || (value.find('[') == npos || value.find(']') == npos)\r\n        ;\r\n    }\r\n};\r\n```\r\nИзвестно, что using используется для типов, using namespace - для пространств имен. Возможно, using variable будет приемлемо для данного использования.\r\n\r\nP.S. Конечно решить данную задачу можно и подручными средствами, но это только пример, а в реальном коде ситуация в разы интереснее.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/85/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/85/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/84",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/84/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/84/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/84/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/84",
    "id": 831686793,
    "node_id": "MDU6SXNzdWU4MzE2ODY3OTM=",
    "number": 84,
    "title": "int128_t, int256_t,..",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-15T10:54:01Z",
    "updated_at": "2023-10-22T10:10:39Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +34, -2\r\n_Aвтор идеи:_ **Клеванец Игорь**\r\n\r\nТекущий стандарт описывает знаковые и беззнаковые типы `int8_t`, `int16_t`, `int32_t`, `int64_t`. Обычно их достаточно для ежедневной работы, но иногда появляется потребность в больших числах: криптография, IPv6, ооочень большие счётчики. Существует нестандартный тип `__in128` в gcc и clang, который подтверждает необходимость таких числах. Но сейчас не существует удобного кросс-платформенного решения. К тому же хочется не только int128, но и int256, int512 и т.д.\r\n\r\nХочется, чтобы интерфейс был идентичен интегральным типам. Например:\r\n```cpp\r\nconstexpr int128_t c = std::numeric_limits<int128_t>::min();\r\nstatic_assert(c == 0x80000000000000000000000000000000_uint128);\r\n\r\nint256_t a = 13;\r\na += 0xFF;\r\na *= 2.0;\r\na -= 12_int128;\r\nassert(a > 0);\r\n```\r\nДелать int с произвольным количеством бит фундаментальным типом на уровне языка проблематично.\r\n\r\nЗато вполне реализуемо в рамках стандартной библиотеки:\r\n```cpp\r\ntemplate<size_t Bytes, bool Signed> class wide_int;\r\n\r\nusing uint128_t = wide_int<16, false>;\r\n```\r\nProof of concept можно найти здесь: https://github.com/cerevra/int/tree/master/v2.\r\n\r\nТекст самого proposal: https://cerevra.github.io/int.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/84/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/84/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/83",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/83/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/83/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/83/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/83",
    "id": 831630440,
    "node_id": "MDU6SXNzdWU4MzE2MzA0NDA=",
    "number": 83,
    "title": "Разрешить писать свои optimized specializations для стандартной библиотеки",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-15T09:47:07Z",
    "updated_at": "2021-03-15T09:48:00Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +0, -2\r\n_Aвтор идеи:_ **Сергей Прейс**\r\n\r\nСейчас стандартные библиотеки помимо базовых шаблонных реализаций зачастую содержат оптимизированные специализации для конкретных типов данных либо используют полные инстанциации непосредственно в реализации (емнип GNU STL использует  std::uniform_distribution<double> в реализации std::normal_distribution<T>). И то и другое делает невозможным создать собственные оптимизированные специализации для классов из стандартной библиотеки.\r\n\r\nЗачем такое может понадобиться? Ну, например, если реализации алгоритмов, используемых в вашем проекте, для parallel_unsequenced_policy вас по каким-то причинам не устраивают и вы бы хотели написать свои, при этом оставив весь код на стандартном С++ для переносимости. Или вы, как производитель платформы (железа), хотели бы предоставить свои реализации std::random для float и double с использованием встроенных в платформу возможностей. \r\n\r\nСейчас работоспособность такого подхода стандартом не гарантируется и, соответственно, придется полностью клонировать <algorithm>  или <random> включая базовую реализацию. \r\n\r\nХотелось бы, чтобы стандарт предусмотрел возможности специализаций для своих интерфейсов в пользовательском коде без необходимости переопределения базовых/общих/шаблонных реализаций. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/83/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/83/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/82",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/82/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/82/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/82/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/82",
    "id": 831612239,
    "node_id": "MDU6SXNzdWU4MzE2MTIyMzk=",
    "number": 82,
    "title": "Явно запретить создание объекта для определенного типа в шаблонном классе",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-15T09:27:36Z",
    "updated_at": "2021-03-15T09:36:19Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +3, -7\r\n_Aвтор идеи:_ **dix75**\r\n\r\nНа текущий момент можно удалить определенную функцию-член в шаблонном классе, но запретить(удалить) создание целого объекта нельзя.\r\n\r\nИмеем\r\n```cpp\r\ntemplate<class T>\r\nstruct Cool {\r\n    void print() {}\r\n};\r\n\r\ntemplate<>\r\nvoid Cool<double>::print() = delete;\r\n```\r\nХотелось бы пользователю сказать, что для определенного типа нельзя создавать объекты на основе данного класса.\r\n```cpp\r\ntemplate<>\r\nvoid Cool<double> = delete;\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/82/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/82/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/81",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/81/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/81/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/81/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/81",
    "id": 831138466,
    "node_id": "MDU6SXNzdWU4MzExMzg0NjY=",
    "number": 81,
    "title": "Добавить поддержку преобразования целого числа в указатель на этапе компиляции",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:58:42Z",
    "updated_at": "2021-03-14T11:59:18Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **lamer0k**\r\n\r\nСейчас преобразование целого в указатель делается через reinterpret_cast, который запрещен в constexpr выражениях. Но если мне известен адрес на этапе компиляции, то почему я не могу привести его к типу указатель? Можно ввести, что типа pointer_cast для выполнения этой операции.\r\n\r\nНапример, регистры:\r\n\r\nМы знаем по каким адресам находятся, но чтобы в них что-то записать или прочитать, мне нужно преобрзовать этот адресс к указателю, а затем разименовать укзатель. Получается вот так сделать нельзя:\r\n```cpp\r\n#include <cstddef>\r\n\r\nstruct Register\r\n{ \r\n  constexpr Register(size_t addr): reg(*reinterpret_cast<volatile size_t*>(addr)) //! Error here\r\n  {\r\n  }\r\n\r\n  void Write(size_t data) const\r\n  {\r\n    reg = data ;\r\n  }    \r\n  \r\nprivate:\r\n  volatile size_t& reg ;\r\n} ;\r\n\r\n//size_t IDR = *reinterpret_cast<size_t*>(0x00010U) ;\r\n\r\nconstexpr Register reg(0x00010U) ; \r\n\r\nint main()\r\n{\r\n  reg.Write(10) ;\r\n}\r\n```\r\nПри этом вот так можно:\r\n```cpp\r\n#include <cstddef>\r\n\r\nstruct Register\r\n{ \r\n  constexpr Register(volatile size_t& addr): reg(addr)\r\n  {\r\n  }\r\n\r\n  void Write(size_t data) const\r\n  {\r\n    reg = data ;\r\n  }    \r\n  \r\nprivate:\r\n  volatile size_t &reg ;\r\n} ;\r\n\r\nsize_t IDR = *reinterpret_cast<volatile size_t*>(0x00010U) ;\r\n//constexpr size_t IDR = *reinterpret_cast<volatile size_t*>(0x00010U) ; //!error\r\n\r\nconstexpr Register reg(IDR) ; \r\n\r\nint main()\r\n{\r\n  reg.Write(10) ;\r\n}\r\n```\r\nБыло бы замечатедьно, если бы можно было бы сделать как то так:\r\n```cpp\r\n#include <cstddef>\r\n\r\nstruct Register\r\n{ \r\n  constexpr Register(size_t addr): reg(*pointer_cast<volatile size_t*>(addr)\r\n  {\r\n  }\r\n\r\n  void Write(size_t data) const\r\n  {\r\n    reg = data ;\r\n  }    \r\n  \r\nprivate:\r\n  volatile size_t &reg ;\r\n} ;\r\n\r\nconstexpr Register reg(0x00100) ; \r\n\r\nint main()\r\n{\r\n  reg.Write(10) ;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/81/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/81/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/80",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/80/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/80/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/80/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/80",
    "id": 831136398,
    "node_id": "MDU6SXNzdWU4MzExMzYzOTg=",
    "number": 80,
    "title": "Treat the latest use of automatic storage duration variables as xvalue expressions",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:47:40Z",
    "updated_at": "2021-03-14T11:50:47Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -6\r\n_Автор идеи:_ **Alexandr Timofeev**\r\n\r\nThe main, semantically lacking, boilerplate in the usage of the `std::move` today is for the sinking of variables that we no longer need, especially locally. It's not like the `std::move` for a transfer of ownership, but a suggestion to make an optimized copy. This proposal is similar in spirit to the current behavior of return statements, which are effectively xvalue expressions in cases when they can't be elided if an automatic storage duration variable is returned.\r\n\r\nQuestions:\r\n\r\n* What if a variable of copyable but non-movable type?\r\n\r\nWhile it's considered a defective type it can potentially break some code.\r\n\r\n* What if a copy contains side effects?\r\n\r\nWe already have a wide range of cases when copy-moves are elided and their side effects are ignored. This proposal would make more such cases.\r\n\r\n* Should we do it for with references too to support the forwarding use case?\r\n\r\nAt this point, this proposal explicitly doesn't cover reference parameters. It could make sense for rvalue references, lvalue const references, but not lvalue references.\r\n\r\n* Can vendors definitely determine the last use of such a variable?\r\n\r\nAccording to Herb Sutter's latest talk in Prague - yes. \r\n\r\n \r\n\r\nExample:\r\n```cpp\r\nvoid sample(x_type x, y_type y) {\r\n  process(x);\r\n  if (something(x)) {\r\n    process(y);\r\n    x.hold();    // last use, could be an implicit `std::move(x).hold()`?\r\n  } else {\r\n    cout << x; // last use, could be an implicit `cout << std::move(x)`\r\n\r\n  }\r\n  transfer(y);  // last use, could be an implicit `transfer(std::move(y))`\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/80/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/80/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/79",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/79/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/79/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/79/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/79",
    "id": 831135926,
    "node_id": "MDU6SXNzdWU4MzExMzU5MjY=",
    "number": 79,
    "title": "Интерфейсы-миксины",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:44:56Z",
    "updated_at": "2021-03-14T11:46:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -3\r\n_Автор идеи:_ **Николай Бахтин**\r\n\r\nЕсть идея внести в язык обособленную сущность под названием \"интерфейс\".\r\nПод словом \"интерфейс\" тут подразумевается таблица виртуальных функций, аналогичная той, что есть у классов, только без данных.\r\nСоответственно, у интерфейса нет скрытого параметра \"this\". Но можно с помощью конструкции using вызывать методы интерфейса в стиле миксинов. Так-же, я думаю, можно делать некоторые \"zero cost\" абстракции.\r\n\r\nПускай объявление интерфейса имеет вид:\r\n```cpp\r\ninterface MyInterface1\r\n{\r\n   void Method1(const char* param1, std::string param2) = 0;\r\n   void Method2(std::map<std::string,std::string>& param1, const std::string& param2) = 0;\r\n};\r\n\r\ninterface Parent1 : MyInterface1\r\n{\r\n    void Method1(const char* param1, std::string param2);\r\n    void Method2(std::map<std::string,std::string>& param1, const std::string& param2);\r\n}parent1;\r\n\r\ninterface Parent2 : MyInterface1\r\n{\r\n    void Method1(const char* param1, std::string param2);\r\n    void Method2(std::map<std::string,std::string>& param1, const std::string& param2);\r\n}parent2;\r\n\r\nvoid Parent1::Method1(const char* param1, std::string param2)\r\n{\r\n   //some code\r\n}\r\n\r\nvoid Parent1::Method2(std::map<std::string,std::string> param1, const std::string& param2)\r\n{\r\n   //some code\r\n}\r\n\r\nvoid Parent2::Method1(const char* param1, std::string param2)\r\n{\r\n   //some code\r\n}\r\n\r\nvoid Parent2::Method2(std::map<std::string,std::string> param1, const std::string& param2)\r\n{\r\n   //some code\r\n}\r\n```\r\nМетоды интерфейса вызываются так-же, как и методы класса. Только в вызове метода нет скрытого параметра \"this\".\r\n```cpp\r\nParent1 p1;\r\nParent2* p2 = &parent2;\r\np1.Method1(\"Hello World!!!\", some_string);\r\np2->Method1(\"Hello World!!!\", some_string);\r\n```\r\nТак же можно использовать using с указанием типа интерфейса и типа данных, чтобы в той области видимости, где объявлен using можно было вызывать методы интерфейса один в один как миксины;\r\n```cpp\r\nusing Parent1<char*>;\r\n\"Hello World\".Method1(some_string);\r\n\r\nstd::map<std::string, std::string> params;\r\nparams.Method2(\"addr\");\r\n```\r\nМожно сделать оптимизацию, если компилятор знает точный тип интерфейса, то не надо делать виртуальный вызов. Будет обычный вызов или inline функции.\r\nВ определенных случаях это позволит \"zero cost\" абстракции.\r\n\r\nТак же интерфейс можно сделать из уже существующийх функций.\r\n```cpp\r\ninterface CStringUtils\r\n{\r\n   size_t length(const char* str) = &strlen;\r\n   double to_double(const char* str) = &atof;\r\n   int to_int(const char* str) = &atoi;\r\n}\r\n\r\nusing CStringUtils<const char*>;\r\n\r\nsize_t v1 = \"Hello world\".length();\r\n\r\nconst char* v2_str = \"77.5\";\r\ndouble v2 = v2_str.to_double()\r\n\r\nconst char* v3_str = \"1234\";\r\nint v3 = v3_str.to_int();\r\n```\r\nНесмотря на то, что код в ООП стиле, компилятор может заменить вызовы методов миксинов на прямой вызов соотвестующийх функций из string.h",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/79/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/79/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/78",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/78/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/78/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/78/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/78",
    "id": 831135522,
    "node_id": "MDU6SXNzdWU4MzExMzU1MjI=",
    "number": 78,
    "title": "erasing_adapter",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:42:49Z",
    "updated_at": "2021-03-14T11:43:08Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -0\r\n_Автор идеи:_ **Antervis**\r\n\r\nадаптер для range-based итерации по контейнеру с удалением элементов\r\n\r\nИногда возникает простая задача пробежаться по контейнеру удаляя из него элементы при выполнении какого-то условия, либо выполняя действия над элементами. В простейшем случае это выглядит примерно так:\r\n```cpp\r\nstd::set<T> s;\r\nfor (auto it = s.begin(); it != s.end(); ) {\r\n    if (cond(*it)) {\r\n        foo(*it);\r\n        it = s.erase(it);\r\n    } else {\r\n        bar(*it);\r\n        it++;\r\n    }\r\n}\r\n```\r\nдилемма в том, что максимально эффективно эта задача решается только на итераторах, а с ними легко запутаться. Однако не слишком сложно реализовать адаптер, который позволит писать код вот так:\r\n```cpp\r\nstd::set<T> s;\r\nfor (auto a = erasing_adapter(s); auto& x : a) {\r\n    if (cond(x)) {\r\n        foo(x);\r\n        a.erase_current();\r\n    } else {\r\n        bar(x);\r\n    }\r\n}\r\n```\r\nгде erase_current() будет лишь выставлять флаг, в зависимости от которого итератор адаптера в операции инкремента будет сначала удалять текущий. [proof of concept](https://godbolt.org/z/GLrk_X). Note: для некоторых типов структур данных нужно будет сделать специализации, например, такая будет делать O(N^2) мувов для std::vector\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/78/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/78/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/77",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/77/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/77/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/77/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/77",
    "id": 831135270,
    "node_id": "MDU6SXNzdWU4MzExMzUyNzA=",
    "number": 77,
    "title": "Добавить функцию subelements в STL контейнеры",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-14T11:41:29Z",
    "updated_at": "2021-03-14T15:27:26Z",
    "closed_at": "2021-03-14T15:27:05Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -4\r\n_Автор идеи:_ **digitalEugene**\r\n\r\nДобавить в стандартные контейнеры вроде std::vector и std::list функцию subelements, которая будет аналогом std::string::substr.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/77/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/77/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/76",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/76/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/76/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/76/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/76",
    "id": 831135019,
    "node_id": "MDU6SXNzdWU4MzExMzUwMTk=",
    "number": 76,
    "title": "Стандартные функции для хеширования",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:40:13Z",
    "updated_at": "2021-03-14T11:40:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +5, -0\r\n_Автор идеи:_ **gbalog**\r\n\r\nПеренос boost::hash_range и boost::hash_combine в стандартную библиотеку и добавление такой функции как std::hash_bytes.\r\n\r\nБыло бы неплохо, если бы была возможность хешировать последовательности байтов стандартными путями.\r\n\r\nСейчас для этого можно использовать `std::hash<std::string_view>()(std::string_view{ptr, len});,` что выглядит больше как хак.\r\n\r\nгораздо удобнее было бы иметь что-то такое: `std::hash_bytes(const std::byte * ptr, std::size_t len, std::size_t seed);`.\r\n\r\nНу а boost::hash_range и boost::hash_combine просто за компанию, т.к. это достаточно полезные функции, когда надо реализовать хеш для своих типов.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/76/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/76/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/75",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/75/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/75/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/75/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/75",
    "id": 831134274,
    "node_id": "MDU6SXNzdWU4MzExMzQyNzQ=",
    "number": 75,
    "title": "Список возможных значений для аргумента шаблона",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:36:20Z",
    "updated_at": "2021-03-14T12:31:13Z",
    "closed_at": "2021-03-14T12:31:13Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Aracks**\r\n\r\nДобавить в шаблоны возможность перечислять список возможных значений аргумента шаблона. То есть никакими другими значениями, кроме указанных, нельзя будет специализировать данный шаблон.\r\n\r\nСуть проблемы:\r\n\r\nПо очивидным причинам шаблоны всегда приходится реализовывать в файле заголовочника, что значительно замедляет компиляцию, в случае, если таких шаблонов становится много. При этом, довольно часто возникают ситуации, когда шаблон делается для некоторого конечного набора аргументов и для аргументов не из списка допустимых вряд-ли будет использоваться. Например, класс строки:\r\n ```cpp\r\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\r\nclass basic_string { /*...*/ };\r\n ```\r\nСоответственно, если я захочу написать некоторую функцию, работающую со строками в различных кодировках, то у меня есть всего два варианта действий:\r\n\r\n1) Написать шаблон функции, но тогда он будет полностью в заголовочнике.\r\n ```cpp\r\ntemplate<typename TChar>\r\nvoid my_func(const std::basic_string<TChar>& cr_value) { /*...*/ }\r\n ```\r\n2) Сделать несколько вариантов с разными типами строк, но тогда у мення будет куча копипаста.\r\n ```cpp\r\nvoid my_func(const std::string& cr_value);\r\n\r\nvoid my_func(const std::wstring& cr_value);\r\n\r\nvoid my_func(const std::u8string& cr_value);\r\n\r\nvoid my_func(const std::u16string& cr_value);\r\n\r\nvoid my_func(const std::u32string& cr_value);\r\n\r\n/*И для каждой из них написать реализацию, в точности повторяющую остальные.*/\r\n ```\r\nА вот если бы существовал способ ограничить набор возможных аргументов шаблона, то можно было бы перенести реализацию в *.cpp файл, а компилятор просто сгенерировал бы для неё все 5 специализаций разом. Это могло бы выглядеть как-то так:\r\n\r\n1) В первом варианте создаётся шаблон, который в принципе нельзя специализировать ничем, кроме заданного набора типов.\r\n\r\n\r\n  ____Заголовочник____\r\n   ```cpp\r\n  template<typename TChar = (char, wchar_t, char8_t, char16_t, char32_t)>\r\n  void my_func(const std::basic_string<TChar>& cr_value);\r\n   ```\r\n  ______CPP-файл______\r\n   ```cpp\r\n  template<typename TChar>\r\n  void my_func(const std::basic_string<TChar>& cr_value) { /*...*/ }\r\n   ```\r\n2) Во втором варианте создаётся шаблон, который можно специализировать разными типами, но вариант по умолчанию задан только для ограниченного набора типов.\r\n\r\n\r\n  ____Заголовочник____\r\n   ```cpp\r\n  template<typename TChar>\r\n  void my_func(const std::basic_string<TChar>& cr_value);\r\n   ```\r\n  ______CPP-файл______\r\n  ```cpp\r\n  template<typename TChar = (char, wchar_t, char8_t, char16_t, char32_t)>\r\n  void my_func<TChar>(const std::basic_string<TChar>& cr_value) { /*...*/ }\r\n   ```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/75/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/75/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/74",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/74/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/74/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/74/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/74",
    "id": 831133881,
    "node_id": "MDU6SXNzdWU4MzExMzM4ODE=",
    "number": 74,
    "title": "Добавить операция конкатенация std::string и std::string_view (operator +)",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-14T11:34:13Z",
    "updated_at": "2021-06-12T14:37:11Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +18, -3\r\n_Автор идеи:_ **khnormuradov**\r\n\r\nНе комплируется конкатенация string_view и std::string: string_view{} + string{} --> ERROR\r\n\r\n```cpp\r\n#include <string>\r\n#include <cstdio>\r\n \r\n\r\nint main()\r\n{\r\n   std::string s = \"hello \";\r\n   std::string_view v = \"world\";\r\n   std::string result = v+s; // ERROR: not found operator + overload\r\n}\r\n```\r\nПоэтому предлагаю добавить два оверлоад\r\n\r\n```cpp\r\nstring operator + (const string_view sv, const string& s)\r\n{\r\n   string result;\r\n   result.reserve(sv.size() + s.size());\r\n   result.append(sv);\r\n   result.append(s);\r\n   return result;\r\n}\r\n\r\nstring operator + (const string& s, const string_view sv )\r\n{\r\n    string result;\r\n    result.reserve(s.size() + sv.size());\r\n    result.append(s);\r\n    result.append(sv);\r\n    return result;\r\n}\r\n\r\n// и для  string && s    случай ещё две оверлоады.   \r\n// Это только схема, в самом деле надо делать через шаблон  \r\n// template <typaname CharT, typename Traits, typename Allocator> basic_string,\r\n// Но без них код выглядить более читабельно.\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/74/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/74/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/73",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/73/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/73/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/73/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/73",
    "id": 831133867,
    "node_id": "MDU6SXNzdWU4MzExMzM4Njc=",
    "number": 73,
    "title": "ConcurrentHashMap для C++",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:34:09Z",
    "updated_at": "2021-03-14T11:37:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +13, -0\r\n_Aвтор идеи:_ **f03n1x** @BlazingPhoenix\r\n\r\nВ стандартной библиотеке есть достаточно много всяких инструментов для написания многопоточных приложений, но большинство из них достаточно низкоуровневые и требуют достаточно высокого уровня понимания логики работы многопточных систем. Практика многопоточного программирования показывает, что большинство возникающих проблем сводится к относительно небольшому набору задач, которые достаточно давно и качественно решены. Я предлагаю добавить в стандарт реализацию горизонтально масштабируемой хеш таблицы, способной эффективно работать под высокой нагрузкой от большого количества потоков.\r\n\r\nПонятно, что можно взять обычную хеш таблицу и прикрыть ее от race condition при помощи mutex'a, но это приведет к тому, что у нас не будет возможности параллельно обращаться к данным внутри хеш таблицы. Более подробно про это можно почитать тут.\r\n\r\nЯ написал STL совместимую реализацию и разместил ее на github.\r\n\r\nДанная имплементация дублирует интерфейс стандартного типа unordered_map и позволяет писать многопоточный код так же легко и удобно, как если бы он таким не был.\r\n```cpp\r\n#include \"concurrent_hash_map.hpp\"\r\n#include <string>\r\n\r\nconcurrent_unordered_map<std::string, int> m;\r\nm.insert(std::make_pair(\"abc\", 123));\r\nassert(m[\"abc\"] == 123);\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/73/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/73/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/72",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/72/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/72/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/72/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/72",
    "id": 831132440,
    "node_id": "MDU6SXNzdWU4MzExMzI0NDA=",
    "number": 72,
    "title": "Добавить синтаксический сахар: тернарный оператор сравнения",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:26:07Z",
    "updated_at": "2021-03-14T11:27:40Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -10\r\n_Автор идеи:_ **Falen**\r\n\r\nЧто бы не плодить длинное условие с повторением одной и той же переменной для проверки вхождения в диапазон.\r\n\r\nПример:\r\n\r\nвместо \r\n```cpp\r\nif (0 < i && i < 100)\r\n```\r\nписать\r\n```cpp\r\nif (0 < i < 100)\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/72/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/72/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/71",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/71/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/71/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/71/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/71",
    "id": 831132265,
    "node_id": "MDU6SXNzdWU4MzExMzIyNjU=",
    "number": 71,
    "title": "std::transform, возвращающий новый диапазон",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-14T11:25:08Z",
    "updated_at": "2022-02-19T10:50:14Z",
    "closed_at": "2022-02-19T10:50:14Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +0, -6\r\n_Aвтор идеи:_ **Алексей Горностаев**\r\n\r\nБыло бы удобно иметь аналог метода map в Python/JavaScript, принимающего на вход массив данных, каким-то образом его преобразующим и возвращающим новый преобразованный массив\r\n\r\nНа текущий момент процесс преобразования данных выглядит так:\r\n```cpp\r\n  std::vector<int> foo  = {1,2,3};\r\n  std::vector<int> bar;\r\n\r\n  bar.resize(foo.size());\r\n\r\n  std::transform (foo.begin(), foo.end(), bar.begin(), op_increase);\r\n```\r\nХотелось бы иметь такой вариант:\r\n```cpp\r\n  std::vector<int> foo = {1,2,3};  \r\n  std::vector<int> bar = std::transform (foo.begin(), foo.end(), op_increase);\r\n```\r\nЭто позволит использовать std::transfrom в качестве аргумента функции, избавит от лишнего кода и позволит немного повысить производительность за счет передачи rvalue непосредственно в функцию без предварительного создания промежуточного объекта",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/71/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/71/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/70",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/70/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/70/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/70/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/70",
    "id": 831131751,
    "node_id": "MDU6SXNzdWU4MzExMzE3NTE=",
    "number": 70,
    "title": "Добавить класс для работы с энумероваными флагами",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:22:12Z",
    "updated_at": "2021-03-14T11:23:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +7, -2\r\n_Aвтор идеи:_ **Иван Комиссаров**\r\n\r\nСейчас, приходится использовать enum вместо enum class для битовых операций с флагами.\r\nТакой подход плох тем, что enum позволяет делать or/and (а также +/-) для произвольных значений, не входящих в энум\r\n\r\nЧто-типа такого:\r\n```cpp\r\nenum class Flag {\r\n     NoFlags = 0x0,\r\n     SuperFlag = 0x1,\r\n     MegaFlag = 0x2,\r\n     UltraFlag = 0x4,\r\n     Mask = 0x7\r\n};\r\n\r\nvoid f(const std::flags<Flag> &flag)\r\n{\r\n    if (flags & Flag::SuperFlag)\r\n         printf(\"Has SuperFlag\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    std::flags<Flag> flags(Flag::MegaFlag);\r\n    flags |= Flag::SuperFlag;\r\n\r\n    f(flags); // ok\r\n    f(Flag::MegaFlag | Flag::SuperFlag); // should be ok too\r\n    f(10); // error\r\n    f(SomeOtherEnum::SomeOtherFlag); // error\r\n\r\n    return 0;\r\n}\r\n```\r\nПример такого класса есть в Qt: http://doc.qt.io/qt-5/qflags.html\r\n\r\nПравда, в данный момент непонятно, как реализовать конструирование флагов от битового выражения с энумами.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/70/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/70/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/69",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/69/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/69/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/69/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/69",
    "id": 831130879,
    "node_id": "MDU6SXNzdWU4MzExMzA4Nzk=",
    "number": 69,
    "title": "Запрос запаса места в unordered контейнерах перед переаллокацией",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:17:39Z",
    "updated_at": "2021-03-14T11:20:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +4, -0\r\n_Aвтор идеи:_ **alexander.y.k**\r\n\r\nВ высококонкурентном коде порой требуется знать займет ли вставка следующего элемента в unordered контейнер около-константное время или линейное (а то и квадратичное) время. Стандарт описывает, что unordered контейнеры увеличивают число bucket'ов когда нужно сохранить load_factor() ниже чем max_load_factor(). Было бы удобно получить целочисленный ответ на этот вопрос без float армифметики.\r\n\r\nСейчас для определения такой ситуации либо нужно делать сравнение целого числа с float:\r\n```cpp\r\nif( unord.size() + new_items_count >= unord.max_load_factor() * unord.bucket_count() ) {\r\n    // slow insertion\r\n} \r\nelse {\r\n    // fast insertion \r\n}\r\n```\r\nА так же здесь для меня до сих пор не очевидно, что нужно использовать знак сравнения \">=\" (в gcc реализации в этом примере корректен именно он), по тому, что пересказ стандарта своими словами легко может сделать сравнение строгим. Так например cppreference.com, наводит именно на эти мысли:\r\n\r\n> The container automatically increases the number of buckets if the load factor exceeds this [max_load_factor()] threshold.\r\n\r\nТак же можно добиться результата эмулируя происходящее внутри контейнера, что должно быть снова затрагивает float'ы, и вообще говоря implementation specific, и так же не очевидна корректность происходящего для всех возможных комбинаций размера коллекции, количества вставляемых элементов и актуальных значений max_load_factor() и bucket_count().\r\n\r\nПомимо этого, сама формулировка из стандарта: \"The container automatically increases the number of buckets as necessary to keep the load factor below this [max_load_factor()] number\", — не ограничивает реализации делать переаллокации в \"удобное\" для них время.\r\n\r\nДалее, учитывая доминирующее положении реализации float чисел по стандарту IEEE 754, мы получаем, что если число элементов вышло за пределы 2^24 (=16'777'216), то требуется точная эмуляция поведения реализации для недежных выводов.\r\n\r\nЯ могу ошибаться, но кажется есть еще один нюанс того как x86 процессоры производят floating арифметику — они ведут флаг округления говорящий в какую сторону был округлен резултат последней операции, и в следующий раз применяют округление в другую сторону, чтобы накопление ошибок округления более-менее нивелировали друг друга в последовательных вычислениях. Если такие механизмы имеются на платформе, то собственноручно написанная техника проверки запаса может дать иной результат относительно того какой получила реализация в текущий момент.\r\n\r\nТаким образом хотелось бы иметь гарантированно работающий механизм получения запаса на количество вставляемых элементов которое не преведет к переаллокации, что-то вроде такого:\r\n```cpp\r\nif( unord.size() + new_items_count > unord.capacity() ) {\r\n    // slow insert\r\n}\r\nelse {\r\n    // fast insert\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/69/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/69/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/68",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/68/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/68/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/68/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/68",
    "id": 831130059,
    "node_id": "MDU6SXNzdWU4MzExMzAwNTk=",
    "number": 68,
    "title": "Библиотеки наше все",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:13:22Z",
    "updated_at": "2021-04-06T19:09:14Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +31, -5\r\n_Aвтор идеи:_ **mabrarov**\r\n\r\nНе совсем идея, конечно...\r\n\r\nНе трогайте и без того сложный язык (синтаксис). Дайте копиляторам и программистам догнать и полностью освоить то, что уже создано.\r\n\r\nНе раздувайте стандартную библиотеку - это не нужно и идет вразрез с философией C++. Раздутая стандратная библиотека сужает область примнения (вспомните JavaSE и JavaME - не повторяйте то, что уже плохо зарекомендовало себя).\r\n\r\nПросто дайте нам модули (и все остальное, что поможет в создании и распространении собранных библиотек). Помогите со становлением систем сборки и управления пакетами наподобие Maven (они не должны входить в стандарт, но желательно как-то поддержать создание стандартов de-facto). Я должен иметь возможность быстро подключить собранные (как мне нужно - static / shared и т.п.) библиотеки. Система управления зависимостями (наподобие Maven) должна уметь выбрать правильную версию (с учетом транзитивных зависимостей), найти нужные бинари в сети, скачать и подключить их к проекту.\r\n\r\nЯ пишу на C++ и моя головная боль не std::string, не поддерживающий итерацию по UTF-8 codepoints (стандарт Unicode может меняться с годами - спросите у Java), а невозмоность подключить ICU без вечера, проведенного в попытках собрать static ICU + static C/C++ runtime под Windows. Удобная работа с (уже собранными - pre-built) бибиотеками решит вопрос недостаточной функциональности стандартной библиотеки и позволит быстро набирать в проект только то, что нужно, оставляя за бортом то, что недоступно для конкретной целевой платформы (IoT, например).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/68/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/68/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/67",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/67/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/67/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/67/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/67",
    "id": 831129486,
    "node_id": "MDU6SXNzdWU4MzExMjk0ODY=",
    "number": 67,
    "title": "Работа со стандартными форматами данных",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:10:25Z",
    "updated_at": "2021-03-14T11:11:49Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +10, -8\r\n_Aвтор идеи:_ **vovacpp**\r\n\r\nКогда же стандартизируют работу с стандартыми форматами\r\n\r\nработа со строками это хорошо но нужна работа с\r\n\r\nархивами, звуком, изображениями, видео и базами данных\r\n\r\nПростые повседневные задачи\r\n\r\nнарисовать график, распечатать в pdf, загрузить png, прочитать упакованный поток, прочитарь конфиг, упаковать звук в mp3, выбрать записи базы\r\n\r\nФорматы данных которые девакто уже стандарты.\r\n\r\nЭто ускорит быстрое прототипирование. Что будет способствовать росту популярности языка.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/67/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/67/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/66",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/66/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/66/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/66/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/66",
    "id": 831128126,
    "node_id": "MDU6SXNzdWU4MzExMjgxMjY=",
    "number": 66,
    "title": "Добавить процентный литерал для дробных чисел",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T11:02:41Z",
    "updated_at": "2021-03-14T11:06:12Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -8\r\n_Автор идеи:_ **demax**\r\n\r\nДля улучшения читабельности и понимания кода при расчёте процента от числа.\r\n\r\nПример:\r\n\r\nДо:\r\n```cpp\r\nauto position = width * 0.33333; // не так точно\r\n\r\nauto position = width * (30. / 100.); // слишком запутанно и длинно\r\n```\r\n \r\n\r\nПосле:\r\n```cpp\r\nauto position = width * 33.%; // double\r\n\r\nauto position = width * 33.%f; // float\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/66/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/66/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/65",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/65/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/65/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/65/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/65",
    "id": 831123721,
    "node_id": "MDU6SXNzdWU4MzExMjM3MjE=",
    "number": 65,
    "title": "Нормальный API для строк",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-14T10:38:08Z",
    "updated_at": "2023-11-12T11:00:23Z",
    "closed_at": "2023-11-12T11:00:09Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +18, -3\r\n_Aвтор идеи:_ **mezastel**\r\n\r\nДопустим вы хотите ввести строку в нижний реестр и побить на токены.\r\n\r\nРаботать это должно вот так\r\n```cpp\r\nstring s;\r\nstring lower = s.to_lower_copy(); // in std::string\r\nvector<string> parts = s.split(' ');\r\n```\r\nВ плане набора API можно и нужно брать C# или Java. ",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/65/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/65/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/64",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/64/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/64/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/64/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/64",
    "id": 831120849,
    "node_id": "MDU6SXNzdWU4MzExMjA4NDk=",
    "number": 64,
    "title": "В плюс к расширению синтаксиса switch+for/while",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T10:21:32Z",
    "updated_at": "2021-03-14T10:22:31Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Виталий Protasov**\r\n\r\nЧасто приходится писать циклы с вложенными переключателями кейсов состояний.\r\n\r\nПример какая нить игровая логика или игровой ии (множество состояний) имеющих неочевидные связи, которые легко описывать такими вот автоматами состояний, иногда связи запутанные и надо прыгать goto с кучей меток, а можно что-то вроде введения ключевых слов помимпо break и continue которые используется switchem для backward compatibility можно добавить нового сахорка:\r\n\r\n \r\n\r\n1 слова break и continue перестают действовать для внешнего for/while с вложеным свитчем, можно добавить: skip/end,\r\n\r\nВызывая при каком-то условие в кейсе, skip будет аналогом вызова continue для внешнего for/while прерывающий возможно проваливающийся код кейса switch, и слово end (тоже что поставить метку за циклом) и позвать при каком-то условии или в каком-то кейсе, аналог break для for/while если надо в кейсе switch'а сломать внешний цикл либо скипнуть шаг без применения меткок или флагов. для самих циклов кстати словом skip (uinsigned int) можно было бы пропускать итерации где итераторы или инкрементирующиеся переменные бы получали смещение пропущенных шагов инстантно если цифра, либо с симуляцией блока видимости до вызова skip пошагово ()\r\n```cpp\r\nfor ( auto i(0); i < 10; i++ ) {\r\n ...\r\n   if( some ) // use just skip 4; for instant or skip (4) for simul steps run until skip call\r\n      i += 4;\r\n\r\n}\r\n```\r\n2 слово jump (case_no) позволяет вернуться из кейса уровнем больше в меньший (назад) или с пропуском (вперед)\r\n\r\n3 слово move убрало бы без флагов/меток/изощрений слова break на пути кейсов от->до, сделав кейс проваливающимся например из 1 ого вызов move 4 прошло бы последовательно по 2,3,4 убрав их внешний break; возможно сделать и обратный ход 4->3->2 сложно придумать зачем, словом back( case_no ) но явно проще чем симулировать такое поведение метками и goto.\r\n\r\n4 слово repeat позволяет зайти в блок видимости до кейсов если там какие-то флаги получаемые вызовами или кто его знает что там может быть \r\n```cpp\r\nswitch ( ... ) { \r\n  /* block */  \r\n   case x: { if (some) repeat; ...  }\r\n   ...\r\n}\r\n```\r\n5 слово up; позволяет на том-же шаге цикла вернуться в блок видимости (начало исполниения цикла) т.е. до самого swith, даже если их пяток лежит там, опять таки перевычислить какие-то флаги другие свитчи, ещё что-то прим. (саму стейт переменную)\r\n```cpp\r\nfor ( ... ) { /* block */ switch(...) {} }\r\n ```\r\n\r\nПока расписал идею подумал (просто нет проверить под рукой)\r\n\r\nможет я придумал какой-то байан и управлять внешними циклами из свитчей можно как-то просто и лаконично.\r\n\r\nПомнится в 2000 видел где-то в циклах/циклов сишного кода ядра линукса некие странные обозначения continue (3); break (2); не мог понять что значило, вроде бы индекс обозначал на каком уровне вложенности надо применять ключевик.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/64/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/64/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/63",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/63/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/63/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/63/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/63",
    "id": 831120265,
    "node_id": "MDU6SXNzdWU4MzExMjAyNjU=",
    "number": 63,
    "title": "Шаблонный оператор for для перечисления типов",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T10:17:52Z",
    "updated_at": "2021-03-14T10:19:56Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -1\r\n_Автор идеи:_ **Николай Бахтин**\r\n\r\nХотелось бы иметь возможность перечислять в цикле типы, подобно тому как можно обрабатывать в существующем цикле значения.\r\n\r\n \r\n\r\nПредположим у нас есть «нечто» – контейнер типов в виде списка.\r\n```cpp\r\ntypelist MyTypeList\r\n{\r\n  int,\r\n  double,\r\n  std::vector<int>\r\n};\r\n```\r\nНапишем код перечисления типов в списке.\r\n```cpp\r\ntemplate<typename T>\r\nfor( T : MyTypeList)\r\n{\r\n  std::cout << typeid(T).name() << \" - size=\" << sizeof(T) << std::endl;\r\n}\r\n```\r\nПо сути этот цикл является шаблоном, который в коде разворачивается в последовательность блоков для каждого типа:\r\n```cpp\r\n//int\r\n{\r\n  std::cout << typeid(int).name() << \" - size=\" << sizeof(int) << std::endl;\r\n}\r\n//double\r\n{\r\n  std::cout << typeid(double).name() << \" - size=\" << sizeof(double) << std::endl;\r\n}\r\n//std::vector<int>\r\n{\r\n  std::cout << typeid(std::vector<int>).name() << \" - size=\" << sizeof(std::vector<int>) << std::endl;\r\n}\r\n```\r\n \r\n\r\nОбобщенно, цикл\r\n```cpp\r\ntemplate<T>\r\nfor ( T : type_range )\r\n{\r\n  loop_statement\r\n}\r\n```\r\nразвертывается в:\r\n```cpp\r\nloop_statement<T1>;\r\nloop_statement<T2>;\r\nloop_statement<T3>;\r\n…\r\nloop_statement<Tn>;\r\n```\r\nгде:\r\n\r\nT1,T2,T3...Tn перечень типов, входящих в type_range\r\n\r\n \r\n\r\nВ качестве type_range можно было взять имя структуры или класса, а в качестве перечисляемых сущностей использовать поля. Но поле помимо типа имеет ещё и имя. Получается, это будет не список типов, а некий список пар «имя поля»-«тип поля».\r\n\r\n \r\n\r\nТогда пускай тип T в цикле описывает пару «имя/тип»\r\n\r\n \r\n```cpp\r\nstruct MyStruct\r\n{\r\n  int a;\r\n  double b;\r\n  std::string c;\r\n};\r\n\r\ntemplate<typename T>\r\nfor( T : MyStruct)\r\n{\r\n  std::cout << \" type=\" << typeid(T::field_type).name();\r\n  std::cout << \" name=\" << T::field_name << std::endl;\r\n}\r\n```\r\nТакой цикл должен вывести что-то вроде:\r\n```cpp\r\ntype=int name=a\r\ntype=double name=b\r\ntype=std::string name=c\r\n```\r\n \r\n\r\nАналогично для классов. Думаю, таким образом можно реализовать некоторое подобие функционала System.Reflection из С# и других языков.\r\n\r\n \r\n\r\nЯ не силен в фунциональных языках, но мне кажется, что с помощью этой штуки можно реализовать некоторый функционал монад, который нельзя сделать текущими средствами языка с++. (А может я просто не понимаю, что такое монады. :)\r\n\r\n \r\n\r\nТут я привел скорее общую идею, чем конкретную реализацию. Что думаете об этой идее?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/63/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/63/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/62",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/62/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/62/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/62/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/62",
    "id": 831119842,
    "node_id": "MDU6SXNzdWU4MzExMTk4NDI=",
    "number": 62,
    "title": "for для перечислений",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T10:15:26Z",
    "updated_at": "2021-03-14T10:16:38Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +12, -2\r\n_Автор идеи:_ **Georgy Firsov**\r\n\r\nХотелось бы иметь способ пройтись по всем возможным значениям перечисления.\r\nЭти значения всегда известны на этапе компиляции, поэтому данная задача не кажется слишком сложной в том числе и для расширения её области использования на compile-time.\r\n\r\nКак можно сейчас:\r\n```cpp\r\nenum class EMyEnum {\r\n  Min,\r\n  First = Min,\r\n  Second,\r\n  ...\r\n  Last,\r\n  Max\r\n};\r\n\r\n...\r\n\r\nfor (std::underlying_type_t<EMyEnum> eMyEnum = EMyEnum::Min; eMyEnum < EMyEnum::Max; eMyEnum++) {\r\n   ...\r\n}\r\n```\r\nНо это с новым кодом, а есть ещё и старый, который менять не всегда можно, что делает такой трюк невозможным. Собственно, предложение состоит в следующем: хотелось бы делать одним из следующих способов:\r\n```cpp\r\nenum class EMyEnum {\r\n   First,\r\n   Second,\r\n   ...\r\n   Last\r\n};\r\n\r\n...\r\n\r\n// (1)\r\nfor (auto eMyEnum : EMyEnum) { ... }\r\n\r\n// (2)\r\nfor (auto eMyEnum = begin(EMyEnum); eMyEnum != end(EMyEnum); eMyEnum++) { ... }\r\n```\r\nДумаю, что можно и иные синтаксические кострукции придумать, но пока смысла в этом не вижу. Первый же вариант кажется более лаконичным.\r\n\r\nТут есть скользкий вопрос - перечисления вот таких типов:\r\n```cpp\r\n// (1)\r\nenum class EMyBadEnum1 {\r\n  First = 0,\r\n  Second = 2,\r\n  Third = 6,\r\n  Last = 7,\r\n  Invalid = -2\r\n};\r\n\r\n// (2)\r\nenum class EMyBadEnum2 {\r\n  First,\r\n  Second,\r\n  Third = First\r\n  Last\r\n};\r\n```\r\nВ обоих случаях можно разрешить данные неприятности проходом от минимального до максимального элемента (не обязательно по порядку их определения). Шаг же инкремента тут не обязательно будет равным единице, что обеспечить легко, так как на этапе компиляции значения перечисления известны.\r\n\r\nПовторяющиеся значения перечисления считаются одинаковыми в данном контексте (т.е. в примере с EMyBadEnum2 будет 3 итерации цикла).\r\n\r\nДля чего оно нужно:\r\n\r\nЭто поможет писать менее чувствительный к изменениям код, так как, например, при написании DLL разумно иногда кодировать различные опции в перечислении, но иногда подобный код во имя большей простоты требует написания \"цикла\" по перечислению, что со старым кодом (где нежелательно вводить служебные значения Min и Max) иногда превращается в набор if-else или switch, хотя можно было бы действительно обойтись циклом по данному перечислению.\r\nИ вот это та ситуация, модификация кода в которой (добавление новой опции) могла бы быть облегчена подобным циклом: достаточно добавить просто значение в перечисление, без необходимости модификации существующего кода. Это один из use-кейсов.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/62/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/62/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/61",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/61/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/61/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/61/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/61",
    "id": 831119318,
    "node_id": "MDU6SXNzdWU4MzExMTkzMTg=",
    "number": 61,
    "title": "Метод std::stack::clear()",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-14T10:12:19Z",
    "updated_at": "2021-03-31T08:09:14Z",
    "closed_at": "2021-03-31T08:09:14Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -1\r\n_Автор идеи:_ **Евгений Красников**\r\n\r\nПредлагаю добавить метод `clear()` для очистки \"стека\".\r\n\r\nЭто будет куда логичнее, чем писать `stack_var = {}.`",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/61/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/61/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/60",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/60/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/60/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/60/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/60",
    "id": 831118573,
    "node_id": "MDU6SXNzdWU4MzExMTg1NzM=",
    "number": 60,
    "title": "lexical_cast",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-14T10:07:52Z",
    "updated_at": "2021-03-14T10:31:55Z",
    "closed_at": "2021-03-14T10:31:33Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -6\r\n_Автор идеи:_ **Damond Loks**",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/60/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/60/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/59",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/59/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/59/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/59/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/59",
    "id": 831118123,
    "node_id": "MDU6SXNzdWU4MzExMTgxMjM=",
    "number": 59,
    "title": "Перенести в стандартную библиотеку boost::lexical_cast",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T10:05:03Z",
    "updated_at": "2021-03-26T17:24:38Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -4\r\n_Автор идеи:_ **Игорь**\r\n\r\nБыло бы неплохо, если такая крайне часто используемая библиотека как boost::lexical_cast мигрировала бы в стандартную библиотеку.\r\n\r\nЧасто используемая и полезная библиотека обязана лежать в пространстве std чтобы лишний раз не грузить по этому поводу бусты.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/59/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/59/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/58",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/58/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/58/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/58/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/58",
    "id": 831116789,
    "node_id": "MDU6SXNzdWU4MzExMTY3ODk=",
    "number": 58,
    "title": "Стандартизовать properties",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T09:57:19Z",
    "updated_at": "2021-03-14T10:02:35Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +9, -20\r\n_Aвтор идеи:_ **mezastel**\r\n\r\nСейчас уже почти на всех компиляторах можно использовать properties, например\r\n```cpp\r\nstruct foo\r\n{\r\n  int n;\r\n  int get_n() const { return n; }\r\n  void set_n(int value) { n = value; }\r\n  __declspec(property(get=get_n,put=set_n)) int n;\r\n}\r\n\r\n// usage\r\nfoo f{};\r\nf.n = 123; // calls f.set_n(123);\r\n```\r\nПредлагаю это как-то оформить в языковую фичу, например чтобы можно было просто писать property int n; а member functions искать подходом convention over configuration (т.е. дефолтные имена).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/58/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/58/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/57",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/57/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/57/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/57/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/57",
    "id": 831116347,
    "node_id": "MDU6SXNzdWU4MzExMTYzNDc=",
    "number": 57,
    "title": "Перегрузить std::begin()/std::end() для std::basic_istream",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-14T09:54:46Z",
    "updated_at": "2021-03-14T09:55:50Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Идея из обсуждения_ https://github.com/cpp-ru/ideas/issues/56\r\n_Aвтор идеи:_ **Polukarov Mikhail**\r\n\r\nСейчас чтобы прочитать что-либо из потока данных необходимо создавать пару итераторов std::istream_iterator<...>. Например:\r\n```cpp\r\nusing namespace std;\r\n\r\nistringstream str(\"0.1 0.2 0.3 0.4\");\r\npartial_sum(istream_iterator<double>(str),\r\nistream_iterator<double>(),\r\nostream_iterator<double>(std::cout, \" \"));\r\n\r\nistringstream buf(\"1 2 3 4 5 6 7\");\r\ncopy(istream_iterator<int>(str),\r\nistream_iterator<int>(),\r\nostream_iterator<int>(cout, \" \"));\r\n```\r\nБыло бы удобно перегрузить `std::begin()`/`std::end()` принимающие `std::basic_istream<...>`. В таком случае можно будет писать такой код:\r\n```cpp\r\nistringstream str(\"0.1 0.2 0.3 0.4\");\r\n// using begin()/end()\r\npartial_sum(begin<double>(str), end<double>(str), ostream_iterator<double>(cout, \" \"));\r\n```\r\nНу и в идеале, использовать ranges и производящую функцию типа make_range(), например так:\r\n```cpp\r\nistringstream buf(\"1 2 3 4 5 6 7\");\r\n// using make_range()\r\ncopy(make_range<int>(str), ostream_iterator<int>(cout, \" \"));\r\n```\r\n\r\nВсе выше описанные функции могут быть реализованы примерно так:\r\n```cpp\r\ntemplate<typename T, typename Elem, typename Traits>\r\nistream_iterator<T, Elem, Traits>\r\nbegin(basic_istream<Elem, Traits>& stream) {\r\n    return istream_iterator<T, Elem, Traits>(stream);\r\n}\r\n\r\ntemplate<typename T, typename Elem, typename Traits>\r\nistream_iterator<T, Elem, Traits>\r\nend(basic_istream<Elem, Traits>&) {\r\n    return istream_iterator<T, Elem, Traits>();\r\n}\r\n\r\ntemplate<typename T, typename Elem, typename Traits>\r\nrange< istream_iterator<T, Elem, Traits> >\r\nmake_range(basic_istream<Elem, Traits>& stream) {\r\n    return { istream_iterator<T, Elem, Traits>(stream), istream_iterator<T, Elem, Traits>() };\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/57/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/57/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/56",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/56/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/56/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/56/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/56",
    "id": 831100111,
    "node_id": "MDU6SXNzdWU4MzExMDAxMTE=",
    "number": 56,
    "title": "Перегрузка std::begin() и std::end() для std::pair",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-14T08:20:28Z",
    "updated_at": "2021-03-14T09:55:39Z",
    "closed_at": "2021-03-14T09:55:39Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +2, -3\r\n_Aвтор идеи:_ **Олег Ляттэ**\r\n\r\nСейчас в стандартной библиотеке есть алгоритмы и функции, которые возвращают диапазон значений в виде пары итераторов. Например алгоритм std::equal_range или одноимённые функции в std::multimap, std::unordered_map и др.\r\n\r\nЧасто бывает нужно сразу пробежаться по этому диапазону в цикле. Но чтобы это сделать, нужно сохранить полученный диапазон в локальную переменную (имя которой будет видно во всём скоупе, хотя было бы достаточно временной переменной), после чего итерироваться по старинке.\r\n\r\nЕсли же написать простые перегрузки вида\r\n```cpp\r\ntemplate<typename T>\r\nT std::begin(const std::pair<T, T>& p)\r\n{\r\n    return p.first;\r\n}\r\n\r\ntemplate<typename T>\r\nT std::end(const std::pair<T, T>& p)\r\n{\r\n    return p.second;\r\n}\r\n```\r\nто вместо\r\n```cpp\r\nstd::multimap<std::string, int> m = getMap();\r\nauto range = m.equal_range(\"hello\");\r\nfor(auto it = range.first; i != range.second; ++i)\r\n{\r\n    doSomething(it->second);\r\n}\r\n```\r\nможно написать\r\n```cpp\r\nstd::multimap<std::string, int> m = getMap();\r\nfor(const auto& v: m.equal_range(\"hello\"))\r\n{\r\n    doSomething(v.second);\r\n}\r\n```\r\nВозможно, перегрузки стоит ограничить (например, с помощью enable_if) только для типов, которые удовлетворяют требованиям к итераторам. Однако даже если этого не делать, то использование не итератора там, где ожидается итератор (в том же range for), всё равно приведёт к ошибке компилятора (причём, возможно, более информативной, чем с использованием enable_if в перегрузках begin и end).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/56/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/56/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/55",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/55/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/55/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/55/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/55",
    "id": 831099748,
    "node_id": "MDU6SXNzdWU4MzEwOTk3NDg=",
    "number": 55,
    "title": "while {} else {};",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2891567122,
        "node_id": "MDU6TGFiZWwyODkxNTY3MTIy",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/--",
        "name": "--",
        "color": "E25547",
        "default": false,
        "description": "Непопулярная идея (10 и более дизлайков)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-14T08:17:49Z",
    "updated_at": "2022-08-12T06:05:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +12, -10\r\n_Aвтор идеи:_ **Эдвард Давтян**\r\n\r\nЧасто нужно знать зашли ли мы хоть раз в цикл while. Для этого все заводят булеву переменную и проставляют её значение внутри цикла. Была бы очень удобно иметь синтаксический сахар c else-м для while-а (при этом тольк для while-а, для for-а, do/while-а нет смысла на мой взгляд).\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nint main() {\r\n  std::string s;\r\n  while (std::getline(std::cin, s)) {\r\n    std::cout << s << std::endl;\r\n  } else {\r\n    std::cout << \"Input is empty\" << std::endl;\r\n  }\r\n  return 0;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/55/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/55/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/54",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/54/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/54/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/54/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/54",
    "id": 830920114,
    "node_id": "MDU6SXNzdWU4MzA5MjAxMTQ=",
    "number": 54,
    "title": "Форматирование в static_assert",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5684210986,
        "node_id": "LA_kwDOFK7cns8AAAABUs4tKg",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++26",
        "name": "C++26",
        "color": "07CC78",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++26"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T15:14:27Z",
    "updated_at": "2023-11-12T10:52:00Z",
    "closed_at": "2023-11-12T10:51:49Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -2\r\n_Автор идеи:_ **yehorror**\r\n\r\nДобавить возможность выводить в static_assert не только строковое сообщение, но и какие-либо другие данные вместе с ним (известные на этапе компиляции): числа, bool, ну и т.д.\r\n\r\nКак один из вариантов - сделать что-то вроде std::format.\r\n```cpp\r\nstatic_assert(sizeof(parameter) == sizeof(something), \"Size of parameter must be {}\", sizeof(something));\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/54/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/54/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/53",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/53/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/53/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/53/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/53",
    "id": 830919620,
    "node_id": "MDU6SXNzdWU4MzA5MTk2MjA=",
    "number": 53,
    "title": "Расширение оператора switch",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T15:12:20Z",
    "updated_at": "2021-03-26T17:21:43Z",
    "closed_at": "2021-03-26T17:21:36Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +12, -2\r\n_Автор идеи:_ **Евгений Красников**\r\n\r\nПредлагаю расширение оператора switch, чтобы можно было перечислять несколько значений через запятую, использовать нецелочисленные значения, переменные, сравнения со значениями.\r\n\r\nКод:\r\n```cpp\r\nswitch (letter) {\r\n  case 'a': case 'e': case 'i': case 'o': case 'u':\r\n    ++vowels;\r\n}\r\n```\r\nбыло бы удобнее использовать так:\r\n```cpp\r\nswitch (letter) {\r\n  case 'a', 'e', 'i', 'o', 'u':\r\n    ++vowels;\r\n}\r\n```\r\nДругой пример. Почему бы не сделать возможность замены:\r\n```cpp\r\nif (str == \"hello\") { std::cout << \"Hi!\"; }\r\nelse if (str == \"bye\") { std::cout << \"See ya!\"; }\r\nelse { std::cout << \"Let's talk!\"; }\r\n```\r\nна:\r\n```cpp\r\nswitch (str) {\r\n  case \"hello\":\r\n    std::cout << \"Hi!\";\r\n    break;\r\n  case \"world\":\r\n    std::cout << \"See ya!\";\r\n    break;\r\n  default:\r\n    std::cout << \"Let's talk!\";\r\n}\r\n```\r\n \r\nНу и, наконец:\r\n```cpp\r\nswitch (value) {\r\n  case < 0:\r\n    // less than 0\r\n    break;\r\n  case >= 10:\r\n    // greater or equal to 0\r\n    break;\r\n  case x:\r\n    // equal to x\r\n    break;\r\n  case_all > y, < z:\r\n    // greater than y and less than z\r\n    break;\r\n  default:\r\n    // else branch\r\n}\r\n```\r\nВ последнем случае допустимы операторы сравнения ==, !=, >, <, >=, <=, следующие сразу за case или запятой. Значения проверяются последовательно, т.е. если удовлетворяется несколько условий, то прыжок идёт на метку, объявленную выше по коду.\r\n\r\nСинтаксис case_all, означающий соблюдение сразу всех условий, вероятно, не лучший, но смысл таков :)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/53/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/53/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/52",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/52/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/52/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/52/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/52",
    "id": 830901336,
    "node_id": "MDU6SXNzdWU4MzA5MDEzMzY=",
    "number": 52,
    "title": "Перегрузка функций по их возвращаемому значению",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:39:42Z",
    "updated_at": "2021-03-13T13:40:26Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -11\r\n_Автор идеи:_ **Иван Володин**\r\n\r\nНазначение основной функции, которая будет вызываться в случае неоднозначности\r\n\r\nСтандарт C++14 13.1/2:\r\n\"Function declarations that differ only in the return type cannot be overloaded\"\r\n[Источник (stackoverflow)](https://ru.stackoverflow.com/questions/490657/%D0%9F%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%BF%D0%BE-%D1%82%D0%B8%D0%BF%D1%83-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)\r\n\r\n\"Перегрузка функций со списками аргументов одного типа лишь на основании возвращаемого типа недопустима\"\r\n[Источник (docs.microsoft)](https://docs.microsoft.com/ru-ru/cpp/cpp/function-overloading?view=msvc-160&viewFallbackFrom=vs-2019#restrictions-on-overloading)\r\n\r\nСуть конфликта:\r\n```cpp\r\n#include <iostream>\r\n\r\nint getOne() //Error E0311\r\n{\r\n\treturn 1;\r\n}\r\n\r\nfloat getOne() //Error E0311\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint intOne = getOne();\r\n\tfloat floatOne = getOne();\r\n\r\n\tstd::cout << intOne << ' ' << floatOne; //Код не скомпилируется из-за ошибок, вывода не будет\r\n\r\n\treturn 0;\r\n}\r\n```\r\nИдея:\r\n\r\nВызывать функцию, итог которой ожидается в записи. Это выглядело бы так:\r\n```cpp\r\n#include <iostream>\r\n\r\nint getOne()\r\n{\r\n\treturn 1;\r\n}\r\n\r\nfloat getOne()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint intOne = getOne(); //Ожидается int, вызываем функцию int getOne()\r\n\tfloat floatOne = getOne(); //Ожидается double, вызываем функцию double getOne()\r\n\r\n\tstd::cout << intOne << ' ' << floatOne; //Должно вывести \"1 1.1\"\r\n\r\n\treturn 0;\r\n}\r\n```\r\nКонтр-аргумент:\r\n\r\nКак тогда программа должна вести себя, если в записи не ожидается типа? Например:\r\n```cpp\r\ngetOne();\r\nauto one = getOne();\r\nstd::cout << getOne();\r\n```\r\nВ подобных случаях, нужно обозначить основную функцию - ту из перегрузок, которая будет вызываться в случае неопределенности. \r\n\r\nПредлагаемые варианты обозначения основных функций:\r\n1) Использование оператора final при инициализации. Пример:\r\n```cpp\r\n#include <iostream>\r\n\r\nfinal int getOne()\r\n{\r\n\treturn 1;\r\n}\r\n\r\nfloat getOne()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tstd::cout << getOne(); //Должно вывести \"1\"\r\n\r\n\treturn 0;\r\n}\r\n```\r\n(В случае, если конкретно final использоваться не может, можно также использовать public или override, или же, ввести новый термин для этой цели, например original, universal или standart)\r\n\r\n2) Самая первая инициализированная - и есть основная. Примеры:\r\n```cpp\r\n#include <iostream>\r\n\r\nint getOne()\r\n{\r\n\treturn 1;\r\n}\r\n\r\nfloat getOne()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tstd::cout << getOne(); //Должно вывести \"1\"\r\n\r\n\treturn 0;\r\n}\r\n#include <iostream>\r\n\r\nfloat getOne()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\nint getOne()\r\n{\r\n\treturn 1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tstd::cout << getOne(); //Должно вывести \"1.1\"\r\n\r\n\treturn 0;\r\n}\r\n```\r\nРаспостраненные частичные или полные обходные решения проблемы в нынешнем C++:\r\n\r\n1) Указание возвращаемого значения внутри имени функции. Пример:\r\n```cpp\r\n#include <iostream>\r\n\r\nint getOneInt()\r\n{\r\n\treturn 1;\r\n}\r\n\r\nfloat getOneFloat()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint intOne = getOneInt();\r\n\tfloat floatOne= getOneFloat();\r\n\r\n\tstd::cout << intOne << ' ' << floatOne; //Должно вывести \"1 1.1\"\r\n\r\n\treturn 0;\r\n}\r\n```\r\n2) Использование template для явного указания ожидаемого типа. (Источник) Например:\r\n```cpp\r\n#include <iostream>\r\n\r\ntemplate<typename T> T getOne();\r\n\r\ntemplate<> int getOne()\r\n{\r\n\treturn 1;\r\n}\r\n\r\ntemplate<> float getOne()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint intOne = getOne<int>();\r\n\tfloat floatOne = getOne<float>();\r\n\r\n\tstd::cout << intOne << ' ' << floatOne; //Должно вывести \"1 1.1\"\r\n\r\n\treturn 0;\r\n}\r\n```\r\n3) Переименование функций-перегрузок, чтобы создать перегружаемый структуру-функтор с именем функции. (Источник) Например:\r\n```cpp\r\n#include <iostream>\r\n\r\ntemplate<typename T> T getOneFoo();\r\n\r\ntemplate<> int getOneFoo()\r\n{\r\n\treturn 1;\r\n}\r\n\r\ntemplate<> float getOneFoo()\r\n{\r\n\treturn 1.1;\r\n}\r\n\r\nstruct getOne //Структура-Функтор\r\n{\r\n\tgetOne() {}\r\n\r\n\ttemplate<typename T> operator T()\r\n\t{\r\n\t\treturn getOneFoo<T>();\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tint intOne = getOne();\r\n\tfloat floatOne = getOne();\r\n\r\n\tstd::cout << intOne << ' ' << floatOne; //Должно вывести \"1 1.1\"\r\n\r\n\treturn 0;\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/52/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/52/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/51",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/51/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/51/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/51/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/51",
    "id": 830900281,
    "node_id": "MDU6SXNzdWU4MzA5MDAyODE=",
    "number": 51,
    "title": "Работа с WildCard",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:33:57Z",
    "updated_at": "2021-03-13T14:21:08Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -3\r\n_Автор идеи:_ **zhekha** @zhekha\r\n\r\nРегулярные выражения добавили а про вайлдкарды забыли, хотя последние бывают нужны не реже, а то и чаще.  (Как пример https://github.com/zemasoft/wildcards)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/51/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/51/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/50",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/50/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/50/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/50/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/50",
    "id": 830899692,
    "node_id": "MDU6SXNzdWU4MzA4OTk2OTI=",
    "number": 50,
    "title": "Поддержка \"человеческой\" инициализации полей структуры, битовых полей и прочих именованных полей везде где возможно",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:31:00Z",
    "updated_at": "2021-03-13T14:12:20Z",
    "closed_at": "2021-03-13T14:12:20Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -5\r\n_Автор идеи:_ **HedgehogInTheCPP** @IRainman\r\n\r\nКомпилятору никто не мешает принять на вход инициализации поля структуры по имени (id) без явного написания кучи blow кода в виде трёх этажных шаблонов.\r\n\r\nПривожу пример кода, первый как хотелось бы писать. В целом мне очень хочется чтобы использовать сторонние генераторы кода было не нужно.\r\n\r\n```cpp\r\nstatic volatile uint16_t* const name = (volatile uint16_t*)(XXXXX);\r\n\r\nstruct ConfigDacLoop\r\n{\r\n   uint16_t unsign : 1, loop : 1;\r\n};\r\n\r\n\r\nConfigDacLoop get_config_dac_loop() { return static_cast<ConfigDacLoop>(*config_dac_loop); }\r\n\r\nvoid set_config_dac_loop(const ConfigDacLoop& p_config_dac_loop) { *config_dac_loop = p_config_dac_loop; }\r\n\r\n\r\nset_config_dac_loop(.unsign = 1, .loop = 0); // Not working.\r\n\r\nset_config_dac_loop({.unsign = 1, .loop = 0}); // Not working.\r\n\r\nset_config_dac_loop(ConfigDacLoop{.unsign = 1, .loop = 0}); // Not working.​\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/50/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/50/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/49",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/49/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/49/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/49/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/49",
    "id": 830898086,
    "node_id": "MDU6SXNzdWU4MzA4OTgwODY=",
    "number": 49,
    "title": "Модификация string.replace",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:22:04Z",
    "updated_at": "2021-03-13T14:21:19Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +18, -0\r\n_Автор идеи:_ **Иван Володин**\r\n\r\nМодификация string.replace для замены символов или строк на другие символы или строки\r\n\r\nВ .NET есть функция `String.Replace`, имеющая перегрузки `String.Replace(char oldValue, char newValue)` и `String.Replace(string oldValue, string newValue)` для замены в строке всех oldValue на newValue.\r\n\r\nВ C++ тоже есть похожая функция, `string.replace(size_t start, size_t count, const string &str)`, однако она позволяет только заменить count символов строки с позиции start из другой переданной строки str.\r\nЕсли есть необходимость замены во всей строке одного символа другим, или замены одной подстрокой другой, то придется использовать regex или писать самопальные функции.\r\n\r\nПочему бы не расширить `string.replace(size_t start, size_t count, const string &str)` до `string.replace(char oldValue, charnewValue)` и `string.replace(string oldValue, string newValue)`?",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/49/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/49/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/48",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/48/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/48/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/48/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/48",
    "id": 830897345,
    "node_id": "MDU6SXNzdWU4MzA4OTczNDU=",
    "number": 48,
    "title": "Aggregate initialization для классов с виртуальными методами",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-13T13:17:40Z",
    "updated_at": "2021-03-13T13:17:40Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -1\r\n_Автор идеи:_ **waka.packmaca**\r\n\r\nЕсли класс наследуется от класса с виртуальными методами, aggregate initialization для него запрещена. Не вижу ни одной причине из-за которой такое кощунство возможно возможно. Хотелось бы, чтобы это ограничение убрали.\r\n\r\nВ связи с имеющимся ограничением следующий код невалиден:\r\n```cpp\r\nstruct Serializer {\r\n  virtual ~Serializer() = default;\r\n  virtual void write(std::int64_t) = 0;\r\n};\r\n\r\nstruct Serializable {\r\n  virtual ~Serializable() = default;\r\n  virtual void serialize(Serializer &s) const = 0;\r\n};\r\n\r\nstruct Object : Serializable {\r\n  std::int64_t value;\r\n\r\n  void serialize(Serializer &s) const override {\r\n    s.write(value);\r\n  }\r\n};\r\n\r\n// ...\r\n\r\nObject {.value = 16};\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/48/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/48/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/47",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/47/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/47/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/47/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/47",
    "id": 830896713,
    "node_id": "MDU6SXNzdWU4MzA4OTY3MTM=",
    "number": 47,
    "title": "Функции преобразования строки в число должны поддерживать работу с итераторами",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      },
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T13:14:11Z",
    "updated_at": "2021-04-02T18:19:46Z",
    "closed_at": "2021-04-02T18:19:33Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **waka.packmaca**\r\n\r\nФункции std::stoi, std::stol, std::stoll и т.д. принимают std::string/std::wstring в качестве аргумента, что делает их \"бесполезными\" при работе с диапазонами.\r\n\r\nХотелось бы иметь возможность помимо строк скармливать им пару итераторов, чтобы сигнатура функции имела следующий вид, например:\r\n```cpp\r\ntemplate<typename Iterator>\r\nint stoi(Iterator first, Iterator last, int base = 10) {\r\n  // ...\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/47/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/47/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/46",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/46/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/46/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/46/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/46",
    "id": 830896075,
    "node_id": "MDU6SXNzdWU4MzA4OTYwNzU=",
    "number": 46,
    "title": "Добавить возможность установки имени потока для std::thread",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:10:56Z",
    "updated_at": "2021-03-13T15:02:18Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +9, -0\r\n_Автор идеи:_ **Arkady Shapkin**\r\n\r\nЭтот вызов внутри может вызывать указанные ниже функции:\r\nПод Windows SetThreadDescription https://docs.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription?redirectedfrom=MSDN\r\nПод Linux есть pthread_setname_np (https://linux.die.net/man/3/pthread_setname_np) (есть ограничение в 16 символов)\r\n\r\nВ других языках есть подобный функционал:\r\n\r\n* В Java https://stackoverflow.com/questions/11457690/how-to-set-name-to-the-thread\r\n\r\n* В C# https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.name?view=net-5.0",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/46/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/46/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/45",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/45/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/45/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/45/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/45",
    "id": 830895807,
    "node_id": "MDU6SXNzdWU4MzA4OTU4MDc=",
    "number": 45,
    "title": "Обертка над стандартными типами данных(char, int, double и т.д.)",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:09:34Z",
    "updated_at": "2021-03-13T15:02:28Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -5\r\n_Автор идеи:_ **Nikola_g**\r\n\r\nСуть проблемы заключается в следующим. В компании, в которой я работаю в основном решаются математические задачи и часто при их решении возникают непредвиденные ситуации. К ним относятся деления на ноль, результат вычисления равен inf или nan, бывает, что происходит переполнения. Так же по незнанию программисты берут на строгое равенство переменные с плавающий точкой. Для решении данной проблемы были написаны несколько классов (ссылка на репозитарий https://github.com/GhostPastR/TestMyLibs/tree/master/libs/system/NType). Возможно ли внести в стандартную библиотеку что-нибудь аналогичное. В C# и Java стандартные типы оформлены виде классов со своими методами.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/45/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/45/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/44",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/44/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/44/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/44/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/44",
    "id": 830895571,
    "node_id": "MDU6SXNzdWU4MzA4OTU1NzE=",
    "number": 44,
    "title": "Методы iterator_from",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:08:19Z",
    "updated_at": "2021-03-27T14:28:24Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **Antervis**\r\n\r\nИдея: добавить способ получения итераторов из ссылок/указателей на элементы контейнера, вида\r\n```cpp\r\ntemplate <container T>\r\nT::iterator iterator_from(T::value_type& val);\r\n\r\ntemplate <container T>\r\nT::const_iterator iterator_from(const T::value_type& val);\r\n\r\ntemplate <associative_container T>\r\nT::iterator iterator_from_key(const T::key_type& val);\r\n\r\ntemplate <associative_container T>\r\nT::iterator iterator_from_mapped(T::mapped_type& val);\r\n\r\ntemplate <associative_container T>\r\nT::const_iterator iterator_from_key(const T::mapped_type& val);\r\n```\r\nСтдлибы/компиляторы знают типы нод своих контейнеров и могут гарантировать корректность такого преобразования, поэтому фича реализуема как минимум для стандартных контейнеров. В случае некорректной ссылки или элемента, не лежащего в соответствующем контейнере, разумеется, UB.\r\n\r\nТакие методы позволили бы некоторые сценарии работы с обычными контейнерами, которые ранее были доступны только интрузивным.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/44/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/44/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/43",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/43/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/43/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/43/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/43",
    "id": 830895360,
    "node_id": "MDU6SXNzdWU4MzA4OTUzNjA=",
    "number": 43,
    "title": "std::(forward_)list::extract/insert",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T13:07:10Z",
    "updated_at": "2021-03-13T15:02:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -3\r\n_Автор идеи:_ **Antervis**\r\n\r\nИдея: добавить к std::list и std::forward_list пары методов extract/insert по аналогии с ассоциативными контейнерами",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/43/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/43/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/42",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/42/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/42/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/42/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/42",
    "id": 830895002,
    "node_id": "MDU6SXNzdWU4MzA4OTUwMDI=",
    "number": 42,
    "title": "explicit using declaration",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T13:05:05Z",
    "updated_at": "2021-03-16T22:28:30Z",
    "closed_at": "2021-03-16T22:28:30Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -3\r\n_Автор идеи:_ **Nikolay Rapotkin** @Rapotkinnik\r\n\r\nДобавить модификатор explicit к using объявлению, который бы делал объявляемый тип не просто alias'ом, а прям новым типом c explicit конструктором он исходного типа. Под капотом может быть использован, например, tag dispatching как предлагают тут https://github.com/joboccara/NamedType.\r\n\r\n```cpp\r\nexplicit using Uid = std::string;\r\n\r\nvoid foo(Uid uid) {\r\n  // ...\r\n};\r\n\r\nfoo(\"Hello\"); // wrong\r\nfoo(Uid{\"Hello\"}); // ok\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/42/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/42/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/41",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/41/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/41/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/41/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/41",
    "id": 830893991,
    "node_id": "MDU6SXNzdWU4MzA4OTM5OTE=",
    "number": 41,
    "title": "std::cyclic_iterator",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T12:59:41Z",
    "updated_at": "2021-03-13T15:08:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -1\r\n_Автор идеи:_ **Денис Черников**\r\n\r\nДобавить обёртку над контейнерами, итераторами или диапазонами, которая по достижении конца автоматически вернётся в начало. Полезно для стандартных алгоритмов, в которых у (одной из) последовательностей не требуется указывать конец (количество итераций зависит от другого диапазона). Gjktpyj lkz \r\n\r\n[Набросок на gist.github.com](https://gist.github.com/deiuch/8e82306596a6cd876f4b72ef5e012054)",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/41/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/41/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/40",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/40/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/40/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/40/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/40",
    "id": 830893845,
    "node_id": "MDU6SXNzdWU4MzA4OTM4NDU=",
    "number": 40,
    "title": "Метод empty для stringstream",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-13T12:58:53Z",
    "updated_at": "2021-03-13T14:16:17Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +7, -1\r\n_Автор идеи:_ **Semyon Sergiev** @sergiev\r\n\r\nСейчас, чтобы проверить stringstream на наличие несчитанных символов, требуется использовать следующую конструкцию:\r\n`my_stringstream.rdbuf()->in_avail()==0`\r\n\r\nПочему бы не добавить метод empty, дабы укоротить эту инструкцию до следующей?\r\n`my_stringstream.empty()`",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/40/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/40/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/39",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/39/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/39/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/39/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/39",
    "id": 830893625,
    "node_id": "MDU6SXNzdWU4MzA4OTM2MjU=",
    "number": 39,
    "title": "Дедукция вывода типа для auto",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T12:57:31Z",
    "updated_at": "2021-03-13T15:08:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Максим Некипелов**\r\n\r\nВ языке не помешал бы инструмент, который позволял добавить дедукцию для вывода типа в auto. Предлагаю добавить ключевое слово auto_deduction, которое и будет этим заниматься.\r\n\r\nКак это работает сейчас:\r\n```cpp\r\ntemplate<class T>\r\nstruct Property\r\n{\r\n    operator T() const { return { }; }\r\n};\r\n\r\nint main()\r\n{\r\n    auto value = Property<int>{ }; // auto будет иметь тип Property<int>\r\n}\r\n```\r\n\r\nКак предлагаю сделать:\r\n```cpp\r\ntemplate<class T>\r\nstruct Property\r\n{\r\n    operator T() const { { }; }\r\n};\r\n\r\ntemplate<class T>\r\nauto_deduction Property<T> = T;\r\n\r\nint main()\r\n{\r\n    auto value = Property<int>{ }; // будет иметь тип int\r\n}\r\n```\r\n\r\nТакже для этого дела не помешала перегрузка:\r\n```cpp\r\ntemplate<class T>\r\nstruct Property\r\n{\r\n    operator T() const { { }; }\r\n};\r\n\r\ntemplate<class T>\r\nauto_deduction Property<T> = T;\r\n\r\nauto_deduction Property<float> = double;\r\n\r\nint main()\r\n{\r\n    auto value = Property<float>{ }; // будет иметь тип double\r\n}\r\n```\r\n\r\nНу и аналогично поддержку концептов из C++ 20.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/39/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/39/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/38",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/38/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/38/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/38/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/38",
    "id": 830882599,
    "node_id": "MDU6SXNzdWU4MzA4ODI1OTk=",
    "number": 38,
    "title": "Свойства (property)",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T11:52:42Z",
    "updated_at": "2021-03-14T10:04:29Z",
    "closed_at": "2021-03-14T10:04:29Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -6\r\n_Автор идеи:_ **Максим Некипелов**\r\n\r\nВо многих уже существующих языках используются свойства для изменения состояния объекта, в C++ их можно написать самому, но натыкаясь на очень много костылей. Почему бы не добавить их в язык и совместить с прелестями C++?\r\n\r\nВ реализации C++ от Microsoft и от Borland уже можно найти жалкое подобие свойств в виде этого:\r\n```cpp\r\nstruct A\r\n{\r\n\tvoid Set(int value) { }\r\n\tint Get() { return 1; }\r\n\t__declspec(property(put=Set, get=get)) MyProperty;\r\n};\r\n```\r\nК минусам:\r\n\r\n1) Сеттер и геттер живут все еще не в свойстве и засоряют пространство имен класса\r\n\r\n2) Невозможно получить указатель на поле (самый главный минус)\r\n`&A::MyProperty // ошибка`\r\n3) Код свойства (геттеров и сеттеров) может повторяться, а менятся только то, с чем взаимодействуем, но его все равно нужно копипастить. Как так? У нас же метапрограммирование\r\n\r\nМотивация использования данного чуда:\r\n\r\nНаверное тут мотивация может отсутвовать только у мазохиста. Но может кто-то не понимает область использования свойств, поэтому демонстрация:\r\n\r\n`Control.SetPosition(Control.GetPosition() + { 100.f, 100.f });`\r\nКак видим не очень красиво. А вот так уже красиво (код превращается в то, что выше, только это компилятор генерирует сам):\r\n\r\n`Control.Position += { 100.f, 100.f };`\r\nНо это мелочи по сравнению с тем, что пойдет дальше. У вас есть класс шаблон, который как-то обрабатывает поля у объекта, которые передаются в шаблон, используя операторы =, /, +, -, +=, -= и т.д., а вы туда не можете передать ваш Position, потому что при его изменении нужно вызывать Get и Set, а писать отдельную специализацию шаблона под указатели на методы банально лень. Тут все таки метапрограммирование как никак.\r\n\r\nОсобенно станет обидно когда в C++23 добавят рефлексию, а у вас тут методами все обмазано. По нормальному это должно все делаться через свойства. Думаю многие из вас видели редакторы и уровней в играх, и контролов для пользовательких приложений и там было окошечко со свойствами какого-то объекта. Задача банальная, а без свойств перерастает в ужастики. Конечно, можно написать свои свойства, но выглядит это все очень колхозно с кучей костылей.\r\n\r\nЯ предалагю добавить в язык ключевые слова: property, set, set_const, get, get_const, value.\r\n\r\nset - для создания скопа кода, который будет вызываться при использовании операторов =, +=, -= и т.д. у свойства.\r\n\r\nget - для создания скопа кода, который будет вызываться для приведения свойства в тип данных, которое оно оборачивает, также внутри операторов +=, -= и т.д.\r\n\r\nТ.е. свойство при += ведет себя так (псевдокод):\r\n```cpp\r\ntype temp = get();\r\ntemp += value;\r\nset(temp);\r\nreturn temp;\r\n```\r\nДля +: \r\n```cpp\r\nreturn get() + right;\r\n```\r\n\r\nДля других операторов думаю принцип работы понятен.\r\n\r\nproperty также как class может взаимодействовать с template. Объект-пустышку свойства возможно определить только внутри класса или структуры (то что имеет внутри себя this если говорить проще). На него можно получить указатель как на обычный член класса (это очень обязательное условие, иначе все идеи использования свойств совместно с рефлексией отпадают), только тип поля будет определятся по типу которое наследует свойство (чтобы при доставании типа данных через специализацию, которое храни свойство, все было хорошо). Внутри скопа также будет доступен this, который будет указателем на класс, внутри которого находится свойство. Теперь пример  кода:\r\n```cpp\r\n#include <iostream>\r\n\r\n// Внешнее определение нового шаблонного свойства, которое устанавливает значение полю возводя его во вторую степень\r\ntemplate<auto Field>\r\nproperty PPow2 : float // value может быть float\r\n{\r\n\tset // скоп сеттера, работает только внутри скопа property\r\n\t{\r\n\t\t(this->*Field) = value * value; // this это Vehicle*, value содержит новое значение, действует только внутри set и set_const\r\n\t}\r\n\r\n\tget_const // скоп константного геттера, работает только внутри скопа property\r\n\t{\r\n\t\treturn this->*Field; // this это const Vehicle*, const из-за get_const, в обычном get указатель будет не константный\r\n\t}\r\n};\r\n\r\nclass Vehicle\r\n{\r\nprivate:\r\n\tfloat _Health = 0.f;\r\n\r\n\tvoid AddSeat()\r\n\t{\r\n\t\tstd::cout << \"NEW SEAT\" << std::endl;\r\n\t}\r\n\r\n\tunsigned _MaxPassenger = 0;\r\n\r\npublic:\r\n\tPPow2<&Vehicle::_Health> Health;\r\n\r\n\t// Внутреннее определение свойства (без имени)\r\n\tproperty : unsigned\r\n\t{\r\n\t\tset\r\n\t\t{\r\n\t\t\tfor (unsigned i = 0; i < value; ++i)\r\n\t\t\t\tAddSeat();\r\n\r\n\t\t\t_MaxPassenger = value;\r\n\t\t}\r\n\r\n\t\tget_const\r\n\t\t{\r\n\t\t\treturn _MaxPassenger;\r\n\t\t}\r\n\t}\r\n\tMaxPassenger = 100;\r\n};\r\n\r\nconstexpr unsigned Vehicle::* MaxPassenger = &Vehicle::MaxPassenger;\r\n\r\nint main()\r\n{\r\n\tVehicle infernus;\r\n\t\r\n\tinfernus.*MaxPassenger = 1337;\r\n\tinfernus.Health = 100.f;\r\n}\r\n```\r\n\r\nДумаю объяснил все максимально кратко и доступно. Если какой-то момент не понятен могу дополнить. Возможно уже кто-то предлагал данную идею, но я не нашел.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/38/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/38/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/37",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/37/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/37/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/37/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/37",
    "id": 830882199,
    "node_id": "MDU6SXNzdWU4MzA4ODIxOTk=",
    "number": 37,
    "title": "Оператор redirect вместо перегрузки точки",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T11:50:04Z",
    "updated_at": "2021-03-20T07:35:24Z",
    "closed_at": "2021-03-20T07:35:14Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -10\r\n_Автор идеи:_ **Максим Некипелов**\r\n\r\nДобавить оператор, который будет перенаправлять поле на другой объект, в случае если компилятор не нашел поля в данном объекте через оператор точки.\r\n\r\nВ некоторых ситуациях для удобства нужно перегрузить точку, но это выглядело бы очень странно и не понятно как работало.\r\n\r\nПредлагаю добавить новый оператор redirect, который будет переадресовывать поле на другой объект, если компилятор его не нашел в действующем. Пример:\r\n```cpp\r\n#include <iostream>\r\n\r\nstruct Vector\r\n{\r\n    float X = 0.f;\r\n};\r\n\r\ntemplate<class T>\r\nstruct Property\r\n{\r\n    T Get() const { { }; }\r\n\r\n    redirect Get;\r\n};\r\n\r\nint main()\r\n{\r\n    Property<Vector> property;\r\n    std::cout << property.X << std::endl; // поле X не было найдено внутри Property<Vector>, поэтому компилятор начинает его искать в Vector, если находит неявно преображает обращение в property.Get().X\r\n}\r\n ```\r\nНа получение указателя поля:\r\n```cpp\r\n&Property<Vector>::X\r\n```\r\nЭто распространяться не должно. Будет выдаваться ошибка.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/37/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/37/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/36",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/36/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/36/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/36/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/36",
    "id": 830871241,
    "node_id": "MDU6SXNzdWU4MzA4NzEyNDE=",
    "number": 36,
    "title": "Добавить пару комбинаторных функций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035680,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njgw",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/good%20first%20issue",
        "name": "good first issue",
        "color": "7057ff",
        "default": true,
        "description": "Несложная на вид идея. Самое то, чтобы попробовать написать на её proposal и помочь РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-13T10:43:32Z",
    "updated_at": "2021-03-13T14:18:57Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +4, -1\r\n_Автор идеи:_ **Ayrtat**\r\n\r\nЗачастую в проектном коде применяются эвристические алгоритмы, подразумевающие какой-нибудь перебор чисел или объектов в контейнере.\r\nВ данном случае речь идет о генерации всех перестановок с повторениями (permutation with repetition) или же сочетаний (combinations).\r\nКроме того, такие функции очень часто могут пригодится в олимпиадном программировании (хотя, очевидно, от авторов задач предполагается создавать такие функции с нуля, вручную).\r\nМой поинт - избавить программиста, участвующего в коммерческой разработке:\r\nА) Писать самостоятельно C-style генерации в виде вложенных семиэтажных циклов for;\r\nБ) Разрабатывать полноценный алгоритм, который будет работать только с контейнерами, поддерживающие RandomAccessIterator.\r\nВ) Делать код нечитаемым и дублируемым, несочетающимся с другими STL-фукнкциями\r\nПредлагаю навязать разработчику использование стандарта для отличной совместимости с другими STL-функциями, контейнерами и сделать код более читаемым!\r\nКак итог: добавить генерацию перестановок с повторениями (permutation with repetition) и генерацию сочетаний (combinations).\r\n\r\n```cpp\r\ntemplate<typename InputIt, typename T>\r\nbool nextPermutationWithRepetition(InputIt begin, InputIt end, T from_value, T to_value) {\r\n\tauto it = std::find_if_not(std::make_reverse_iterator(end),\r\n\tstd::make_reverse_iterator(begin),\r\n\t[&to_value](auto current) { return to_value == current; });\r\n\r\n\tif (it == std::make_reverse_iterator(begin))\r\n\t\treturn false;\r\n\r\n\tauto bound_element_iterator = std::prev(it.base());\r\n\r\n\t(*bound_element_iterator)++;\r\n\tstd::fill(std::next(bound_element_iterator), end, from_value);\r\n\r\n\treturn true;\r\n}\r\n\r\ntemplate<typename InputIt, typename T>\r\nbool nextCombination(InputIt begin,\r\n\t\t     InputIt end,\r\n\t\t     T toElement) {\r\n\tconst auto lengthOfSubsequence = std::distance(begin, end);\r\n\tauto pos = lengthOfSubsequence;\r\n\r\n\tauto viewed_element_it = std::make_reverse_iterator(end);\r\n\tauto reversed_begin = std::make_reverse_iterator(begin);\r\n\r\n\t/*Looking for this element here*/\r\n\r\n\twhile ((viewed_element_it != reversed_begin) && \r\n               (*viewed_element_it >= toElement - lengthOfSubsequence + std::distance(viewed_element_it, reversed_begin))) \r\n        { viewed_element_it++; }\r\n\r\n\tif (viewed_element_it == reversed_begin)\r\n\t\treturn false;\r\n\r\n\tauto it = std::prev(viewed_element_it.base());\r\n\r\n\tstd::iota(it, end, *it + 1); //with C++17\r\n\r\n\treturn true;\r\n}\r\n\r\n/* The example of usage */\r\n\r\nstd::list<int> vec(3);\r\n\r\ndo {\r\n    std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(std::cout, \" \"));\r\n    std::cout << std::endl;\r\n} while (nextPermutationWithRepetition(vec.begin(), vec.end(), 0, 2));\r\n```\r\n\r\n```cpp\r\nstd::list<int> vec = { 1, 2, 3 };\r\n\r\ndo {\r\n    std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(std::cout, \" \"));\r\n    std::cout << std::endl;\r\n} while (nextCombination(vec.begin(), vec.end(), 10));\r\n\r\n​\r\ntemplate<typename InputIt, typename T>\r\nbool nextPermutationWithRepetition(InputIt begin, InputIt end, T from_value, T to_value) {\r\n\tauto it = std::find_if_not(std::make_reverse_iterator(end),\r\n\tstd::make_reverse_iterator(begin),\r\n\t[&to_value](auto current) { return to_value == current; });\r\n\r\n\tif (it == std::make_reverse_iterator(begin))\r\n\t\treturn false;\r\n\r\n\tauto bound_element_iterator = std::prev(it.base());\r\n\r\n\t(*bound_element_iterator)++;\r\n\tstd::fill(std::next(bound_element_iterator), end, from_value);\r\n\r\n\treturn true;\r\n}\r\n\r\ntemplate<typename InputIt, typename T>\r\nbool nextCombination(InputIt begin,\r\n\t\t     InputIt end,\r\n\t\t     T toElement) {\r\n\tconst auto lengthOfSubsequence = std::distance(begin, end);\r\n\tauto pos = lengthOfSubsequence;\r\n\r\n\tauto viewed_element_it = std::make_reverse_iterator(end);\r\n\tauto reversed_begin = std::make_reverse_iterator(begin);\r\n\r\n\t/*Looking for this element here*/\r\n\r\n\twhile ((viewed_element_it != reversed_begin) && \r\n               (*viewed_element_it >= toElement - lengthOfSubsequence + \t\t\t\t\t\t\t\t\t  std::distance(viewed_element_it, reversed_begin))) { viewed_element_it++; }\r\n\r\n\tif (viewed_element_it == reversed_begin)\r\n\t\treturn false;\r\n\r\n\tauto it = std::prev(viewed_element_it.base());\r\n\r\n\tstd::iota(it, end, *it + 1); //with C++17\r\n\r\n\treturn true;\r\n}\r\n\r\n/* The example of usage */\r\n\r\nstd::list<int> vec(3);\r\n\r\ndo {\r\n    std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(std::cout, \" \"));\r\n    std::cout << std::endl;\r\n} while (nextPermutationWithRepetition(vec.begin(), vec.end(), 0, 2));\r\n\r\nstd::list<int> vec = { 1, 2, 3 };\r\n\r\ndo {\r\n    std::copy(vec.begin(), vec.end(), std::ostream_iterator<int>(std::cout, \" \"));\r\n    std::cout << std::endl;\r\n} while (nextCombination(vec.begin(), vec.end(), 10));\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/36/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/36/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/35",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/35/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/35/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/35/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/35",
    "id": 830870472,
    "node_id": "MDU6SXNzdWU4MzA4NzA0NzI=",
    "number": 35,
    "title": "Подмешивание новых методов уже существующим классам",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815035671,
        "node_id": "MDU6TGFiZWwyODE1MDM1Njcx",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/duplicate",
        "name": "duplicate",
        "color": "cfd3d7",
        "default": true,
        "description": "This issue or pull request already exists"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T10:38:52Z",
    "updated_at": "2021-03-19T17:21:40Z",
    "closed_at": "2021-03-19T17:21:31Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -7\r\n_Автор идеи:_ **valera_ee**\r\n\r\nДумаю, многие согласятся, что подход STL не очень удобен в использовании, когда алгоритмы живут сами по себе, а типы данных, к которым применяются эти алгоритмы, сами по себе. Не всегда очевидно какой алгоритм можно или нельзя использовать с тем или иным контейнером. Но STL уже не изменить, но можно улучшить.\r\nНа примере класса std::vector покажу, как я сделал его немного удобнее для себя.\r\n\r\nЕсть шаблонный класс, которы реализует некоторый алгоритм, например, заполнение контейнера некоторым значением:\r\n```cpp\r\ntemplate <class Container>\r\nclass add_fill\r\n{\r\npublic:\r\n    template<class Arg>\r\n    Container& fill(Arg &&arg) {\r\n        auto p = static_cast<Container*>(this);\r\n        std::fill(p->begin(), p->end(), arg);\r\n        return (*p);\r\n    }\r\n};\r\n```\r\nТеперь конструирую свой вектор на основе std:: vector :\r\n```cpp\r\ntemplate <class T>\r\nclass my_vector : public std::vector<T>,\r\n                  public add_fill<vector<T>>\r\n{\r\npublic:\r\n    template <class ...Args>\r\n    vector(Args&& ...args) : std::vector<T>(args...) {}\r\n    vector(std::initializer_list<T> init) : std::vector<T>(init) {}\r\n};\r\nТаким образом можно добавить множество алгоритмов и оно работает, но есть минус, я вынужден создавать новый тип через наследование.\r\n\r\nКуда удобнее написать что-то вроде:\r\n\r\ntemplate<class T>\r\nusing my_vector_t = std::vector<T, add_fill, add_copy, add_find, add_sort, add_transform>;\r\n\r\nmy_vector_t<int> my_vec;\r\nmy_vec.resize(N);\r\nmy_vec.fill(-200_dB);\r\nmy_vec.transform_from(other_vec, [](int val){ return 10*val - 5; });\r\nА для ещё большего удобства делать возвращаемый тип не void, а ссылку на себя, в таком случае можно писать так:\r\n\r\nmy_vec.resize(N).fill(-200_dB).transform_from(other_vec, [](int val){ \r\n    return 10*val - 5; \r\n});\r\n```\r\nЭтот приём позволяет много всего интересного и мой пример лишь малая часть, очень бы хотелось, что бы STL из коробки давал возможность создавать удобные типы на основе уже существующих без наследования.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/35/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/35/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/34",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/34/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/34/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/34/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/34",
    "id": 830870235,
    "node_id": "MDU6SXNzdWU4MzA4NzAyMzU=",
    "number": 34,
    "title": "Конструктор для string_view, хранящий длину литерала",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-13T10:37:33Z",
    "updated_at": "2023-11-12T10:56:29Z",
    "closed_at": "2023-11-12T10:56:18Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -4\r\n_Автор идеи:_ **Денис Черников**\r\n\r\nВ некоторых случаях мог бы быть полезен шаблонный конструктор std::string_view (с шаблонным параметром std::size_t N), принимающий массив CharT и инициализирующий длину контейнера равной шаблонному N.\r\n\r\nP.S.: не проверял, будет ли это конфликтовать с текущими перегрузками конструктора.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/34/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/34/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/33",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/33/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/33/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/33/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/33",
    "id": 830870041,
    "node_id": "MDU6SXNzdWU4MzA4NzAwNDE=",
    "number": 33,
    "title": "Вывод std::chrono с точностью до наносекунд",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-13T10:36:25Z",
    "updated_at": "2021-03-13T11:11:17Z",
    "closed_at": "2021-03-13T11:11:16Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -0\r\n_Автор идеи:_ **_NN_**\r\n\r\nРешается сегодня через стороннюю библиотеку, хотя должно быть частью стандарта.\r\n\r\nhttps://github.com/HowardHinnant/date/blob/master/include/date/date.h\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class Precision>\r\nstring getISOCurrentTimestamp()\r\n{\r\n    auto now = chrono::system_clock::now();\r\n    return date::format(\"%FT%TZ\", date::floor<Precision>(now));\r\n}\r\n\r\nint main() {\r\n\r\n cout << getISOCurrentTimestamp<chrono::nanoseconds>();   \r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/33/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/33/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/32",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/32/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/32/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/32/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/32",
    "id": 830867764,
    "node_id": "MDU6SXNzdWU4MzA4Njc3NjQ=",
    "number": 32,
    "title": "Интерфейсы(с виртуальными и невиртуальными методами)",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-13T10:22:31Z",
    "updated_at": "2021-03-13T10:46:04Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -5\r\n_Автор идеи:_ **Виталий Псевдокенко**\r\n\r\nИнтерфейсы в общем нужны для избежания ошибок при написания самого тела класса(то есть как можно раньше, а не при передаче объекта как аргумента функции или вообще багов на рантайме в случае использование множественного наследования), а также для подсказок IDE и автогенерации кода. Виртуальные интерфейсы для избежания проблем с множественным наследованием. Невиртуальные интерфейсы наподобие концептов в с++20, а также как их дополнение.\r\n\r\n1 Интерфейсы в целом.\r\n\r\n1.1 Для объявления интерфейса используется контекстное слово “interface” вместе с ключевым словом “class”\r\n```cpp\r\nclass interface MyInterface{\r\n    // *** \r\n};\r\n```\r\n1.2 Объявления реализации интерфейса осуществляется так же как и при наследовании класса от другого класса, только без указания модификатора доступа наследования.\r\n```cpp\r\nclass interface MyInterface: OtherInterface1, OtherInterface2{\r\n    // *** \r\n};\r\n```\r\n1.3 При реализации интерфейса запрещается множественное наследование от классов(целесообразность этого пункта под вопросом)\r\n\r\n1.4 Интерфейс может использоваться так же как и концепт (под капотом компилятор создаёт концепт без имени с проверкой std::is_base_of):\r\n```cpp\r\ntemplate<MyInterface T>\r\nvoid func(T x);\r\n```\r\n1.5 Уточнения std::is_base_of для интерфейсов, и/или добавление отдельного библиотечного класса для такой проверки.\r\n\r\n1.6 Методы с реализацией по умолчанию:\r\n```cpp\r\nclass interface MyInterface{\r\n    // Метод без реализации\r\n    void test();\r\n    \r\n    // Метод с реализацией по умолчанию вне тела класа или с реализацией компилятора(к \r\n    // примеру операторы сравнения начиная с c++20\r\n    void test2() = default;\r\n\r\n    // Метод с реализацией по умолчанию внутри класа\r\n    void test3() = default {\r\n        // ...\r\n    }\r\n};\r\n```\r\n1.7 Для всех модификаторов доступа разрешены пользовательские типы и статические члены.\r\n\r\n1.8 Для модификатора доступа “protected” разрешены также методы с реализацией по умолчанию.\r\n\r\n1.9 Для модификатора доступа “public” разрешены также методы с и без реализации.\r\n\r\n1.10 Для модификатора доступа “private” разрешено все то же что и в обычном классе, а также приватный конструктор по умолчанию, который всегда вызывается только конструкторами реализующих классов или в интерфейсах, которые расширяют интерфейс.\r\n\r\n1.11 Члены с модификатором “private” используются методами с реализацией по умолчанию.\r\n\r\n1.12 Для переопределения метода при колизии используется ключевое слово “using”: \r\n```cpp\r\nclass interface MyInterfaceA{\r\n    int test(int a, int b) = default{\r\n       return a + b;\r\n    }\r\n};\r\n\r\nclass interface MyInterfaceB {\r\n    int test(int a, int b) = default{\r\n       return a + b;\r\n    }\r\n};\r\n\r\nclass interface MyInterfaceC: MyInterfaceA, MyInterfaceB {\r\n    using int MyInterfaceB::test(int a, int b);\r\n};\r\n\r\nclass MyClass: MyInterfaceA, MyInterfaceB {\r\n    using int MyInterfaceA::test(int a, int b);\r\n};\r\n```\r\n\r\n1.13 Модификатор доступа по умолчанию - “public” .\r\n\r\n1.14 Определения виртуального или невиртульного метода:\r\n```cpp\r\nclass interface MyInterfaceA{\r\n    void test1();\r\n    virtual void test2();\r\n};\r\n\r\nclass interface MyInterfaceB: MyInterfaceA{\r\n    void test1() = default{\r\n        // ...\r\n    }\r\n\r\n    virtual void test2();\r\n};\r\n\r\nclass MyClassB: MyInterfaceB{\r\n\r\n};\r\n\r\nclass interface MyInterfaceC: MyInterfaceB{\r\n    virtual void test2() = default{\r\n        // ...\r\n    }\r\n};\r\n\r\nclass MyClassC: MyInterfaceC{\r\n\r\n};\r\n\r\nint main(){\r\n   MyInterfaceA * ptr; // ОШИБКА: у интерфейса есть нереализованые невиртуальные методы \r\n   MyInterfaceB * ptr; // ОК\r\n\r\n   MyClassB obj; // ОШИБКА: у интерфейса есть нереализованые виртуальные методы\r\n   MyClassC obj; // ОК\r\n\r\n}\r\n```\r\n\r\n2 Невиртуальные методы интерфейса\r\n\r\n2.1 Разрешается использования “override”, “final”, “= 0”   для невиртуальных методов интерфейса для проверки в классе реализации метода:\r\n```cpp\r\nclass interface MyInterface{\r\n    void test1();\r\n\r\n    void test_final();};\r\nclass MyClass1{public:\r\n    void test1() override { //...} // ОК\r\n    void test2() override { //...} // ОШИБКА\r\n\r\n    void test_final() final override { // ...}}\r\nclass MyClass2: public MyClass1{public:\r\n    void test_final() override { // ...} // ОШИБКА\r\n    void test_final() { // ...}          // ОК}\r\n}\r\n```\r\n\r\n2.2 Специальная конструкция для определения типа класса, который реализуюет невиртуальный метод (определяется при каждой реализации, так как невиртуальный метод недоступен по ссылке или указателю интерфейса или класса, который не реализует метод); (используется как синтаксический сахар над CRTP, и в случае переопределения метода):\r\n```cpp\r\nclass interface MyInterface{\r\n\r\n    auto test(); // auto - может содержать тип класса, который реализует интерфейс\r\n}\r\n\r\nclass MyClass1: MyInterface{\r\n\r\n     MyClass1 test() override{//...} //ОК\r\n\r\n     int test() override{//...} //ОШИБКА \r\n}\r\n\r\nclass MyClass2: public MyClass1{\r\n\r\n     MyClass2 test() override{//...} //ОК\r\n\r\n}​\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/32/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/32/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/31",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/31/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/31/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/31/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/31",
    "id": 830310441,
    "node_id": "MDU6SXNzdWU4MzAzMTA0NDE=",
    "number": 31,
    "title": "Библиотека для Unit-тестирования",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T17:18:58Z",
    "updated_at": "2021-03-12T17:22:19Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +22, -5\r\n_Aвтор идеи:_ **Алексей Горностаев**\r\n\r\nНа текущий момент нет стандартных средств для модульного тестирования. Добавление библиотеки в качестве TS могло бы упростить развертывание тестов и сделать их легко переносимыми между платформами.\r\n\r\nИзвестные библиотеки:\r\nhttps://github.com/google/googletest\r\nhttp://www.boost.org/doc/libs/1_62_0/libs/test/doc/html/index.html\r\nhttps://msdn.microsoft.com/en-us/library/hh598953.aspx\r\nhttps://github.com/google/googletest",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/31/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/31/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/30",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/30/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/30/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/30/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/30",
    "id": 830304224,
    "node_id": "MDU6SXNzdWU4MzAzMDQyMjQ=",
    "number": 30,
    "title": "Функции (методы) расширения",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-12T17:09:45Z",
    "updated_at": "2021-03-20T07:39:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +5, -1\r\n_Aвтор идеи:_ **mezastel**\r\n\r\nВ текущей парадигме, чтобы добавить то или иное поведение классу, который нельзя менять, используются глобальные функции. Типичный пример - это строковые алгоритмы в Boost вроде boost::to_lower_copy(). Проблема с этими функциями - они все глобальны, их сложно искать, и цепочные вызовы таких функций вылгядят как f(g(x)) вместо x.g().f(). Хочется получать то же, что имеют разработчики C#, где методы расширения реализуются специальным ключевым словом.\r\n\r\nЯ предлагаю в С++ сделать то же самое вплоть до синтаксиса, то есть\r\n```cpp\r\nnamespace std\r\n{\r\n  static std::string to_lower_copy(this string s)\r\n  {\r\n    ...\r\n  }\r\n}\r\n```\r\nКлючевое слово `this` тут помечает функцию как функцию-расширение, так что ее можно использовать\r\n\r\n*   Естественным путем, т.е. `my_string.to_lower_copy()`\r\n*   Статическим путем, т.е. `std::to_lower_copy(my_string)`\r\n\r\nВторой способ нужен в случае коллизий между member functions и extension functions.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/30/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/30/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/29",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/29/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/29/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/29/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/29",
    "id": 830301149,
    "node_id": "MDU6SXNzdWU4MzAzMDExNDk=",
    "number": 29,
    "title": "Расширить алгоритмы, принимающие значение и бинарный предикат",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T17:05:15Z",
    "updated_at": "2021-03-12T17:06:36Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +2, -2\r\n_Aвтор идеи:_ **h4tred**\r\n\r\nЯзык добавил нам возможность использовать лямбды и передавать их в функции алгоритмов, но некоторые вызовы становятся громоздкими.\r\n\r\nНапример:\r\n```cpp\r\n  int myints[] = {1,2,3,4,5,4,3,2,1};\r\n  std::vector<int> v(myints,myints+9);                         // 1 2 3 4 5 4 3 2 1\r\n\r\n  // using default comparison:\r\n  std::sort (v.begin(), v.end());\r\n\r\n  auto it = std::binary_search(v.begin(), v.end(), 4, [](auto lhs, auto rhs) {\r\n    // тут может быть куда более сложная проверка\r\n    return lhs < rhs;\r\n  });\r\n```\r\n\r\nВ данном примере передача 4 и бинарного предиката избыточны. В случае использование лямбды контекст и так определён и значение для сравнения можно не передавать как в сам алгоритм, так и в лямбду. Кроме того, в некоторых сложных случаях само значение как таковое передать невозможно вообще, так как критерий сортировки и поиска может быть сложным.\r\n\r\nПример с использованием унарного предиката:\r\n```\r\n  auto it = std::binary_search(v.begin(), v.end(), [](auto value) {\r\n    // тут может быть куда более сложная проверка\r\n    return value < 4;\r\n  });\r\n```\r\nК подобным алгоритмам относятся:\r\n\r\n*    std::binary_search\r\n*    std::lower_bound\r\n*    std::upper_bound\r\n*    std::equal_range\r\n*    std::search_n\r\n\r\nПонятна необходимость использования общего компаратора с `std::sort` (или другими), ведь работа алгоритмов бинарного поиска основана на условии сортировки. С другой стороны, часто для сортировки сложных структур используется одно-два поля и искать запись только по этому полю становится неудобно: нужно передавать целый объект, что бы передать только одно/два поля. В случае сортировки эти объекты уже есть, в случае поиска - его нужно создать и заполнить самому.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/29/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/29/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/28",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/28/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/28/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/28/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/28",
    "id": 830289269,
    "node_id": "MDU6SXNzdWU4MzAyODkyNjk=",
    "number": 28,
    "title": "Возможность realloc",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T16:48:53Z",
    "updated_at": "2021-03-12T16:58:23Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +8, -1\r\n_Aвтор идеи:_ **h4tred**\r\n\r\nВ текущем виде, если нужно увеличить размер массива, мы вынуждены сначала аллоцировать новый, после чего делать копию/перемещение существующих элементов и освобождать память. Это объяснимо и применимо для типов у которых есть нетривиальные конструкторы копирования/перемещения, но не является оптимильным для простых типов.\r\n\r\nПримерный вид может быть таким:\r\n```cpp\r\nnew_ptr = new (old_ptr) Foo[new_size];\r\n```\r\nСигнатура для оператора new, может быть такой:\r\n```cpp\r\nvoid* operator new[] (size_t size, void *old_ptr, struct realloc_tag);\r\n```\r\nтег нужен, что бы не конфликтовать с существующей сигнатурой для placement new.\r\n\r\nПредложенный синтаксис в текущем виде применим для placement new, но может вызывать ряд проблем:\r\n\r\n*  http://stackoverflow.com/questions/15254/can-placement-new-for-arrays-be-used-in-a-portable-way\r\n*  http://stackoverflow.com/questions/4011577/placement-new-array-alignment\r\n\r\nЕсли кто-то осторожно работает с placement new для массивов, возможна поломка обратной совместимости. Что бы избежать возможно:\r\n\r\n    Добавление тега в вызов new:\r\n```\r\n    new (realloc_tag, old_ptr) Foo[new_size]​\r\n```\r\n    Использовать новый специальный оператор, напрример renew\r\n\r\nДанных механизм применим только для памяти выделенной при помощи new[].\r\n\r\nПоддержка со стороны языка нужна, что бы можно было отличить тип элемента массива и правильно принять решение: делать `realloc` или вызывать `new[]+move/copy+delete[]`.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/28/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/28/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/27",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/27/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/27/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/27/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/27",
    "id": 830283793,
    "node_id": "MDU6SXNzdWU4MzAyODM3OTM=",
    "number": 27,
    "title": "Making all instances of tag types inline",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T16:41:24Z",
    "updated_at": "2021-03-12T16:44:36Z",
    "closed_at": "2021-03-12T16:44:36Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +6, -1\r\n_Aвтор идеи:_ **Anton Bikineev**\r\n\r\nРасммотрим 3.2.6.2 [basic.def.odr](http://eel.is/c++draft/basic.def.odr):\r\n\r\nin each definition of D, corresponding names, looked up accordingly to 3.4, shall refer to an entity defined within the definition of D, or shall refer  to the same entity, after overload resolution and after matching of partial template specialization, except that a name can refer to\r\n\r\n- a non-volatile const object with internal or no linkage if the object\r\n- has the same literal type in all definitions of D,\r\n- is initialized with a constant expression,\r\n- is not odr-used, and\r\n- has the same value in all definitions of D.\r\n\r\nТеперь рассмотрим, к примеру, пример определения экзекьюшн-политики и параллельного алгоритма в стандартной библиотеке:\r\n```cpp\r\nconstexpr sequential_execution_policy seq{};\r\n\r\ntemplate<class ExecutionPolicy, class InputIterator>\r\ntypename std::iterator_traits<InputIt>::value_type reduce(\r\n    ExecutionPolicy&& policy, InputIt first, InputIt last);\r\n```\r\nВидно, что передача параметра по ссылке делает переменную odr-used. Следовательно, любой вызов алгоритма в инлайновой функции или шаблонной функции, определенной в различных единицах трансляции, приводит к odr-нарушению.\r\n\r\nВыдвигается идея сделать следующие объекты из стандартной библиотеки инлайновыми:\r\n```cpp\r\n    std::placeholders::_1, ...\r\n    piecewise_construct\r\n    allocator_arg\r\n    nullopt\r\n    ignore\r\n    defer_lock\r\n    try_to_lock\r\n    adopt_lock\r\n    seq\r\n    par\r\n    par_unseq\r\n```\r\nДанная проблема также рассмотрена в National Body комментах (GB28, FI9).",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/27/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/27/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/26",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/26/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/26/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/26/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/26",
    "id": 830234150,
    "node_id": "MDU6SXNzdWU4MzAyMzQxNTA=",
    "number": 26,
    "title": "Добавить возможности кортежей к агрегатам",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815256097,
        "node_id": "MDU6TGFiZWwyODE1MjU2MDk3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%92%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5",
        "name": "В работе",
        "color": "FBCA04",
        "default": false,
        "description": "Над идеей идёт активная работа в рамках РГ21"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-12T15:37:38Z",
    "updated_at": "2022-11-06T09:34:15Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +6, -2\r\n_Автор идеи:_ **Антон Полухин** @apolukhin\r\n\r\nstd::tuple и std::pair отлично подходяд для обобщённого программирования, однако у них есть недостатки. Во первых, использующий их код сложно читать и понимать:\r\n```cpp\r\nstruct auth_info_aggreagte {\r\n    std::int64_t id;\r\n    std::int64_t session_id;\r\n    std::int64_t source_id;\r\n    std::time_t valid_till;\r\n};\r\n\r\nusing auth_info_tuple = std::tuple<\r\n    std::int64_t,\r\n    std::int64_t,\r\n    std::int64_t,\r\n    std::time_t\r\n>;\r\n```\r\nОбъявление через структуру намного понятнее, видно за что какое поле отвечает, что в нём хранится. Использование структур тоже более понятное: return std::get<1>(value); сравните с return value.session_id;\r\n\r\nВо вторых, агрегаты предоставляют более эффективные операции копирования, присваивания и перемещения:\r\n```cpp\r\ntemplate <class T>\r\nconstexpr bool validate() {\r\n    static_assert(std::is_trivially_move_constructible_v<T>);\r\n    static_assert(std::is_trivially_copy_constructible_v<T>);\r\n    static_assert(std::is_trivially_move_assignable_v<T>);\r\n    static_assert(std::is_trivially_copy_assignable_v<T>);\r\n    return true;\r\n}\r\n\r\nconstexpr bool tuples_fail = validate<auth_info_tuple>(); // Проваливает большинство проверок\r\nconstexpr bool aggregates_are_ok = validate<auth_info_aggreagte>();\r\n```\r\nИз-за вышеозвученных причин, многие компании рекомендуют использовать агрегаты вместо кортежей.\r\n\r\nОднако, мы не можем использовать агрегаты в обобщённом коде (разве что мы воспользуемся библиотекой [Boost.PFR](https://www.boost.org/doc/libs/1_75_0/doc/html/boost_pfr.html)):\r\n```cpp\r\nnamespace impl {\r\n    template <class Stream, class Result, std::size_t... I>\r\n    void fill_fileds(Stream& s, Result& res, std::index_sequence<I...>) {\r\n        (s >> ... >> std::get<I>(res));\r\n    }\r\n}\r\n\r\ntemplate <class T>\r\nT ExecuteSQL(std::string_view statement) {\r\n    std::stringstream stream;\r\n    // some logic that feeds data into stream\r\n\r\n    T result;\r\n    impl::fill_fileds(stream, result, std::make_index_sequence<std::tuple_size_v<T>>());\r\n    return result;\r\n}\r\n\r\nconstexpr std::string_view query = \"SELECT id, session_id, source_id, valid_till FROM auth\";\r\nconst auto tuple_result = ExecuteSQL<auth_info_tuple>(query);\r\nconst auto aggreagate_result = ExecuteSQL<auth_info_aggreagte>(query); // does not compile\r\n\r\n// Можно проверить на https://godbolt.org/z/y49lya\r\n```\r\nДобавив функциональность кортежей к агрегатам мы получим все преимущества кортежей, не потеряв преимуществ агрегатов. Мы получим именованные кортежи.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/26/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/26/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/25",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/25/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/25/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/25/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/25",
    "id": 830233534,
    "node_id": "MDU6SXNzdWU4MzAyMzM1MzQ=",
    "number": 25,
    "title": "Making all std::char_traits functions constexpr",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-12T15:36:51Z",
    "updated_at": "2021-07-09T12:29:34Z",
    "closed_at": "2021-03-12T15:41:25Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +3, -0\r\n_Aвтор идеи:_ **Anton Bikineev**\r\n\r\nИдея сделать только 4 функции константными выражениями выглядит как ад-хок решение для string_view быть константным выражением. Почему некоторые функции остались без внимания? Что, если они будут нужны потом? Что вы скажете своим детям? Вы или они будете писать дефект репорт и еще один пропозал?\r\n\r\nКто-то может оказаться лучшим Нострадамусом чем я и сказать, что констэкпрессность не понадобится для других функций. Тогда давайте поподробнее про дефект репорты. Рассмотрим пару из них, которые, насколько я понимаю, были заапрувлены на митинге:\r\n\r\n*  DR2777:basic_string_view::copy should use char_traits::copy\r\n*  DR2778:basic_string_view is missing constexpr\r\n\r\nПервый репорт обязывает сделать basic_string_view::copy через char_traits::copy, а второй репорт, в частности, предлагает сделать basic_string_view::copy констэкспр. Но как вы сделаете the latter констэкспр без the former констэкспр?\r\n\r\nПредлагается наиболее полно реализовать констэкспрессность промежуточного уровня, а именно, char_traits, переходя к констэкпрессности более высокого уровня, а именно string_view.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/25/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/25/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/24",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/24/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/24/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/24/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/24",
    "id": 830232411,
    "node_id": "MDU6SXNzdWU4MzAyMzI0MTE=",
    "number": 24,
    "title": "enum explicit",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-03-12T15:35:23Z",
    "updated_at": "2021-03-12T15:35:30Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +8, -1\r\n_Автор идеи:_ **Pavel**\r\n\r\nВ C++17 можно инициализировать enum значением которого в нём не объявлено:\r\n\r\n```cpp\r\nenum class Handle { Invalid };\r\nHandle h { 42 }; // OK as of C++17\r\n```\r\n\r\nКак бы получается, что в функции/методе, где нужет тот же Handle надо делать обработку невалидных значений, что уже исключительная ситуация. Может всё-таки стоит сделать enum, который никуда не кастится и не преобразуется. Получается такие недотип или полукласс с известными значениями. То есть существуют значения только явно объявленные в перечислении и никакие больше. Синтаксис легко сделать как enum explicit - благо смысл передаёт точно.\r\n\r\nВ объяснении на [cppreference пришут](https://en.cppreference.com/w/cpp/language/enum), что это позволяет всякие удобности на каких-то ABI, но такой безопасный enum тоже нужен. Сразу пропадает необходимость проверки валидности. Ну и это в принципе в канве type safety.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/24/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/24/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/23",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/23/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/23/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/23/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/23",
    "id": 830229193,
    "node_id": "MDU6SXNzdWU4MzAyMjkxOTM=",
    "number": 23,
    "title": "Boost.Sort",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:31:11Z",
    "updated_at": "2021-03-12T15:31:50Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +4, -5\r\n_Aвтор идеи:_ **Александр Зайцев** @ZaMaZaN4iK\r\n\r\nДанная библиотека имеет сортировки, которые выигрывают по скорости во многих случаях у std::sort. Также в библиотеке, возможно, позже появится имплементация TimSort, который уже есть в Python и OpenJDK.\r\n\r\nБолее подробная информация: http://www.boost.org/doc/libs/1_62_0/libs/sort/doc/html/index.html",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/23/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/23/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/22",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/22/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/22/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/22/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/22",
    "id": 830226301,
    "node_id": "MDU6SXNzdWU4MzAyMjYzMDE=",
    "number": 22,
    "title": "Библиотека для логирования",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:27:34Z",
    "updated_at": "2021-03-12T15:28:11Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +13, -4\r\n_Aвтор идеи:_ **Александр Зайцев** @ZaMaZaN4iK\r\n\r\nНа данный момент в C++ крайне слабая система логирования - clog ни на что не годится. Было бы неплохо иметь в библиотеке более мощную библиотеку логирования. Варианты: Boost.Log, spdlog, log4cplus, pantheios, easyloggingpp. Быть может, что-то другое.\r\n \r\n\r\nhttp://www.boost.org/doc/libs/1_62_0/libs/log/doc/html/index.html\r\n\r\nhttps://github.com/gabime/spdlog\r\n\r\nhttps://github.com/easylogging/easyloggingpp\r\n\r\nhttp://www.pantheios.org/\r\n\r\nhttps://github.com/log4cplus/log4cplus",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/22/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/22/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/21",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/21/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/21/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/21/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/21",
    "id": 830214710,
    "node_id": "MDU6SXNzdWU4MzAyMTQ3MTA=",
    "number": 21,
    "title": "PIMPL or FastPIMPL delete",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:13:23Z",
    "updated_at": "2022-02-19T15:41:04Z",
    "closed_at": "2022-02-19T15:41:04Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -0\r\n_Автор идеи:_ **Мартынов Иван** @VanyaClassicTGN\r\n\r\nДоброго времени суток!\r\n\r\nДобавить ключевое слово import, которое скрывает по умолчанию внутренности модуля.\r\n\r\nС уважением, Мартынов Иван.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/21/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/21/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/20",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/20/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/20/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/20/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/20",
    "id": 830213290,
    "node_id": "MDU6SXNzdWU4MzAyMTMyOTA=",
    "number": 20,
    "title": "explicit assignment operator",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:12:18Z",
    "updated_at": "2021-03-13T15:07:01Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +12, -2\r\n_Автор идеи:_ **Топунов Владимир Андреевич**\r\n\r\nПодобно explicit конструктору запрещает неявное преобразование типа при присваивании\r\n\r\n```cpp\r\nstd::string s;\r\ns = 49; // Неявное преобразование int в char\r\nstd::cout << s << std::endl; // Вывод символа '1' \r\n```\r\n\r\n```cpp\r\nclass String\r\n{\r\npublic:\r\n    explicit operator = (char ch);\r\n...\r\n};\r\n\r\n...\r\n\r\nString s;\r\ns = 49; // Ошибка компиляции\r\ns = '1'; // OK\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/20/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/20/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/19",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/19/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/19/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/19/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/19",
    "id": 830210865,
    "node_id": "MDU6SXNzdWU4MzAyMTA4NjU=",
    "number": 19,
    "title": "Расширить static_cast для nested class",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:10:16Z",
    "updated_at": "2021-03-13T15:06:53Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -7\r\n_Автор идеи:_ **Максим Некипелов**\r\n\r\nДать возможность статически преобразовывать указатели вложенных классов на указатель держателя (вычислять смещение поля и отбавлять его от this). Конечно же для шаблона и если компилятор увидел связь.\r\n\r\nДать возможность данному примеру компилироваться:\r\n```cpp\r\ntemplate<class T>\r\nclass CWheel\r\n{\r\npublic:\r\n\tvoid Turn()\r\n\t{\r\n\t\tstatic_cast<T*>(this)->Velocity += 10.f; // сейчас тут ошибка\r\n\t}\r\n};\r\n\r\nclass CVehicle\r\n{\r\npublic:\r\n\tfloat Velocity = 0.f;\r\n\r\n\tCWheel<CVehicle> Wheel;\r\n};\r\n\r\ntemplate<class T>\r\nvoid ProcessWheel(CWheel<T>* wheel)\r\n{\r\n\twheel->Turn();\r\n}\r\n\r\nint main()\r\n{\r\n\tCVehicle car;\r\n\r\n\tProcessWheel(&car.Wheel);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/19/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/19/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/18",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/18/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/18/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/18/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/18",
    "id": 830209424,
    "node_id": "MDU6SXNzdWU4MzAyMDk0MjQ=",
    "number": 18,
    "title": "if inline constexpr",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:08:57Z",
    "updated_at": "2021-03-13T15:06:36Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +3, -8\r\n_Автор идеи:_ **Максим Некипелов**\r\n\r\nВозникает потребность расширить область видимости какого-то объекта за приделы скопа if constexpr. Наглядно в очень простом примере:\r\n```cpp\r\ntemplate<bool Input>\r\nvoid OutHello()\r\n{\r\n\tif constexpr (Input)\r\n\t{\r\n\t\tint value = 0;\r\n\t\tstd::cin >> value;\r\n\t}\r\n\r\n\tstd::cout << \"HELLO!\" << std::endl;\r\n\r\n\tif constexpr (Input)\r\n\t{\r\n\t\tstd::cout << \"input \" << value << std::endl; // не можем использовать value\r\n\t}\r\n}\r\n```\r\n\r\nКод приходится писать два раза для реализации этой логики.\r\n```cpp\r\ntemplate<bool Input>\r\nvoid OutHello()\r\n{\r\n\tif constexpr (Input)\r\n\t{\r\n\t\tint value = 0;\r\n\t\tstd::cin >> value;\r\n\r\n\t\tstd::cout << \"HELLO!\" << std::endl;\r\n\r\n\t\tstd::cout << \"input \" << value << std::endl; // можем использовать value\r\n\t}\r\n\telse\r\n\t\tstd::cout << \"HELLO!\" << std::endl; // ПОВТОР!\r\n}\r\n```\r\n\r\nНе очень приятное занятие. Особенно когда промежуток занимает значительное количество строк.\r\n\r\nПредлагаю добавить конструкцию if inline constexpr, которая не будет ограничивать область видимости объявленных в нем объектов. Проще говоря просто подставлять код (как #if #endif). Пример:\r\n```cpp\r\ntemplate<bool Input>\r\nvoid OutHello()\r\n{\r\n\tif inline constexpr (Input)\r\n\t{\r\n\t\tint value = 0;\r\n\t\tstd::cin >> value;\r\n\t}\r\n\r\n\tstd::cout << \"HELLO!\" << std::endl;\r\n\r\n\tif inline constexpr (Input)\r\n\t{\r\n\t\tstd::cout << \"input \" << value << std::endl; // ВСЕ ОК!\r\n\t}\r\n}\r\n```\r\nНужно понимать, что пример взят очень простой. И заранее отвечаю на возможно возникшие притензии:\r\n\r\nВынести эту переменную за приделы скопа, компилятор ее все равно вырежет за ненужностью!\r\n\r\nВо-первых компилятор напишет варнинг о неиспользуемой переменной, а во-вторых там может быть объект с тяжелым конструктором и т.д., который уже не вырезать.\r\n\r\nВынести этот промежуточный код в отдельную функцию и вызывай ее из этой! Никакого повторения кода.\r\n\r\nПромежуточный код может сильно зависить от каких-то переменных, которые объявлены выше. И в добавок сам производить переменные, которые будут использоваться ниже. Будет получаться не очень красиво. Лучше просто добавить новый оператор и возложить все обязаности на компилятор.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/18/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/18/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/17",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/17/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/17/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/17/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/17",
    "id": 830208023,
    "node_id": "MDU6SXNzdWU4MzAyMDgwMjM=",
    "number": 17,
    "title": "Boost.Intrusive",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:07:35Z",
    "updated_at": "2021-03-12T15:24:09Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +9, -1\r\n_Aвтор идеи:_ **Александр Зайцев** @ZaMaZaN4iK\r\n\r\nНа данный момент мы имеем в стандартной библиотеке неинтурзивные контейнеры. В некоторых операциях, где нам важна производительность(избежать допольнительных аллокаций памяти, `noexcept` гарантия, и т.д.) мы можем использовать интрузивные контейнеры. Очень хорошая имплементация имеется в Boost.\r\n\r\nhttps://www.boost.org/libs/intrusive",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/17/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/17/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/16",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/16/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/16/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/16/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/16",
    "id": 830207012,
    "node_id": "MDU6SXNzdWU4MzAyMDcwMTI=",
    "number": 16,
    "title": "std::string_view есть, а куда его засунуть — нет",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:06:32Z",
    "updated_at": "2021-03-13T15:06:29Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +10, -0\r\n_Автор идеи:_ **ldvsoft**\r\n\r\nНадо перебрать все методы, принимающие строчки в качестве аргументов для «посмотреть», потому что не во все из них можно передать std::string_view, хотя казалось бы.\r\n\r\nЯ начал писать код с активным использованием std::string_view и обнаружил, что хватает мест, куда std::string_view передать напрямую нельзя, а хочется. Например:\r\n\r\n1. Конструктор std::bitset (принимает std::string const & или char const * на пару с позициями начала и конца, это же как раз std::string_view),\r\n2. std::stol и её друзья,\r\n3. std::from_chars туда же.\r\n4. Методы поиска и доступа в std::map и std::unordered_map: сейчас имея на руках std::string_view приходится строить полную std::string лишь бы проверить, лежит ли в мапе нужное значение, что точно избыточно. Оно вполне может заслуживать отдельного пропозала на гетерогенный поиск в контейнерах, подобных множествам (std::set туда же). Понятно, что универсальный код контейнеров вряд ли может рассчитывать, чтобы компаратор/хешер строчек умел принимать дополнительные типы, но очень уж неудобно получается. Неявное приведение std::string_view→std::string решило бы проблему, но мы понимаем, что так делать скорее не надо. Всю эту проблему можно решить храня множество каноничных std::string и используя отображения std::string_view на каноничную→Value, но удобство уменьшается. Наверное тут ситуация будет похожая и для случаев, когда в контейнере ищут другой контейнер по range необходимых элементов, но со стороны это точно другая проблема.\r\n\r\nЕсли последний пункт в целом заслуживает абсолютно отдельного разговора (хотя если вдруг мы можем его относительно просто решить то давайте!), то и без него технически мелких вещей хватает, потому что приходится класть std::string_view в переменную и передавать по кускам, а добавить перегрузку не должно ломать ABI. Более того, возможно стоит задуматься об устаревании старых куч перегрузок, все из которых сводятся к передаче аналогов std::string_view, и в будущем дизайнить подобные методы/функции аккуратнее.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/16/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/16/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/15",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/15/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/15/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/15/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/15",
    "id": 830205824,
    "node_id": "MDU6SXNzdWU4MzAyMDU4MjQ=",
    "number": 15,
    "title": "Стандартизация SIMD инструкций",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:05:24Z",
    "updated_at": "2021-03-13T11:19:33Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +2, -2\r\n_Автор идеи:_ **Игорь Буренков**\r\n\r\nДля использования SSE и AVX инструкций мы подключаем библиотеки:\r\n\r\n`#include \"xmmintrin.h\"`\tили `#include <x86intrin.h>`\r\nВидите? Уже здесь наблюдается нестыковка в виде множества библиотек, часть из которых проприетарна.\r\n\r\nРассмотрим пример SSE инструкции:\r\n```cpp\r\n#include \"iostream\"\r\n#include \"xmmintrin.h\"\t\r\n\r\nint main()\r\n{\r\n\tconst auto N = 8;\r\n\r\n\talignas(16) float a[] = { 41982.0,  81.5091, 3.14, 42.666, 54776.45, 342.4556, 6756.2344, 4563.789 };\r\n\talignas(16) float b[] = { 85989.111,  156.5091, 3.14, 42.666, 1006.45, 9999.4546, 0.2344, 7893.789 };\r\n\t\r\n\t__m128* a_simd = reinterpret_cast<__m128*>(a);\r\n\t__m128* b_simd = reinterpret_cast<__m128*>(b);\r\n\r\n        auto size = sizeof(float);\r\n        void *ptr = _aligned_malloc(N * size, 32);\r\n\tfloat* c = reinterpret_cast<float*>(ptr);\r\n\t\r\n        for (size_t i = 0; i < N/2; i++, a_simd++, b_simd++, c += 4)\r\n\t\t_mm_store_ps(c, _mm_add_ps(*a_simd, *b_simd));\r\n\tc -= N;\r\n\r\n\tstd::cout.precision(10);\r\n\tfor (size_t i = 0; i < N; i++)\r\n\t\tstd::cout << c[i] << std::endl;\r\n\r\n\t_aligned_free(ptr);\r\n\r\n\tsystem(\"PAUSE\");\r\n\treturn 0;\r\n}\r\n```\r\nМало того, что этот код выглядит мало понятно из-за всяких __m128 и т.д., так программа, скомпилированная с SIMD не будет работать в системах без его. \r\n\r\nА, возращаясь к вопросам производительности на ядро - AVX и SSE позволяет ускорить производительность на ядро от 8 (SSE) до 16 (AVX) раз.\r\nТакже стоит обратить внимание, что раньше монополистом данной технологии была Intel и SIMD использовалась исключительно в серверных процессорах, однако сейчас SIMD можно встретить и в потребительском сегменте, а также у компании-конкурента AMD.\r\n\r\nЭто показывает важность интеграции новой технологии, что поддерживается практически всеми современными CPU x86. Причем интеграция не должна останавливаться на ассемблерообразном коде, приведя код к удобному и практичному виду. Также важно добавить провеки наличия SIMD и возможность использования SIMD объектов на процессорах без онных инструкций, пусть и с потерей производительности. Это позволит ускорить современное ПО без потери обратной совместимости, а также ускорить разработку и дальнейшую поддержку кода с использованием SIMD инструкций.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/15/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/15/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/14",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/14/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/14/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/14/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/14",
    "id": 830205336,
    "node_id": "MDU6SXNzdWU4MzAyMDUzMzY=",
    "number": 14,
    "title": "Boost.Bimap",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T15:04:53Z",
    "updated_at": "2021-03-12T15:05:34Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +8, -3\r\n_Aвтор идеи:_ **Александр Зайцев** @ZaMaZaN4iK\r\n\r\nВ отличие от `std::map`, где ключом у Вас может быть только одно значение, в Boost.Bimap ключом у Вас может быть каждое из значений, что довольно удобно. Было бы неплохо добавить это в стандарт.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/14/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/14/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/13",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/13/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/13/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/13/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/13",
    "id": 830137620,
    "node_id": "MDU6SXNzdWU4MzAxMzc2MjA=",
    "number": 13,
    "title": "Безопасный аналог printf",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815246228,
        "node_id": "MDU6TGFiZWwyODE1MjQ2MjI4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++20",
        "name": "C++20",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++20"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-12T13:50:14Z",
    "updated_at": "2021-03-12T14:00:21Z",
    "closed_at": "2021-03-12T14:00:20Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +16, -0\r\n_Aвтор идеи:_ **Александр Зайцев** @ZaMaZaN4iK\r\n\r\nНа данный момент мы можем выводить либо через потоки, что получается довольн громоздко (например, когда нам надо выввести с некоторой точностью), либо через printf, который не контролирует, что мы ему передадим. Хотелось бы в стандарте иметь вещь, которая сочетает их свойства. \r\n\r\nНапример, вот это: https://github.com/fmtlib/fmt",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/13/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/13/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/12",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/12/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/12/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/12/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/12",
    "id": 830128633,
    "node_id": "MDU6SXNzdWU4MzAxMjg2MzM=",
    "number": 12,
    "title": "Базовый тип byte",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815245408,
        "node_id": "MDU6TGFiZWwyODE1MjQ1NDA4",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++17",
        "name": "C++17",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++17"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T13:39:25Z",
    "updated_at": "2021-03-12T13:47:50Z",
    "closed_at": "2021-03-12T13:47:50Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +20, -1\r\n_Aвтор идеи:_ **y.belykhav**\r\n\r\nВ C++ нет встроенного типа byte . Для представления байтовых значений используется тип `unsigned char`.\r\n\r\nНе красиво выглядет `char` - символ. Все делают свой byte|BYTE.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/12/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/12/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/11",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/11/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/11/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/11/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/11",
    "id": 830125078,
    "node_id": "MDU6SXNzdWU4MzAxMjUwNzg=",
    "number": 11,
    "title": "Парсер json",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T13:35:09Z",
    "updated_at": "2021-03-12T13:38:12Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +19, -8\r\n_Aвтор идеи:_ **Андрей Урусов**\r\n\r\nНа рынке много неплохих библиотек, но хочется из коробки со всеми плюшками. jsoncpp довольно удобный, но с его помощью не получается валидировать. В бусте парсер сериализует только в propertytree.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/11/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/11/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/10",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/10/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/10/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/10/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/10",
    "id": 830092492,
    "node_id": "MDU6SXNzdWU4MzAwOTI0OTI=",
    "number": 10,
    "title": "Именованные параметры функции",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-12T12:55:42Z",
    "updated_at": "2021-04-06T19:08:11Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +35, -8\r\n_Aвтор идеи:_ **smikler**\r\n\r\nЕсли у функции (метода) есть больше одного параметра с дефолтными настройками - дать возможность её вызывать с указанием только тех параметров, которые надо задать (остальные берутся по умолчанию).\r\n\r\nТакая функциональность есть, например, в языке Python.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/10/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/10/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/9",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/9/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/9/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/9/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/9",
    "id": 830080212,
    "node_id": "MDU6SXNzdWU4MzAwODAyMTI=",
    "number": 9,
    "title": "Классы для получения backtrace",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815247857,
        "node_id": "MDU6TGFiZWwyODE1MjQ3ODU3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/C++23",
        "name": "C++23",
        "color": "0E8A16",
        "default": false,
        "description": "Реализовано, в стандарте начиная с C++23"
      },
      {
        "id": 2815260277,
        "node_id": "MDU6TGFiZWwyODE1MjYwMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%A1%D0%B4%D0%B5%D0%BB%D0%B0%D0%BD%D0%BE%20%D0%B2%20%D0%A0%D0%9321",
        "name": "Сделано в РГ21",
        "color": "0E8A16",
        "default": false,
        "description": "Идея реализована с участием РГ21"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-12T12:39:34Z",
    "updated_at": "2021-04-06T19:06:59Z",
    "closed_at": "2021-03-12T12:47:45Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +36, -6\r\n_Aвтор идеи:_ **Антон Полухин** @apolukhin\r\n\r\nНа данный момент в С++ нет изкоробочного метода для получения стека вызовов и работы с ним. Предлагаю придумать такие методы и классы, написать прототип и сделать егостандартом языка.\r\n\r\nНа данный момент есть прототип, который активно мной дописывается [stacktrace](https://github.com/boostorg/stacktrace):\r\n\r\n```cpp\r\nstd::stacktrace s;\r\nstd::cout << s;     // выведет стектрейс\r\n\r\nstd::cout << s[0];  // выведет текущую функцию, например:\r\n// foo(int)    ../example/getting_started.cpp:29\r\n```\r\n\r\nПожалуста, расскажите чего вам не хватает в прототипе и что вам кажется в нём неправильным.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/9/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/9/timeline",
    "performed_via_github_app": null,
    "state_reason": "completed"
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/8",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/8/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/8/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/8/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/8",
    "id": 830073190,
    "node_id": "MDU6SXNzdWU4MzAwNzMxOTA=",
    "number": 8,
    "title": "Добавить возможность миксинов в язык С++",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T12:30:13Z",
    "updated_at": "2021-03-13T15:06:16Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +1, -5\r\n_Автор идеи:_ **Мартынов Иван** @VanyaClassicTGN\r\n\r\nДоброго времени суток, друзья.\r\n\r\nсейчас миксины добавляются следующийм образом\r\n```cpp\r\ntemplate <class T>\r\nclass B {}\r\n\r\nclass Derived : public B<Derived> {}\r\n```\r\nзаменить на \r\n```cpp\r\nclass Derived : public mixin B {}\r\n```\r\nС уважением, Мартынов Иван.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/8/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/8/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/7",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/7/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/7/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/7/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/7",
    "id": 830071712,
    "node_id": "MDU6SXNzdWU4MzAwNzE3MTI=",
    "number": 7,
    "title": "Класс для работы с плавающей запятой по стандарту ieee 754",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T12:28:11Z",
    "updated_at": "2021-03-13T15:06:10Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +0, -5\r\n_Автор идеи:_ **Мартынов Иван** @VanyaClassicTGN\r\n\r\nДоброго времени суток, друзья.\r\n\r\nХочется забыть о fuzzy_compare в пользовательском коде приложений. Хочется забыть о любых тонкостях в использовании чисел с плавающей запятой.\r\n\r\nПривожу на Ваш суд свой класс работы с плавающей точкой. \r\nhttps://github.com/VanyaClassicTGN/Utils/blob/main/Float.h\r\n\r\nПозволяет писать такой код:\r\n\r\n`float_t a = 10; float_t b = 0.3;`\r\n\r\n`auto res = a + b;`\r\n\r\nили `bool flag = a > b;`\r\n\r\nДополнительно реализовано бинарное сравнение чисел с плавающей точкой.\r\n\r\nС уважением, Мартынов Иван Евгеньевич",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/7/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/7/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/6",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/6/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/6/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/6/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/6",
    "id": 830043363,
    "node_id": "MDU6SXNzdWU4MzAwNDMzNjM=",
    "number": 6,
    "title": "Ослабить требование к второму аргументу в static_assert",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T11:50:45Z",
    "updated_at": "2021-03-13T15:06:04Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +43, -0\r\n_Автор идеи:_ **Александр Караев** @smertig\r\n\r\nТекущая версия стандарта требует, чтобы второй аргумент static_assert'а являлся string literal, что не позволяет использовать в нём constexpr char*\r\n\r\nПри написании библиотек/вспомогательных шаблонных классов разработчики часто используют static_assert для контроля входных данных и промежуточных результатов. Однако сообщения, выдаваемые при нарушении обязательств, должны быть строковыми литералами. Так как сама проверка может происходить где-то в недрах библиотеки, то и выдать универсальное понятное сообщение не всегда представляется возможным. \r\n\r\nПредложение состоит в том, чтобы разрешить использование constexpr char* значений в качестве второго аргумента static_assert. Это позволит писать код с более информативными сообщениями об ошибках времени компиляции.\r\n\r\nПредставим старый код:\r\n```cpp\r\n#include <type_traits>\r\n#include <string>\r\n\r\ntemplate <class... Args>\r\nclass foo {\r\n  static_assert(std::conjunction_v<std::is_pod<Args>...>, \"All args must be pod!\");\r\n};\r\n\r\nint main() {\r\n\tfoo<int, std::string, float> f;\r\n}\r\n```\r\nСообщение об ошибке будет соответствующим. А теперь представим, что каждый из аргументов - это синоним типа и их более десятка. И какой-то из них после очередного рефакторинга перестал быть POD. На поиск источника проблемы уйдёт драгоценное время.\r\n\r\nА теперь новый код, если предложение примут:\r\n```cpp\r\ntemplate <class... Args>\r\nclass foo {\r\n  static_assert(std::conjunction_v<std::is_pod<Args>...>, compile_time_joiner(\"All args must be pod, but \", type_name<find_non_pod<Args...>>, \" isn't\"));\r\n};\r\n```\r\nПреимущество очевидно. На данный момент существует несколько реализаций compile-time строк, множество алгоритмов для работы с типами, поэтому реализация compile_time_joiner, type_name<..> и find_non_pod<...> - не проблема. С учётом того, что идёт активная работа над рефлексией, то упростится и работа с типами. Там подоспеет и аналог sprintf времени компиляции. А раз у нас будет более удобное метапрограммирование, значит нужны и информативные сообщения об ошибках!",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/6/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/6/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/5",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/5/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/5/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/5/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/5",
    "id": 830040518,
    "node_id": "MDU6SXNzdWU4MzAwNDA1MTg=",
    "number": 5,
    "title": "constexpr std::regex",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-12T11:46:51Z",
    "updated_at": "2021-03-13T15:05:54Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +45, -1\r\n_Автор идеи:_ **Антон Полухин** @apolukhin\r\n\r\nМножество языков программирования в данный момент компилируют/транслируют регулярные выражения ещё перед запуском программы. Таким образом, когда программа стартует, все регулярные выражения уже преобразованы в соптимизированный конечный автомат.\r\n\r\nПредлагаю добавить подобную возможность и для C++.\r\n```cpp\r\nbool is_valid_mail(std::string_view mail) {\r\n    static const std::regex mail_regex(R\"((?:(?:[^<>()\\[\\].,;:\\s@\\\"]+(?:\\.[^<>()\\[\\].,;:\\s@\\\"]+)*)|\\\".+\\\")@(?:(?:[^<>()\\[\\].,;:\\s@\\\"]+\\.)+[^<>()\\[\\].,;:\\s@\\\"]{2,}))\");\r\n\r\n    return std::regex_match(\r\n        std::cbegin(mail),\r\n        std::cend(mail),\r\n        mail_regex\r\n    );\r\n}\r\n```\r\nВ коде выше конечный автомат из регулярного выражения будет строится при первом заходе в функцию is_valid_mail(). Это долгая операция, которая в добавок будет выполняться в критической секции.\r\n\r\nС готовящимися новинками для constexpr вычислений (constexpr new, is_constexpr_evaluated() и др.) можно будет в C++20 делать множество вещей на этапе компиляции, в том числе можно будет сделать constexpr std::regex.\r\n\r\nС constexpr std::regex конечный автомат для функции is_valid_mail() построится ещё на этапе компиляции. Более того, GCC сможет генерировать оптимизированные регулярки на этапе компиляции без static const, т.к. начиная с GCC-6 если у constexpr функции все параметры на вход — константы, GCC форсирует вычисление на этапе компиляции. [Багрепорт](https://bugs.llvm.org//show_bug.cgi?id=37415) на добавление аналогично функционала в Clang уже есть",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/5/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/5/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/4",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/4/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/4/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/4/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/4",
    "id": 830027853,
    "node_id": "MDU6SXNzdWU4MzAwMjc4NTM=",
    "number": 4,
    "title": "Обернуть аргументы программы в С++ классы",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T11:29:56Z",
    "updated_at": "2021-04-06T18:54:45Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +49, -0\r\n_Автор идеи:_ **Дмитрий Ковальков**\r\n\r\nПередавать строки как указатель на char и массивы как размер + указатель на начало уже выглядит устаревшим и противоречит core guidelines.\r\n\r\nСейчас:\r\n```cpp\r\nint main(int argc, char **argv)\r\n```\r\nХочется:\r\n```cpp\r\nint main(std::span<std::string_view> args)\r\n```\r\nСразу будут доступны итераторы/удобное сравнение/substr и т.д.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/4/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/4/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/3",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/3/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/3/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/3/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/3",
    "id": 830018605,
    "node_id": "MDU6SXNzdWU4MzAwMTg2MDU=",
    "number": 3,
    "title": "Работа с сетью",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815551289,
        "node_id": "MDU6TGFiZWwyODE1NTUxMjg5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9F%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%20%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D0%BE%D0%BC",
        "name": "Помощь советом",
        "color": "FEF2C0",
        "default": false,
        "description": "Идея прорабатывается другими участниками международного коммитета"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-03-12T11:18:15Z",
    "updated_at": "2021-04-06T18:54:19Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +58, -1\r\n_Автор идеи:_ **maksimus1210**\r\n\r\nЛюбое современное ПО требует работы с сетью, а отсутствие в стандартной библиотеке таких классов заставляет искать альтернативы и переход на другой язык программирования, в языке GO очень развитая библиотека для работы с сетью и если требуется реализовать HTTP сервер, то я зык GO идеально подходит для этого.",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/3/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/3/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/2",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/2/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/2/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/2",
    "id": 829957353,
    "node_id": "MDU6SXNzdWU4Mjk5NTczNTM=",
    "number": 2,
    "title": "Принять в стандарт RAII класс для работы с динамическими библиотеками",
    "user": {
      "login": "Neargye",
      "id": 7997966,
      "node_id": "MDQ6VXNlcjc5OTc5NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7997966?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Neargye",
      "html_url": "https://github.com/Neargye",
      "followers_url": "https://api.github.com/users/Neargye/followers",
      "following_url": "https://api.github.com/users/Neargye/following{/other_user}",
      "gists_url": "https://api.github.com/users/Neargye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Neargye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Neargye/subscriptions",
      "organizations_url": "https://api.github.com/users/Neargye/orgs",
      "repos_url": "https://api.github.com/users/Neargye/repos",
      "events_url": "https://api.github.com/users/Neargye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Neargye/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2021-03-12T10:06:27Z",
    "updated_at": "2021-04-06T18:57:44Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_ голоса +43, -2\r\n_Автор идеи:_ **Антон Полухин** @apolukhin\r\n\r\nПредлагаю стандартизировать [Boost.DLL](https://github.com/boostorg/dll), чтобы можно было с лёгкостью делать плагины и импортировать функции по мере необходимости из динамических библиотек:\r\n\r\n```cpp\r\nauto cpp11_func = dll::import<int(std::string&&)>(\r\n    \"libmy.so\", \"i_am_a_cpp11_function\"\r\n);\r\n\r\ncpp11_func(\"'Hello word' that is sent to shared library\");\r\n```\r\n\r\nПредложение уже доступно по адресу: [P0275](https://wg21.link/p0275)\r\n\r\nПриветствуются любые предложения по улучшению proposal или Boost.DLL!",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/2/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/2/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/cpp-ru/ideas/issues/1",
    "repository_url": "https://api.github.com/repos/cpp-ru/ideas",
    "labels_url": "https://api.github.com/repos/cpp-ru/ideas/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/cpp-ru/ideas/issues/1/comments",
    "events_url": "https://api.github.com/repos/cpp-ru/ideas/issues/1/events",
    "html_url": "https://github.com/cpp-ru/ideas/issues/1",
    "id": 829941732,
    "node_id": "MDU6SXNzdWU4Mjk5NDE3MzI=",
    "number": 1,
    "title": "Атрибут [[visible]], упрощающий создание динамических библиотек.",
    "user": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 2815531277,
        "node_id": "MDU6TGFiZWwyODE1NTMxMjc3",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/%D0%9D%D0%B0%20%D0%BF%D0%B0%D1%83%D0%B7%D0%B5",
        "name": "На паузе",
        "color": "D93F0B",
        "default": false,
        "description": "Международный комитет холодно встретил идею, нужно переосмыслить идею и вернуться к ней позднее"
      },
      {
        "id": 2890256979,
        "node_id": "MDU6TGFiZWwyODkwMjU2OTc5",
        "url": "https://api.github.com/repos/cpp-ru/ideas/labels/++",
        "name": "++",
        "color": "D2F663",
        "default": false,
        "description": "Популярная идея (более чем с 20 лайками)"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "apolukhin",
      "id": 1700098,
      "node_id": "MDQ6VXNlcjE3MDAwOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolukhin",
      "html_url": "https://github.com/apolukhin",
      "followers_url": "https://api.github.com/users/apolukhin/followers",
      "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
      "organizations_url": "https://api.github.com/users/apolukhin/orgs",
      "repos_url": "https://api.github.com/users/apolukhin/repos",
      "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolukhin/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "apolukhin",
        "id": 1700098,
        "node_id": "MDQ6VXNlcjE3MDAwOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apolukhin",
        "html_url": "https://github.com/apolukhin",
        "followers_url": "https://api.github.com/users/apolukhin/followers",
        "following_url": "https://api.github.com/users/apolukhin/following{/other_user}",
        "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions",
        "organizations_url": "https://api.github.com/users/apolukhin/orgs",
        "repos_url": "https://api.github.com/users/apolukhin/repos",
        "events_url": "https://api.github.com/users/apolukhin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/apolukhin/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 3,
    "created_at": "2021-03-12T09:47:55Z",
    "updated_at": "2021-09-25T07:26:21Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "_Перенос предложения:_  голоса +44, -3\r\n_Aвтор идеи:_ **Антон Полухин** @apolukhin\r\n\r\nНаверное многие сталкивались с ситуацией, что чтобы создать динамическую биюлиотеку или плагин, необходимо написать подобный код:\r\n```cpp\r\n    #if EXPORTING\r\n    #   if MSVC\r\n    #       define API __declspec(dllexport)\r\n    #   else\r\n    #       define API __attribute__((visibility(\"default\")))\r\n    #   endif\r\n    #else\r\n    #   if MSVC\r\n    #       define API __declspec(dllimport)\r\n    #   else\r\n    #       define API\r\n    #   endif\r\n    #endif\r\n```\r\nПосле чего, все публичные методы библиотеки пометить описанным выше макросом API:\r\n```cpp\r\n    // Public interface\r\n    API bool grph_is_tree(graph* g);\r\n    API bool grph_is_directed(graph* g);\r\n```\r\nВ дальнешем нужно следить за параметрами сборки, правильно задавать макросы EXPORTING и возможно придется дорабатывать код (чтобы можно было собирать статические библиотеки с тем же заголовочным файлом, собираться на других платформах и т.п.)\r\n\r\nТак вот, предлагаю сделать атрибут `[[visible]]`, который берёт эту задачу на себя. Предложение уже доступно по адресу https://wg21.link/p0276r0\r\n\r\nС радостью выслушаю любые идеи и замечания к предложению!\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/cpp-ru/ideas/issues/1/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/cpp-ru/ideas/issues/1/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
